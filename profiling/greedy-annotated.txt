*** File /usr/include/c++/9/bits/basic_string.h:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21 Strings library
                //
                
                #ifndef _BASIC_STRING_H
                #define _BASIC_STRING_H 1
                
                #pragma GCC system_header
                
                #include <ext/atomicity.h>
                #include <ext/alloc_traits.h>
                #include <debug/debug.h>
                
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                #if __cplusplus >= 201703L
                # include <string_view>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201703L
                // Support P0426R1 changes to char_traits in C++17.
                # define __cpp_lib_constexpr_string 201611L
                #endif
                
                #if _GLIBCXX_USE_CXX11_ABI
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _Char_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
                
                      // Types:
                    public:
                      typedef _Traits					traits_type;
                      typedef typename _Traits::char_type		value_type;
                      typedef _Char_alloc_type				allocator_type;
                      typedef typename _Alloc_traits::size_type		size_type;
                      typedef typename _Alloc_traits::difference_type	difference_type;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef typename _Alloc_traits::pointer		pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                							const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    protected:
                      // type used for positions in insert, erase etc.
                #if __cplusplus < 201103L
                      typedef iterator __const_iterator;
                #else
                      typedef const_iterator __const_iterator;
                #endif
                
                    private:
                #if __cplusplus >= 201703L
                      // A helper type for avoiding boiler-plate.
                      typedef basic_string_view<_CharT, _Traits> __sv_type;
                
                      template<typename _Tp, typename _Res>
                	using _If_sv = enable_if_t<
                	  __and_<is_convertible<const _Tp&, __sv_type>,
                		 __not_<is_convertible<const _Tp*, const basic_string*>>,
                		 __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
                	  _Res>;
                
                      // Allows an implicit conversion to __sv_type.
                      static __sv_type
                      _S_to_string_view(__sv_type __svt) noexcept
                      { return __svt; }
                
                      // Wraps a string_view by explicit conversion and thus
                      // allows to add an internal constructor that does not
                      // participate in overload resolution when a string_view
                      // is provided.
                      struct __sv_wrapper
                      {
                	explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
                	__sv_type _M_sv;
                      };
                
                      /**
                       *  @brief  Only internally used: Construct string from a string view
                       *          wrapper.
                       *  @param  __svw  string view wrapper.
                       *  @param  __a  Allocator to use.
                       */
                      explicit
                      basic_string(__sv_wrapper __svw, const _Alloc& __a)
                      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                #endif
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : allocator_type // TODO check __is_final
                      {
                #if __cplusplus < 201103L
                	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
                	: allocator_type(__a), _M_p(__dat) { }
                #else
                	_Alloc_hider(pointer __dat, const _Alloc& __a)
                	: allocator_type(__a), _M_p(__dat) { }
                
                	_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
                	: allocator_type(std::move(__a)), _M_p(__dat) { }
                #endif
                
                	pointer _M_p; // The actual data.
                      };
                
                      _Alloc_hider	_M_dataplus;
                      size_type		_M_string_length;
                
                      enum { _S_local_capacity = 15 / sizeof(_CharT) };
                
                      union
                      {
                	_CharT           _M_local_buf[_S_local_capacity + 1];
                	size_type        _M_allocated_capacity;
                      };
                
                      void
                      _M_data(pointer __p)
                      { _M_dataplus._M_p = __p; }
                
                      void
                      _M_length(size_type __length)
                      { _M_string_length = __length; }
                
                      pointer
                      _M_data() const
                      { return _M_dataplus._M_p; }
                
                      pointer
                      _M_local_data()
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
                #else
                	return pointer(_M_local_buf);
                #endif
                      }
                
                      const_pointer
                      _M_local_data() const
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
                #else
                	return const_pointer(_M_local_buf);
                #endif
                      }
                
                      void
                      _M_capacity(size_type __capacity)
                      { _M_allocated_capacity = __capacity; }
                
                      void
                      _M_set_length(size_type __n)
                      {
                	_M_length(__n);
                	traits_type::assign(_M_data()[__n], _CharT());
                      }
                
                      bool
                      _M_is_local() const
                      { return _M_data() == _M_local_data(); }
                
                      // Create & Destroy
                      pointer
                      _M_create(size_type&, size_type);
                
                      void
                      _M_dispose()
                      {
                	if (!_M_is_local())
                	  _M_destroy(_M_allocated_capacity);
                      }
                
                      void
                      _M_destroy(size_type __size) throw()
                      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
                
                      // _M_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIterator is an integral type
                      template<typename _InIterator>
                        void
                        _M_construct_aux(_InIterator __beg, _InIterator __end,
                			 std::__false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          _M_construct(__beg, __end, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
                	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }
                
                      void
                      _M_construct_aux_2(size_type __req, _CharT __c)
                      { _M_construct(__req, __c); }
                
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  _M_construct_aux(__beg, __end, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end,
                		     std::input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<typename _FwdIterator>
                        void
                        _M_construct(_FwdIterator __beg, _FwdIterator __end,
                		     std::forward_iterator_tag);
                
                      void
                      _M_construct(size_type __req, _CharT __c);
                
                      allocator_type&
                      _M_get_allocator()
                      { return _M_dataplus; }
                
                      const allocator_type&
                      _M_get_allocator() const
                      { return _M_dataplus; }
                
                    private:
                
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                      // The explicit instantiations in misc-inst.cc require this due to
                      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063
                      template<typename _Tp, bool _Requires =
                	       !__are_same<_Tp, _CharT*>::__value
                	       && !__are_same<_Tp, const _CharT*>::__value
                	       && !__are_same<_Tp, iterator>::__value
                	       && !__are_same<_Tp, const_iterator>::__value>
                	struct __enable_if_not_native_iterator
                	{ typedef basic_string& __type; };
                      template<typename _Tp>
                	struct __enable_if_not_native_iterator<_Tp, false> { };
                #endif
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);
                      }
                
                      static void
                      _S_assign(_CharT* __d, size_type __n, _CharT __c)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, (void)++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_assign(const basic_string&);
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
                		size_type __len2);
                
                      void
                      _M_erase(size_type __pos, size_type __n);
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                      _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)
                      : _M_dataplus(_M_local_data())
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct string with copy of value of @a __str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str)
                      : _M_dataplus(_M_local_data(),
                		    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
                      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2583. no way to supply an allocator for basic_string(str, pos)
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __start = __str._M_data()
                	  + __str._M_check(__pos, "basic_string::basic_string");
                	_M_construct(__start, __start + __str._M_limit(__pos, npos));
                      }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n)
                      : _M_dataplus(_M_local_data())
                      {
                	const _CharT* __start = __str._M_data()
                	  + __str._M_check(__pos, "basic_string::basic_string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __start
                	  = __str._M_data() + __str._M_check(__pos, "string::string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s + __n); }
                
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3076. basic_string CTAD ambiguity
                      template<typename = _RequireAllocator<_Alloc>>
                #endif
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
                
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3076. basic_string CTAD ambiguity
                      template<typename = _RequireAllocator<_Alloc>>
                #endif
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str) noexcept
                      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
                      {
                	if (__str._M_is_local())
                	  {
                	    traits_type::copy(_M_local_buf, __str._M_local_buf,
                			      _S_local_capacity + 1);
                	  }
                	else
                	  {
                	    _M_data(__str._M_data());
                	    _M_capacity(__str._M_allocated_capacity);
                	  }
                
                	// Must use _M_length() here not _M_set_length() because
                	// basic_stringbuf relies on writing into unallocated capacity so
                	// we mess up the contents if we put a '\0' in the string.
                	_M_length(__str.length());
                	__str._M_data(__str._M_local_data());
                	__str._M_set_length(0);
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__l.begin(), __l.end()); }
                
                      basic_string(const basic_string& __str, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__str.begin(), __str.end()); }
                
                      basic_string(basic_string&& __str, const _Alloc& __a)
                      noexcept(_Alloc_traits::_S_always_equal())
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	if (__str._M_is_local())
                	  {
                	    traits_type::copy(_M_local_buf, __str._M_local_buf,
                			      _S_local_capacity + 1);
                	    _M_length(__str.length());
                	    __str._M_set_length(0);
                	  }
                	else if (_Alloc_traits::_S_always_equal()
                	    || __str.get_allocator() == __a)
                	  {
                	    _M_data(__str._M_data());
                	    _M_length(__str.length());
                	    _M_capacity(__str._M_allocated_capacity);
                	    __str._M_data(__str._M_local_buf);
                	    __str._M_set_length(0);
                	  }
                	else
                	  _M_construct(__str.begin(), __str.end());
                      }
                
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<typename _InputIterator>
                #endif
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc())
                	: _M_dataplus(_M_local_data(), __a)
                	{ _M_construct(__beg, __end); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Construct string from a substring of a string_view.
                       *  @param  __t   Source object convertible to string view.
                       *  @param  __pos The index of the first character to copy from __t.
                       *  @param  __n   The number of characters to copy from __t.
                       *  @param  __a   Allocator to use.
                       */
                      template<typename _Tp, typename = _If_sv<_Tp, void>>
                	basic_string(const _Tp& __t, size_type __pos, size_type __n,
                		     const _Alloc& __a = _Alloc())
                	: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }
                
                      /**
                       *  @brief  Construct string from a string_view.
                       *  @param  __t  Source object convertible to string view.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<typename _Tp, typename = _If_sv<_Tp, void>>
                	explicit
                	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
                	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
                #endif // C++17
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string()
                      { _M_dispose(); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str)
                      {
                #if __cplusplus >= 201103L
                	if (_Alloc_traits::_S_propagate_on_copy_assign())
                	  {
                	    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
                		&& _M_get_allocator() != __str._M_get_allocator())
                	      {
                		// Propagating allocator cannot free existing storage so must
                		// deallocate it before replacing current allocator.
                		if (__str.size() <= _S_local_capacity)
                		  {
                		    _M_destroy(_M_allocated_capacity);
                		    _M_data(_M_local_data());
                		    _M_set_length(0);
                		  }
                		else
                		  {
                		    const auto __len = __str.size();
                		    auto __alloc = __str._M_get_allocator();
                		    // If this allocation throws there are no effects:
                		    auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                		    _M_destroy(_M_allocated_capacity);
                		    _M_data(__ptr);
                		    _M_capacity(__len);
                		    _M_set_length(__len);
                		  }
                	      }
                	    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                	  }
                #endif
                	return this->assign(__str);
                      }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s)
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c)
                      {
                	this->assign(1, __c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2063. Contradictory requirements for string move assignment
                      basic_string&
                      operator=(basic_string&& __str)
                      noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
                	    && !_Alloc_traits::_S_always_equal()
                	    && _M_get_allocator() != __str._M_get_allocator())
                	  {
                	    // Destroy existing storage before replacing allocator.
                	    _M_destroy(_M_allocated_capacity);
                	    _M_data(_M_local_data());
                	    _M_set_length(0);
                	  }
                	// Replace allocator if POCMA is true.
                	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                
                	if (__str._M_is_local())
                	  {
                	    // We've always got room for a short string, just copy it.
                	    if (__str.size())
                	      this->_S_copy(_M_data(), __str._M_data(), __str.size());
                	    _M_set_length(__str.size());
                	  }
                	else if (_Alloc_traits::_S_propagate_on_move_assign()
                	    || _Alloc_traits::_S_always_equal()
                	    || _M_get_allocator() == __str._M_get_allocator())
                	  {
                	    // Just move the allocated pointer, our allocator can free it.
                	    pointer __data = nullptr;
                	    size_type __capacity;
                	    if (!_M_is_local())
                	      {
                		if (_Alloc_traits::_S_always_equal())
                		  {
                		    // __str can reuse our existing storage.
                		    __data = _M_data();
                		    __capacity = _M_allocated_capacity;
                		  }
                		else // __str can't use it, so free it.
                		  _M_destroy(_M_allocated_capacity);
                	      }
                
                	    _M_data(__str._M_data());
                	    _M_length(__str.length());
                	    _M_capacity(__str._M_allocated_capacity);
                	    if (__data)
                	      {
                		__str._M_data(__data);
                		__str._M_capacity(__capacity);
                	      }
                	    else
                	      __str._M_data(__str._M_local_buf);
                	  }
                	else // Need to do a deep copy
                	  assign(__str);
                	__str.clear();
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value to string constructed from a string_view.
                       *  @param  __svt  An object convertible to string_view.
                       */
                     template<typename _Tp>
                       _If_sv<_Tp, basic_string&>
                       operator=(const _Tp& __svt)
                       { return this->assign(__svt); }
                
                      /**
                       *  @brief  Convert to a string_view.
                       *  @return A string_view.
                       */
                      operator __sv_type() const noexcept
                      { return __sv_type(data(), size()); }
                #endif // C++17
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.
                       */
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.
                       */
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() noexcept
                      {
                #if __cpp_exceptions
                	if (capacity() > size())
                	  {
                	    try
                	      { reserve(0); }
                	    catch(...)
                	      { }
                	  }
                #endif
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      {
                	return _M_is_local() ? size_type(_S_local_capacity)
                	                     : _M_allocated_capacity;
                      }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_set_length(0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_assert(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	__glibcxx_assert(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front() noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back() noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      {
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt  An object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	operator+=(const _Tp& __svt)
                	{ return this->append(__svt); }
                #endif // C++17
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str)
                      { return _M_append(__str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n = npos)
                      { return _M_append(__str._M_data()
                			 + __str._M_check(__pos, "basic_string::append"),
                			 __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	const size_type __n = traits_type::length(__s);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c)
                      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(end(), end(), __first, __last); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt  An object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        append(const _Tp& __svt)
                        {
                          __sv_type __sv = __svt;
                          return this->append(__sv.data(), __sv.size());
                        }
                
                      /**
                       *  @brief  Append a range of characters from a string_view.
                       *  @param __svt  An object convertible to string_view to be appended from.
                       *  @param __pos The position in the string_view to append from.
                       *  @param __n   The number of characters to append from the string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                	append(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return _M_append(__sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      {
                	const size_type __size = this->size();
                	if (__size + 1 > this->capacity())
                	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
                	traits_type::assign(this->_M_data()[__size], __c);
                	this->_M_set_length(__size + 1);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str)
                      {
                	this->_M_assign(__str);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string&
                      assign(basic_string&& __str)
                      noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2063. Contradictory requirements for string move assignment
                	return *this = std::move(__str);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
                      { return _M_replace(size_type(0), this->size(), __str._M_data()
                			  + __str._M_check(__pos, "basic_string::assign"),
                			  __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	return _M_replace(size_type(0), this->size(), __s, __n);
                      }
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return _M_replace(size_type(0), this->size(), __s,
                			  traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(begin(), end(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value from a string_view.
                       *  @param __svt  The source object convertible to string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	assign(const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->assign(__sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Set value from a range of characters in a string_view.
                       *  @param __svt  The source object convertible to string_view.
                       *  @param __pos  The position in the string_view to assign from.
                       *  @param __n  The number of characters to assign.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return _M_replace(size_type(0), this->size(),
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(const_iterator __p, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	this->replace(__p, __p, __n, __c);
                	return iterator(this->_M_data() + __pos);
                      }
                #else
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [beg,end).  If adding characters
                       *  causes the length to exceed max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	  const size_type __pos = __p - begin();
                	  this->replace(__p, __p, __beg, __end);
                	  return iterator(this->_M_data() + __pos);
                	}
                #else
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      iterator
                      insert(const_iterator __p, initializer_list<_CharT> __l)
                      { return this->insert(__p, __l.begin(), __l.end()); }
                
                #ifdef _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // See PR libstdc++/83328
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	this->insert(__p - begin(), __l.begin(), __l.size());
                      }
                #endif
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->replace(__pos1, size_type(0),
                			     __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n = npos)
                      { return this->replace(__pos1, size_type(0), __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::insert"),
                			     __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n)
                      { return this->replace(__pos, size_type(0), __s, __n); }
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, size_type(0), __s,
                			     traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(__const_iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	return iterator(_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos  Iterator referencing position in string to insert at.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	insert(size_type __pos, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->insert(__pos, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos  Iterator referencing position in string to insert at.
                       *  @param __svt  The object convertible to string_view to insert from.
                       *  @param __pos  Iterator referencing position in string_view to insert
                       *  from.
                       *  @param __n    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	insert(size_type __pos1, const _Tp& __svt,
                	       size_type __pos2, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, size_type(0),
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
                	      std::__sv_limit(__sv.size(), __pos2, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      {
                	_M_check(__pos, "basic_string::erase");
                	if (__n == npos)
                	  this->_M_set_length(__pos);
                	else if (__n != 0)
                	  this->_M_erase(__pos, _M_limit(__pos, __n));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()
                				 && __position < end());
                	const size_type __pos = __position - begin();
                	this->_M_erase(__pos, size_type(1));
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __first, __const_iterator __last)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last
                				 && __last <= end());
                        const size_type __pos = __first - begin();
                	if (__last == end())
                	  this->_M_set_length(__pos);
                	else
                	  this->_M_erase(__pos, __last - __first);
                	return iterator(this->_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() noexcept
                      {
                	__glibcxx_assert(!empty());
                	_M_erase(size() - 1, 1);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2)
                      {
                	__glibcxx_requires_string_len(__s, __n2);
                	return _M_replace(_M_check(__pos, "basic_string::replace"),
                			  _M_limit(__pos, __n1), __s, __n2);
                      }
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
                	      _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        basic_string&
                        replace(const_iterator __i1, const_iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
                					   std::__false_type());
                	}
                #else
                      template<class _InputIterator>
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                        typename __enable_if_not_native_iterator<_InputIterator>::__type
                #else
                        basic_string&
                #endif
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                #endif
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(const_iterator __i1, const_iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos  The position to replace at.
                       *  @param __n    The number of characters to replace.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(size_type __pos, size_type __n, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos, __n, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos1  The position to replace at.
                       *  @param __n1    The number of characters to replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  The position in the string_view to insert from.
                       *  @param __n2    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, __n1,
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
                	      std::__sv_limit(__sv.size(), __pos2, __n2));
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __i1    An iterator referencing the start position
                          to replace at.
                       *  @param __i2    An iterator referencing the end position
                          for the replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__i1 - begin(), __i2 - __i1, __sv);
                	}
                #endif // C++17
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _Integer __n, _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _InputIterator __k1, _InputIterator __k2,
                			    __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
                		 const size_type __len2);
                
                      basic_string&
                      _M_append(const _CharT* __s, size_type __n);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a pointer to internal data.  It is undefined to modify
                       *  the contents through the returned pointer. To get a pointer that
                       *  allows modifying the contents use @c &str[0] instead,
                       *  (or in C++17 the non-const @c str.data() overload).
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Return non-const pointer to contents.
                       *
                       *  This is a pointer to the character sequence held by the string.
                       *  Modifying the characters in the sequence is allowed.
                      */
                      _CharT*
                      data() noexcept
                      { return _M_data(); }
                #endif
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_get_allocator(); }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	rfind(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->rfind(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character of a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character not in a string_view.
                       *  @param __svt  A object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character not in a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const _GLIBCXX_NOEXCEPT;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __svt An object convertible to string_view to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  const size_type __size = this->size();
                	  const size_type __osize = __sv.size();
                	  const size_type __len = std::min(__size, __osize);
                
                	  int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                	  if (!__r)
                	    __r = _S_compare(__size, __osize);
                	  return __r;
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos  A position in the string to start comparing from.
                       *  @param __n  The number of characters to compare.
                       *  @param __svt  An object convertible to string_view to compare
                       *                against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos, size_type __n, const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this).substr(__pos, __n).compare(__sv);
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos1  A position in the string to start comparing from.
                       *  @param __n1  The number of characters to compare.
                       *  @param __svt  An object convertible to string_view to compare
                       *                against.
                       *  @param __pos2  A position in the string_view to start comparing from.
                       *  @param __n2  The number of characters to compare.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this)
                	    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                
                #if __cplusplus > 201703L
                      bool
                      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                #endif // C++20
                
                      // Allow basic_stringbuf::__xfer_bufptrs to call _M_length:
                      template<typename, typename, typename> friend class basic_stringbuf;
                    };
                _GLIBCXX_END_NAMESPACE_CXX11
                #else  // !_GLIBCXX_USE_CXX11_ABI
                  // Reference-counted COW string implentation
                
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   *
                   *  @doctodo
                   *
                   *
                   *  Documentation?  What's that?
                   *  Nathan Myers <ncm@cantrip.org>.
                   *
                   *  A string looks like this:
                   *
                   *  @code
                   *                                        [_Rep]
                   *                                        _M_length
                   *   [basic_string<char_type>]            _M_capacity
                   *   _M_dataplus                          _M_refcount
                   *   _M_p ---------------->               unnamed array of char_type
                   *  @endcode
                   *
                   *  Where the _M_p points to the first character in the string, and
                   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
                   *  pointer to the header.
                   *
                   *  This approach has the enormous advantage that a string object
                   *  requires only one allocation.  All the ugliness is confined
                   *  within a single %pair of inline functions, which each compile to
                   *  a single @a add instruction: _Rep::_M_data(), and
                   *  string::_M_rep(); and the allocation function which gets a
                   *  block of raw bytes and with room enough and constructs a _Rep
                   *  object at the front.
                   *
                   *  The reason you want _M_data pointing to the character %array and
                   *  not the _Rep is so that the debugger can see the string
                   *  contents. (Probably we should add a non-inline member to get
                   *  the _Rep for the debugger to use, so users can check the actual
                   *  string length.)
                   *
                   *  Note that the _Rep object is a POD so that you can have a
                   *  static <em>empty string</em> _Rep object already @a constructed before
                   *  static constructors have run.  The reference-count encoding is
                   *  chosen so that a 0 indicates one reference, so you never try to
                   *  destroy the empty-string _Rep object.
                   *
                   *  All but the last paragraph is considered pretty conventional
                   *  for a C++ string implementation.
                  */
                  // 21.3  Template class basic_string
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
                
                      // Types:
                    public:
                      typedef _Traits					    traits_type;
                      typedef typename _Traits::char_type		    value_type;
                      typedef _Alloc					    allocator_type;
                      typedef typename _CharT_alloc_type::size_type	    size_type;
                      typedef typename _CharT_alloc_type::difference_type   difference_type;
                #if __cplusplus < 201103L
                      typedef typename _CharT_alloc_type::reference	    reference;
                      typedef typename _CharT_alloc_type::const_reference   const_reference;
                #else
                      typedef value_type&				    reference;
                      typedef const value_type&				    const_reference;
                #endif
                      typedef typename _CharT_alloc_type::pointer	    pointer;
                      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                                            const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		    reverse_iterator;
                
                    protected:
                      // type used for positions in insert, erase etc.
                      typedef iterator __const_iterator;
                
                    private:
                      // _Rep: string representation
                      //   Invariants:
                      //   1. String really contains _M_length + 1 characters: due to 21.3.4
                      //      must be kept null-terminated.
                      //   2. _M_capacity >= _M_length
                      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
                      //   3. _M_refcount has three states:
                      //      -1: leaked, one reference, no ref-copies allowed, non-const.
                      //       0: one reference, non-const.
                      //     n>0: n + 1 references, operations require a lock, const.
                      //   4. All fields==0 is an empty string, given the extra storage
                      //      beyond-the-end for a null terminator; thus, the shared
                      //      empty string representation needs no constructor.
                
                      struct _Rep_base
                      {
                	size_type		_M_length;
                	size_type		_M_capacity;
                	_Atomic_word		_M_refcount;
                      };
                
                      struct _Rep : _Rep_base
                      {
                	// Types:
                	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
                
                	// (Public) Data members:
                
                	// The maximum number of individual char_type elements of an
                	// individual string is determined by _S_max_size. This is the
                	// value that will be returned by max_size().  (Whereas npos
                	// is the maximum number of bytes the allocator can allocate.)
                	// If one was to divvy up the theoretical largest size string,
                	// with a terminating character and m _CharT elements, it'd
                	// look like this:
                	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
                	// Solving for m:
                	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
                	// In addition, this implementation quarters this amount.
                	static const size_type	_S_max_size;
                	static const _CharT	_S_terminal;
                
                	// The following storage is init'd to 0 by the linker, resulting
                        // (carefully) in an empty string with one reference.
                        static size_type _S_empty_rep_storage[];
                
                        static _Rep&
                        _S_empty_rep() _GLIBCXX_NOEXCEPT
                        { 
                	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that
                	  // _S_empty_rep_storage is never modified and the punning should
                	  // be reasonably safe in this case.
                	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
                	  return *reinterpret_cast<_Rep*>(__p);
                	}
                
                        bool
                	_M_is_leaked() const _GLIBCXX_NOEXCEPT
                        {
                #if defined(__GTHREADS)
                          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,
                          // so we need to use an atomic load. However, _M_is_leaked
                          // predicate does not change concurrently (i.e. the string is either
                          // leaked or not), so a relaxed load is enough.
                          return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;
                #else
                          return this->_M_refcount < 0;
                #endif
                        }
                
                        bool
                	_M_is_shared() const _GLIBCXX_NOEXCEPT
                	{
                #if defined(__GTHREADS)
                          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,
                          // so we need to use an atomic load. Another thread can drop last
                          // but one reference concurrently with this check, so we need this
                          // load to be acquire to synchronize with release fetch_and_add in
                          // _M_dispose.
                          return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;
                #else
                          return this->_M_refcount > 0;
                #endif
                        }
                
                        void
                	_M_set_leaked() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = -1; }
                
                        void
                	_M_set_sharable() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = 0; }
                
                	void
                	_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      this->_M_set_sharable();  // One reference.
                	      this->_M_length = __n;
                	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                	      // grrr. (per 21.3.4)
                	      // You cannot leave those LWG people alone for a second.
                	    }
                	}
                
                	_CharT*
                	_M_refdata() throw()
                	{ return reinterpret_cast<_CharT*>(this + 1); }
                
                	_CharT*
                	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
                	{
                	  return (!_M_is_leaked() && __alloc1 == __alloc2)
                	          ? _M_refcopy() : _M_clone(__alloc1);
                	}
                
                	// Create & Destroy
                	static _Rep*
                	_S_create(size_type, size_type, const _Alloc&);
                
                	void
                	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      // Be race-detector-friendly.  For more info see bits/c++config.
                	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
                              // Decrement of _M_refcount is acq_rel, because:
                              // - all but last decrements need to release to synchronize with
                              //   the last decrement that will delete the object.
                              // - the last decrement needs to acquire to synchronize with
                              //   all the previous decrements.
                              // - last but one decrement needs to release to synchronize with
                              //   the acquire load in _M_is_shared that will conclude that
                              //   the object is not shared anymore.
                	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
                							 -1) <= 0)
                		{
                		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
                		  _M_destroy(__a);
                		}
                	    }
                	}  // XXX MT
                
                	void
                	_M_destroy(const _Alloc&) throw();
                
                	_CharT*
                	_M_refcopy() throw()
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
                	  return _M_refdata();
                	}  // XXX MT
                
                	_CharT*
                	_M_clone(const _Alloc&, size_type __res = 0);
                      };
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : _Alloc
                      {
                	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	: _Alloc(__a), _M_p(__dat) { }
                
                	_CharT* _M_p; // The actual data.
                      };
                
                    public:
                      // Data Members (public):
                      // NB: This is an unsigned type, and thus represents the maximum
                      // size that the allocator can hold.
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // Data Members (private):
                      mutable _Alloc_hider	_M_dataplus;
                
                      _CharT*
                      _M_data() const _GLIBCXX_NOEXCEPT
                      { return  _M_dataplus._M_p; }
                
                      _CharT*
                      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
                      { return (_M_dataplus._M_p = __p); }
                
                      _Rep*
                      _M_rep() const _GLIBCXX_NOEXCEPT
                      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
                
                      // For the internal use we have functions similar to `begin'/`end'
                      // but they do not call _M_leak.
                      iterator
                      _M_ibegin() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      iterator
                      _M_iend() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      void
                      _M_leak()    // for use in begin() & non-const op[]
                      {
                	if (!_M_rep()->_M_is_leaked())
                	  _M_leak_hard();
                      }
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);	  
                      }
                
                      static void
                      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);	  
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, (void)++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
                
                      void
                      _M_leak_hard();
                
                      static _Rep&
                      _S_empty_rep() _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_empty_rep(); }
                
                #if __cplusplus >= 201703L
                      // A helper type for avoiding boiler-plate.
                      typedef basic_string_view<_CharT, _Traits> __sv_type;
                
                      template<typename _Tp, typename _Res>
                	using _If_sv = enable_if_t<
                	  __and_<is_convertible<const _Tp&, __sv_type>,
                		 __not_<is_convertible<const _Tp*, const basic_string*>>,
                		 __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
                	  _Res>;
                
                      // Allows an implicit conversion to __sv_type.
                      static __sv_type
                      _S_to_string_view(__sv_type __svt) noexcept
                      { return __svt; }
                
                      // Wraps a string_view by explicit conversion and thus
                      // allows to add an internal constructor that does not
                      // participate in overload resolution when a string_view
                      // is provided.
                      struct __sv_wrapper
                      {
                	explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
                	__sv_type _M_sv;
                      };
                
                      /**
                       *  @brief  Only internally used: Construct string from a string view
                       *          wrapper.
                       *  @param  __svw  string view wrapper.
                       *  @param  __a  Allocator to use.
                       */
                      explicit
                      basic_string(__sv_wrapper __svw, const _Alloc& __a)
                      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                #endif
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      _GLIBCXX_NOEXCEPT
                      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc())
                #else
                      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc())
                #endif
                      { }
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a);
                
                      // NB: per LWG issue 42, semantics different from IS:
                      /**
                       *  @brief  Construct string with copy of value of @a str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2583. no way to supply an allocator for basic_string(str, pos)
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a);
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       **/
                      basic_string(basic_string&& __str)
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      noexcept // FIXME C++11: should always be noexcept.
                #endif
                      : _M_dataplus(std::move(__str._M_dataplus))
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	__str._M_data(_S_empty_rep()._M_refdata());
                #else
                	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
                #endif
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
                
                      basic_string(const basic_string& __str, const _Alloc& __a)
                      : _M_dataplus(__str._M_rep()->_M_grab(__a, __str.get_allocator()), __a)
                      { }
                
                      basic_string(basic_string&& __str, const _Alloc& __a)
                      : _M_dataplus(__str._M_data(), __a)
                      {
                	if (__a == __str.get_allocator())
                	  {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	    __str._M_data(_S_empty_rep()._M_refdata());
                #else
                	    __str._M_data(_S_construct(size_type(), _CharT(), __a));
                #endif
                	  }
                	else
                	  _M_dataplus._M_p = _S_construct(__str.begin(), __str.end(), __a);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<class _InputIterator>
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc());
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Construct string from a substring of a string_view.
                       *  @param  __t   Source object convertible to string view.
                       *  @param  __pos The index of the first character to copy from __t.
                       *  @param  __n   The number of characters to copy from __t.
                       *  @param  __a   Allocator to use.
                       */
                      template<typename _Tp, typename = _If_sv<_Tp, void>>
                	basic_string(const _Tp& __t, size_type __pos, size_type __n,
                		     const _Alloc& __a = _Alloc())
                	: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }
                
                      /**
                       *  @brief  Construct string from a string_view.
                       *  @param  __t  Source object convertible to string view.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<typename _Tp, typename = _If_sv<_Tp, void>>
                	explicit
                	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
                	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
                #endif // C++17
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string() _GLIBCXX_NOEXCEPT
                      { _M_rep()->_M_dispose(this->get_allocator()); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str)
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s) 
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c) 
                      { 
                	this->assign(1, __c); 
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       **/
                      basic_string&
                      operator=(basic_string&& __str)
                      _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value)
                      {
                	// NB: DR 1204.
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value to string constructed from a string_view.
                       *  @param  __svt An object convertible to  string_view.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	operator=(const _Tp& __svt)
                	{ return this->assign(__svt); }
                
                      /**
                       *  @brief  Convert to a string_view.
                       *  @return A string_view.
                       */
                      operator __sv_type() const noexcept
                      { return __sv_type(data(), size()); }
                #endif // C++17
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.  Unshares the string.
                       */
                      iterator
                      begin() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.  Unshares the string.
                       */
                      iterator
                      end() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data() + this->size());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.  Unshares the string.
                       */
                      reverse_iterator
                      rbegin() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.  Unshares the string.
                       */
                      reverse_iterator
                      rend() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_max_size; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() _GLIBCXX_NOEXCEPT
                      {
                #if __cpp_exceptions
                	if (capacity() > size())
                	  {
                	    try
                	      { reserve(0); }
                	    catch(...)
                	      { }
                	  }
                #endif
                      }
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_capacity; }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg = 0);
                
                      /**
                       *  Erases the string, making it empty.
                       */
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      {
                	if (_M_rep()->_M_is_shared())
                	  {
                	    _M_rep()->_M_dispose(this->get_allocator());
                	    _M_data(_S_empty_rep()._M_refdata());
                	  }
                	else
                	  _M_rep()->_M_set_length_and_sharable(0);
                      }
                #else
                      // PR 56166: this should not throw.
                      void
                      clear()
                      { _M_mutate(0, this->size(), 0); }
                #endif
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_assert(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)  Unshares the string.
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	__glibcxx_assert(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	_M_leak();
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.  Success results in
                       *  unsharing the string.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	_M_leak();
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front()
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back()
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      { 
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt The object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	operator+=(const _Tp& __svt)
                	{ return this->append(__svt); }
                #endif // C++17
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str);
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n = npos);
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->append(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                      template<class _InputIterator>
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt The object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	append(const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->append(__sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Append a range of characters from a string_view.
                       *  @param __svt The object convertible to string_view to be appended
                       *               from.
                       *  @param __pos The position in the string_view to append from.
                       *  @param __n   The number of characters to append from the string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                	append(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return append(__sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      { 
                	const size_type __len = 1 + this->size();
                	if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	  this->reserve(__len);
                	traits_type::assign(_M_data()[this->size()], __c);
                	_M_rep()->_M_set_length_and_sharable(__len);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string&
                      assign(basic_string&& __str)
                      noexcept(allocator_traits<_Alloc>::is_always_equal::value)
                      {
                	this->swap(__str);
                	return *this;
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
                      { return this->assign(__str._M_data()
                			    + __str._M_check(__pos, "basic_string::assign"),
                			    __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->assign(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                      template<class _InputIterator>
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value from a string_view.
                       *  @param __svt The source object convertible to string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	assign(const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->assign(__sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Set value from a range of characters in a string_view.
                       *  @param __svt  The source object convertible to string_view.
                       *  @param __pos  The position in the string_view to assign from.
                       *  @param __n  The number of characters to assign.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return assign(__sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Iterator referencing location in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n = npos)
                      { return this->insert(__pos1, __str._M_data()
                			    + __str._M_check(__pos2, "basic_string::insert"),
                			    __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Iterator referencing location in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->insert(__pos, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	const size_type __pos = __p - _M_ibegin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos  Iterator referencing position in string to insert at.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	insert(size_type __pos, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->insert(__pos, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos1  Position in string to insert at.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  Position in string_view to insert from.
                       *  @param __n    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        insert(size_type __pos1, const _Tp& __svt,
                	       size_type __pos2, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, size_type(0), __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
                	      std::__sv_limit(__sv.size(), __pos2, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      { 
                	_M_mutate(_M_check(__pos, "basic_string::erase"),
                		  _M_limit(__pos, __n), size_type(0));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
                				 && __position < _M_iend());
                	const size_type __pos = __position - _M_ibegin();
                	_M_mutate(__pos, size_type(1), size_type(0));
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __first, iterator __last);
                 
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() // FIXME C++11: should be noexcept.
                      {
                	__glibcxx_assert(!empty());
                	erase(size() - 1, 1);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2);
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      template<class _InputIterator>
                        basic_string&
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				   && __i2 <= _M_iend());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(iterator __i1, iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos  The position to replace at.
                       *  @param __n    The number of characters to replace.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(size_type __pos, size_type __n, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos, __n, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos1  The position to replace at.
                       *  @param __n1    The number of characters to replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  The position in the string_view to insert from.
                       *  @param __n2    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        replace(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, __n1,
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
                	      std::__sv_limit(__sv.size(), __pos2, __n2));
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __i1    An iterator referencing the start position
                          to replace at.
                       *  @param __i2    An iterator referencing the end position
                          for the replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__i1 - begin(), __i2 - __i1, __sv);
                	}
                #endif // C++17
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
                			    _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			    _InputIterator __k2, __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		      size_type __n2);
                
                      // _S_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIter is an integral type
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          return _S_construct(__beg, __end, __a, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<class _Integer>
                        static _CharT*
                        _S_construct_aux(_Integer __beg, _Integer __end,
                			 const _Alloc& __a, __true_type)
                        { return _S_construct_aux_2(static_cast<size_type>(__beg),
                				    __end, __a); }
                
                      static _CharT*
                      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
                      { return _S_construct(__req, __c, __a); }
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  return _S_construct_aux(__beg, __end, __a, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<class _InIterator>
                        static _CharT*
                         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		      input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<class _FwdIterator>
                        static _CharT*
                        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
                		     forward_iterator_tag);
                
                      static _CharT*
                      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s)
                      _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value);
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a pointer to internal data.  It is undefined to modify
                       *  the contents through the returned pointer. To get a pointer that
                       *  allows modifying the contents use @c &str[0] instead,
                       *  (or in C++17 the non-const @c str.data() overload).
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Return non-const pointer to contents.
                       *
                       *  This is a pointer to the character sequence held by the string.
                       *  Modifying the characters in the sequence is allowed.
                      */
                      _CharT*
                      data() noexcept
                      {
                	_M_leak();
                	return _M_data();
                      }
                #endif
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_dataplus; }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	rfind(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->rfind(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character of a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character not in a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const _GLIBCXX_NOEXCEPT;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character not in a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __svt An object convertible to string_view to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	   __sv_type __sv = __svt;
                	  const size_type __size = this->size();
                	  const size_type __osize = __sv.size();
                	  const size_type __len = std::min(__size, __osize);
                
                	  int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                	  if (!__r)
                	    __r = _S_compare(__size, __osize);
                	  return __r;
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos  A position in the string to start comparing from.
                       *  @param __n  The number of characters to compare.
                       *  @param __svt  An object convertible to string_view to compare
                       *                against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos, size_type __n, const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this).substr(__pos, __n).compare(__sv);
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos1  A position in the string to start comparing from.
                       *  @param __n1  The number of characters to compare.
                       *  @param __svt   An object convertible to string_view to compare
                       *                 against.
                       *  @param __pos2  A position in the string_view to start comparing from.
                       *  @param __n2  The number of characters to compare.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this)
                	    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                
                #if __cplusplus > 201703L
                      bool
                      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                #endif // C++20
                
                # ifdef _GLIBCXX_TM_TS_INTERNAL
                      friend void
                      ::_txnal_cow_string_C1_for_exceptions(void* that, const char* s,
                					    void* exc);
                      friend const char*
                      ::_txnal_cow_string_c_str(const void *that);
                      friend void
                      ::_txnal_cow_string_D1(void *that);
                      friend void
                      ::_txnal_cow_string_D1_commit(void *that);
                # endif
                  };
                #endif  // !_GLIBCXX_USE_CXX11_ABI
                
                #if __cpp_deduction_guides >= 201606
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                  template<typename _InputIterator, typename _CharT
                	     = typename iterator_traits<_InputIterator>::value_type,
                	   typename _Allocator = allocator<_CharT>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
                      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 3075. basic_string needs deduction guides from basic_string_view
                  template<typename _CharT, typename _Traits,
                	   typename _Allocator = allocator<_CharT>,
                	   typename = _RequireAllocator<_Allocator>>
                    basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
                      -> basic_string<_CharT, _Traits, _Allocator>;
                
                  template<typename _CharT, typename _Traits,
                	   typename _Allocator = allocator<_CharT>,
                	   typename = _RequireAllocator<_Allocator>>
                    basic_string(basic_string_view<_CharT, _Traits>,
                		 typename basic_string<_CharT, _Traits, _Allocator>::size_type,
                		 typename basic_string<_CharT, _Traits, _Allocator>::size_type,
                		 const _Allocator& = _Allocator())
                      -> basic_string<_CharT, _Traits, _Allocator>;
                _GLIBCXX_END_NAMESPACE_CXX11
                #endif
                
                  // operator+
                  /**
                   *  @brief  Concatenate two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate C string and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate character and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate string and C string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate string and character.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                      __string_type __str(__lhs);
                      __str.append(__size_type(1), __rhs);
                      return __str;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    {
                      const auto __size = __lhs.size() + __rhs.size();
                      const bool __cond = (__size > __lhs.capacity()
                			   && __size <= __rhs.capacity());
                      return __cond ? std::move(__rhs.insert(0, __lhs))
                	            : std::move(__lhs.append(__rhs));
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const _CharT* __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, 1, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const _CharT* __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      _CharT __rhs)
                    { return std::move(__lhs.append(1, __rhs)); }
                #endif
                
                  // operator ==
                  /**
                   *  @brief  Test equivalence of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) == 0; }
                
                  template<typename _CharT>
                    inline
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
                    operator==(const basic_string<_CharT>& __lhs,
                	       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT
                    { return (__lhs.size() == __rhs.size()
                	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
                						    __lhs.size())); }
                
                  /**
                   *  @brief  Test equivalence of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) == 0; }
                
                  /**
                   *  @brief  Test equivalence of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
      922058 ->     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                  // operator !=
                  /**
                   *  @brief  Test difference of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return !(__lhs == __rhs); }
                
                  // operator <
                  /**
                   *  @brief  Test if string precedes string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if string precedes C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if C string precedes string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) > 0; }
                
                  // operator >
                  /**
                   *  @brief  Test if string follows string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if string follows C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if C string follows string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) < 0; }
                
                  // operator <=
                  /**
                   *  @brief  Test if string doesn't follow string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if string doesn't follow C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't follow string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) >= 0; }
                
                  // operator >=
                  /**
                   *  @brief  Test if string doesn't precede string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if string doesn't precede C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't precede string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const _CharT* __lhs,
                	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) <= 0; }
                
                  /**
                   *  @brief  Swap contents of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *
                   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline void
                    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__lhs.swap(__rhs)))
                    { __lhs.swap(__rhs); }
                
                
                  /**
                   *  @brief  Read stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until whitespace is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  If is.width() is non-zero, that is the limit on the
                   *  number of characters stored into @a __str.  Any previous
                   *  contents of @a __str are erased.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is,
                	       basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  template<>
                    basic_istream<char>&
                    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
                
                  /**
                   *  @brief  Write string to a stream.
                   *  @param __os  Output stream.
                   *  @param __str  String to write out.
                   *  @return  Reference to the output stream.
                   *
                   *  Output characters of @a __str into os following the same rules as for
                   *  writing a C string.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 586. string inserter not a formatted function
                      return __ostream_insert(__os, __str.data(), __str.size());
                    }
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @param __delim  Character marking end of line.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until @a __delim is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  @a __delim is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from is into @a __str until &apos;\n&apos; is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  end of line is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str, __is.widen('\n')); }
                
                #if __cplusplus >= 201103L
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    { return std::getline(__is, __str, __delim); }
                
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str); }
                #endif
                
                  template<>
                    basic_istream<char>&
                    getline(basic_istream<char>& __in, basic_string<char>& __str,
                	    char __delim);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
                	    wchar_t __delim);
                #endif  
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                
                #include <ext/string_conversions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                
                #if _GLIBCXX_USE_C99_STDLIB
                  // 21.4 Numeric Conversions [string.conversions].
                  inline int
                  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long
                  stol(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: strtof vs strtod.
                  inline float
                  stof(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
                #endif // _GLIBCXX_USE_C99_STDLIB
                
                #if _GLIBCXX_USE_C99_STDIO
                  // NB: (v)snprintf vs sprintf.
                
                  // DR 1261.
                  inline string
                  to_string(int __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
                					   "%d", __val); }
                
                  inline string
                  to_string(unsigned __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned),
                					   "%u", __val); }
                
                  inline string
                  to_string(long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
                					   "%ld", __val); }
                
                  inline string
                  to_string(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long),
                					   "%lu", __val); }
                
                  inline string
                  to_string(long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(long long),
                					   "%lld", __val); }
                
                  inline string
                  to_string(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
                					   4 * sizeof(unsigned long long),
                					   "%llu", __val); }
                
                  inline string
                  to_string(float __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(long double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%Lf", __val);
                  }
                #endif // _GLIBCXX_USE_C99_STDIO
                
                #if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR
                  inline int 
                  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long 
                  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: wcstof vs wcstod.
                  inline float
                  stof(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
                
                #ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                  // DR 1261.
                  inline wstring
                  to_wstring(int __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
                					    L"%d", __val); }
                
                  inline wstring
                  to_wstring(unsigned __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned),
                					    L"%u", __val); }
                
                  inline wstring
                  to_wstring(long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
                					    L"%ld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long),
                					    L"%lu", __val); }
                
                  inline wstring
                  to_wstring(long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(long long),
                					    L"%lld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long long),
                					    L"%llu", __val); }
                
                  inline wstring
                  to_wstring(float __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(long double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%Lf", __val);
                  }
                #endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                #endif // _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR
                
                _GLIBCXX_END_NAMESPACE_CXX11
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* C++11 */
                
                #if __cplusplus >= 201103L
                
                #include <bits/functional_hash.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // DR 1182.
                
                #ifndef _GLIBCXX_COMPATIBILITY_CXX0X
                  /// std::hash specialization for string.
                  template<>
                    struct hash<string>
                    : public __hash_base<size_t, string>
                    {
                      size_t
                      operator()(const string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<string>> : std::false_type
                    { };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// std::hash specialization for wstring.
                  template<>
                    struct hash<wstring>
                    : public __hash_base<size_t, wstring>
                    {
                      size_t
                      operator()(const wstring& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(wchar_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<wstring>> : std::false_type
                    { };
                #endif
                #endif /* _GLIBCXX_COMPATIBILITY_CXX0X */
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  /// std::hash specialization for u8string.
                  template<>
                    struct hash<u8string>
                    : public __hash_base<size_t, u8string>
                    {
                      size_t
                      operator()(const u8string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char8_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u8string>> : std::false_type
                    { };
                #endif
                
                  /// std::hash specialization for u16string.
                  template<>
                    struct hash<u16string>
                    : public __hash_base<size_t, u16string>
                    {
                      size_t
                      operator()(const u16string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char16_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u16string>> : std::false_type
                    { };
                
                  /// std::hash specialization for u32string.
                  template<>
                    struct hash<u32string>
                    : public __hash_base<size_t, u32string>
                    {
                      size_t
                      operator()(const u32string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char32_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u32string>> : std::false_type
                    { };
                
                #if __cplusplus >= 201402L
                
                #define __cpp_lib_string_udls 201304
                
                  inline namespace literals
                  {
                  inline namespace string_literals
                  {
                #pragma GCC diagnostic push
                #pragma GCC diagnostic ignored "-Wliteral-suffix"
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char>
                    operator""s(const char* __str, size_t __len)
                    { return basic_string<char>{__str, __len}; }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<wchar_t>
                    operator""s(const wchar_t* __str, size_t __len)
                    { return basic_string<wchar_t>{__str, __len}; }
                #endif
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char8_t>
                    operator""s(const char8_t* __str, size_t __len)
                    { return basic_string<char8_t>{__str, __len}; }
                #endif
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char16_t>
                    operator""s(const char16_t* __str, size_t __len)
                    { return basic_string<char16_t>{__str, __len}; }
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char32_t>
                    operator""s(const char32_t* __str, size_t __len)
                    { return basic_string<char32_t>{__str, __len}; }
                
                #pragma GCC diagnostic pop
                  } // inline namespace string_literals
                  } // inline namespace literals
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // basic_string into a variant, but only if moving the string cannot throw.
                    template<typename _Tp, typename _Traits, typename _Alloc>
                      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
                      : __and_<
                	is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,
                	is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>
                	>::type
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                #endif // C++14
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _BASIC_STRING_H */


Top 10 Lines:

     Line      Count

     6178     922058

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   922058   Total number of line executions
922058.00   Average executions per line


*** File /usr/include/c++/9/bits/stl_function.h:
                // Functor implementations -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_function.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{functional}
                 */
                
                #ifndef _STL_FUNCTION_H
                #define _STL_FUNCTION_H 1
                
                #if __cplusplus > 201103L
                #include <bits/move.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // 20.3.1 base classes
                  /** @defgroup functors Function Objects
                   * @ingroup utilities
                   *
                   *  Function objects, or @e functors, are objects with an @c operator()
                   *  defined and accessible.  They can be passed as arguments to algorithm
                   *  templates and used in place of a function pointer.  Not only is the
                   *  resulting expressiveness of the library increased, but the generated
                   *  code can be more efficient than what you might write by hand.  When we
                   *  refer to @a functors, then, generally we include function pointers in
                   *  the description as well.
                   *
                   *  Often, functors are only created as temporaries passed to algorithm
                   *  calls, rather than being created as named variables.
                   *
                   *  Two examples taken from the standard itself follow.  To perform a
                   *  by-element addition of two vectors @c a and @c b containing @c double,
                   *  and put the result in @c a, use
                   *  \code
                   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
                   *  \endcode
                   *  To negate every element in @c a, use
                   *  \code
                   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
                   *  \endcode
                   *  The addition and negation functions will be inlined directly.
                   *
                   *  The standard functors are derived from structs named @c unary_function
                   *  and @c binary_function.  These two classes contain nothing but typedefs,
                   *  to aid in generic (template) programming.  If you write your own
                   *  functors, you might consider doing the same.
                   *
                   *  @{
                   */
                  /**
                   *  This is one of the @link functors functor base classes@endlink.
                   */
                  template<typename _Arg, typename _Result>
                    struct unary_function
                    {
                      /// @c argument_type is the type of the argument
                      typedef _Arg 	argument_type;   
                
                      /// @c result_type is the return type
                      typedef _Result 	result_type;  
                    };
                
                  /**
                   *  This is one of the @link functors functor base classes@endlink.
                   */
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    struct binary_function
                    {
                      /// @c first_argument_type is the type of the first argument
                      typedef _Arg1 	first_argument_type; 
                
                      /// @c second_argument_type is the type of the second argument
                      typedef _Arg2 	second_argument_type;
                
                      /// @c result_type is the return type
                      typedef _Result 	result_type;
                    };
                  /** @}  */
                
                  // 20.3.2 arithmetic
                  /** @defgroup arithmetic_functors Arithmetic Classes
                   * @ingroup functors
                   *
                   *  Because basic math often needs to be done during an algorithm,
                   *  the library provides functors for those operations.  See the
                   *  documentation for @link functors the base classes@endlink
                   *  for examples of their use.
                   *
                   *  @{
                   */
                
                #if __cplusplus > 201103L
                  struct __is_transparent;  // undefined
                
                  template<typename _Tp = void>
                    struct plus;
                
                  template<typename _Tp = void>
                    struct minus;
                
                  template<typename _Tp = void>
                    struct multiplies;
                
                  template<typename _Tp = void>
                    struct divides;
                
                  template<typename _Tp = void>
                    struct modulus;
                
                  template<typename _Tp = void>
                    struct negate;
                #endif
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct plus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x + __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct minus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x - __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x * __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct divides : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x / __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct modulus : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x % __y; }
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<typename _Tp>
                    struct negate : public unary_function<_Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x) const
                      { return -__x; }
                    };
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_transparent_operators 201510
                
                  template<>
                    struct plus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct minus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct multiplies<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct divides<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct modulus<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link arithmetic_functors math functors@endlink.
                  template<>
                    struct negate<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(-std::forward<_Tp>(__t)))
                	-> decltype(-std::forward<_Tp>(__t))
                	{ return -std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                  // 20.3.3 comparisons
                  /** @defgroup comparison_functors Comparison Classes
                   * @ingroup functors
                   *
                   *  The library provides six wrapper functors for all the basic comparisons
                   *  in C++, like @c <.
                   *
                   *  @{
                   */
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct equal_to;
                
                  template<typename _Tp = void>
                    struct not_equal_to;
                
                  template<typename _Tp = void>
                    struct greater;
                
                  template<typename _Tp = void>
                    struct less;
                
                  template<typename _Tp = void>
                    struct greater_equal;
                
                  template<typename _Tp = void>
                    struct less_equal;
                #endif
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
      153172 ->       operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x == __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x != __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct greater : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x > __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct less : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x < __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct greater_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x >= __y; }
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<typename _Tp>
                    struct less_equal : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x <= __y; }
                    };
                
                  // Partial specialization of std::greater for pointers.
                  template<typename _Tp>
                    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x > __y))
                #endif
                	  return __x > __y;
                #endif
                	return (__UINTPTR_TYPE__)__x > (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                  // Partial specialization of std::less for pointers.
                  template<typename _Tp>
                    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x < __y))
                #endif
                	  return __x < __y;
                #endif
                	return (__UINTPTR_TYPE__)__x < (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                  // Partial specialization of std::greater_equal for pointers.
                  template<typename _Tp>
                    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x >= __y))
                #endif
                	  return __x >= __y;
                #endif
                	return (__UINTPTR_TYPE__)__x >= (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                  // Partial specialization of std::less_equal for pointers.
                  template<typename _Tp>
                    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
                    {
                      _GLIBCXX14_CONSTEXPR bool
                      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
                      {
                #if __cplusplus >= 201402L
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                	if (__builtin_is_constant_evaluated())
                #else
                	if (__builtin_constant_p(__x <= __y))
                #endif
                	  return __x <= __y;
                #endif
                	return (__UINTPTR_TYPE__)__x <= (__UINTPTR_TYPE__)__y;
                      }
                    };
                
                #if __cplusplus >= 201402L
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct equal_to<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct not_equal_to<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct greater<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return greater<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator> member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator>(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator> for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator>(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct less<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return less<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator< member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator<(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator< for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator<(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct greater_equal<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return greater_equal<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator>= member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator>=(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator>= for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator>=(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                
                  /// One of the @link comparison_functors comparison functors@endlink.
                  template<>
                    struct less_equal<void>
                    {
                      template <typename _Tp, typename _Up>
                	constexpr auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
                	{
                	  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                			__ptr_cmp<_Tp, _Up>{});
                	}
                
                      template<typename _Tp, typename _Up>
                	constexpr bool
                	operator()(_Tp* __t, _Up* __u) const noexcept
                	{ return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }
                
                      typedef __is_transparent is_transparent;
                
                    private:
                      template <typename _Tp, typename _Up>
                	static constexpr decltype(auto)
                	_S_cmp(_Tp&& __t, _Up&& __u, false_type)
                	{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }
                
                      template <typename _Tp, typename _Up>
                	static constexpr bool
                	_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
                	{
                	  return less_equal<const volatile void*>{}(
                	      static_cast<const volatile void*>(std::forward<_Tp>(__t)),
                	      static_cast<const volatile void*>(std::forward<_Up>(__u)));
                	}
                
                      // True if there is no viable operator<= member function.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded2 : true_type { };
                
                      // False if we can call T.operator<=(U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded2<_Tp, _Up, __void_t<
                	  decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
                	: false_type { };
                
                      // True if there is no overloaded operator<= for these operands.
                      template<typename _Tp, typename _Up, typename = void>
                	struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };
                
                      // False if we can call operator<=(T,U)
                      template<typename _Tp, typename _Up>
                	struct __not_overloaded<_Tp, _Up, __void_t<
                	  decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
                	: false_type { };
                
                      template<typename _Tp, typename _Up>
                	using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                	      is_convertible<_Tp, const volatile void*>,
                	      is_convertible<_Up, const volatile void*>>;
                    };
                #endif // C++14
                  /** @}  */
                
                  // 20.3.4 logical operations
                  /** @defgroup logical_functors Boolean Operations Classes
                   * @ingroup functors
                   *
                   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,
                   *  and @c !.
                   *
                   *  @{
                   */
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct logical_and;
                
                  template<typename _Tp = void>
                    struct logical_or;
                
                  template<typename _Tp = void>
                    struct logical_not;
                #endif
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_and : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x && __y; }
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_or : public binary_function<_Tp, _Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x || __y; }
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<typename _Tp>
                    struct logical_not : public unary_function<_Tp, bool>
                    {
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const _Tp& __x) const
                      { return !__x; }
                    };
                
                #if __cplusplus > 201103L
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_and<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_or<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  /// One of the @link logical_functors Boolean operations functors@endlink.
                  template<>
                    struct logical_not<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(!std::forward<_Tp>(__t)))
                	-> decltype(!std::forward<_Tp>(__t))
                	{ return !std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                  /** @}  */
                
                #if __cplusplus > 201103L
                  template<typename _Tp = void>
                    struct bit_and;
                
                  template<typename _Tp = void>
                    struct bit_or;
                
                  template<typename _Tp = void>
                    struct bit_xor;
                
                  template<typename _Tp = void>
                    struct bit_not;
                #endif
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 660. Missing Bitwise Operations.
                  template<typename _Tp>
                    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x & __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x | __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
                    {
                      _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x, const _Tp& __y) const
                      { return __x ^ __y; }
                    };
                
                  template<typename _Tp>
                    struct bit_not : public unary_function<_Tp, _Tp>
                    {
                    _GLIBCXX14_CONSTEXPR
                      _Tp
                      operator()(const _Tp& __x) const
                      { return ~__x; }
                    };
                
                #if __cplusplus > 201103L
                  template <>
                    struct bit_and<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_or<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_xor<void>
                    {
                      template <typename _Tp, typename _Up>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t, _Up&& __u) const
                	noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
                	-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
                	{ return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }
                
                      typedef __is_transparent is_transparent;
                    };
                
                  template <>
                    struct bit_not<void>
                    {
                      template <typename _Tp>
                	_GLIBCXX14_CONSTEXPR
                	auto
                	operator()(_Tp&& __t) const
                	noexcept(noexcept(~std::forward<_Tp>(__t)))
                	-> decltype(~std::forward<_Tp>(__t))
                	{ return ~std::forward<_Tp>(__t); }
                
                      typedef __is_transparent is_transparent;
                    };
                #endif
                
                  // 20.3.5 negators
                  /** @defgroup negators Negators
                   * @ingroup functors
                   *
                   *  The functions @c not1 and @c not2 each take a predicate functor
                   *  and return an instance of @c unary_negate or
                   *  @c binary_negate, respectively.  These classes are functors whose
                   *  @c operator() performs the stored predicate function and then returns
                   *  the negation of the result.
                   *
                   *  For example, given a vector of integers and a trivial predicate,
                   *  \code
                   *  struct IntGreaterThanThree
                   *    : public std::unary_function<int, bool>
                   *  {
                   *      bool operator() (int x) { return x > 3; }
                   *  };
                   *
                   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
                   *  \endcode
                   *  The call to @c find_if will locate the first index (i) of @c v for which
                   *  <code>!(v[i] > 3)</code> is true.
                   *
                   *  The not1/unary_negate combination works on predicates taking a single
                   *  argument.  The not2/binary_negate combination works on predicates which
                   *  take two arguments.
                   *
                   *  @{
                   */
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    class unary_negate
                    : public unary_function<typename _Predicate::argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                
                    public:
                      _GLIBCXX14_CONSTEXPR
                      explicit
                      unary_negate(const _Predicate& __x) : _M_pred(__x) { }
                
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const typename _Predicate::argument_type& __x) const
                      { return !_M_pred(__x); }
                    };
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    _GLIBCXX14_CONSTEXPR
                    inline unary_negate<_Predicate>
                    not1(const _Predicate& __pred)
                    { return unary_negate<_Predicate>(__pred); }
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    class binary_negate
                    : public binary_function<typename _Predicate::first_argument_type,
                			     typename _Predicate::second_argument_type, bool>
                    {
                    protected:
                      _Predicate _M_pred;
                
                    public:
                      _GLIBCXX14_CONSTEXPR
                      explicit
                      binary_negate(const _Predicate& __x) : _M_pred(__x) { }
                
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(const typename _Predicate::first_argument_type& __x,
                		 const typename _Predicate::second_argument_type& __y) const
                      { return !_M_pred(__x, __y); }
                    };
                
                  /// One of the @link negators negation functors@endlink.
                  template<typename _Predicate>
                    _GLIBCXX14_CONSTEXPR
                    inline binary_negate<_Predicate>
                    not2(const _Predicate& __pred)
                    { return binary_negate<_Predicate>(__pred); }
                  /** @}  */
                
                  // 20.3.7 adaptors pointers functions
                  /** @defgroup pointer_adaptors Adaptors for pointers to functions
                   * @ingroup functors
                   *
                   *  The advantage of function objects over pointers to functions is that
                   *  the objects in the standard library declare nested typedefs describing
                   *  their argument and result types with uniform names (e.g., @c result_type
                   *  from the base classes @c unary_function and @c binary_function).
                   *  Sometimes those typedefs are required, not just optional.
                   *
                   *  Adaptors are provided to turn pointers to unary (single-argument) and
                   *  binary (double-argument) functions into function objects.  The
                   *  long-winded functor @c pointer_to_unary_function is constructed with a
                   *  function pointer @c f, and its @c operator() called with argument @c x
                   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
                   *  thing, but with a double-argument @c f and @c operator().
                   *
                   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
                   *  an instance of the appropriate functor.
                   *
                   *  @{
                   */
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg, typename _Result>
                    class pointer_to_unary_function : public unary_function<_Arg, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg);
                
                    public:
                      pointer_to_unary_function() { }
                
                      explicit
                      pointer_to_unary_function(_Result (*__x)(_Arg))
                      : _M_ptr(__x) { }
                
                      _Result
                      operator()(_Arg __x) const
                      { return _M_ptr(__x); }
                    };
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg, typename _Result>
                    inline pointer_to_unary_function<_Arg, _Result>
                    ptr_fun(_Result (*__x)(_Arg))
                    { return pointer_to_unary_function<_Arg, _Result>(__x); }
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    class pointer_to_binary_function
                    : public binary_function<_Arg1, _Arg2, _Result>
                    {
                    protected:
                      _Result (*_M_ptr)(_Arg1, _Arg2);
                
                    public:
                      pointer_to_binary_function() { }
                
                      explicit
                      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
                      : _M_ptr(__x) { }
                
                      _Result
                      operator()(_Arg1 __x, _Arg2 __y) const
                      { return _M_ptr(__x, __y); }
                    };
                
                  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
                  template<typename _Arg1, typename _Arg2, typename _Result>
                    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
                    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
                    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
                  /** @}  */
                
                  template<typename _Tp>
                    struct _Identity
                    : public unary_function<_Tp, _Tp>
                    {
                      _Tp&
                      operator()(_Tp& __x) const
                      { return __x; }
                
                      const _Tp&
                      operator()(const _Tp& __x) const
                      { return __x; }
                    };
                
                  // Partial specialization, avoids confusing errors in e.g. std::set<const T>.
                  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };
                
                  template<typename _Pair>
                    struct _Select1st
                    : public unary_function<_Pair, typename _Pair::first_type>
                    {
                      typename _Pair::first_type&
                      operator()(_Pair& __x) const
                      { return __x.first; }
                
                      const typename _Pair::first_type&
                      operator()(const _Pair& __x) const
                      { return __x.first; }
                
                #if __cplusplus >= 201103L
                      template<typename _Pair2>
                        typename _Pair2::first_type&
                        operator()(_Pair2& __x) const
                        { return __x.first; }
                
                      template<typename _Pair2>
                        const typename _Pair2::first_type&
                        operator()(const _Pair2& __x) const
                        { return __x.first; }
                #endif
                    };
                
                  template<typename _Pair>
                    struct _Select2nd
                    : public unary_function<_Pair, typename _Pair::second_type>
                    {
                      typename _Pair::second_type&
                      operator()(_Pair& __x) const
                      { return __x.second; }
                
                      const typename _Pair::second_type&
                      operator()(const _Pair& __x) const
                      { return __x.second; }
                    };
                
                  // 20.3.8 adaptors pointers members
                  /** @defgroup memory_adaptors Adaptors for pointers to members
                   * @ingroup functors
                   *
                   *  There are a total of 8 = 2^3 function objects in this family.
                   *   (1) Member functions taking no arguments vs member functions taking
                   *        one argument.
                   *   (2) Call through pointer vs call through reference.
                   *   (3) Const vs non-const member function.
                   *
                   *  All of this complexity is in the function objects themselves.  You can
                   *   ignore it by using the helper function mem_fun and mem_fun_ref,
                   *   which create whichever type of adaptor is appropriate.
                   *
                   *  @{
                   */
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class mem_fun_t : public unary_function<_Tp*, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp* __p) const
                      { return (__p->*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)();
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp* __p) const
                      { return (__p->*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      mem_fun_ref_t(_Ret (_Tp::*__pf)())
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp& __r) const
                      { return (__r.*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)();
                  };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp>
                    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp& __r) const
                      { return (__r.*_M_f)(); }
                
                    private:
                      _Ret (_Tp::*_M_f)() const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp* __p, _Arg __x) const
                      { return (__p->*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(_Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg);
                    };
                
                  /// One of the @link memory_adaptors adaptors for member
                  /// pointers@endlink.
                  template<typename _Ret, typename _Tp, typename _Arg>
                    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
                    {
                    public:
                      explicit
                      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
                      : _M_f(__pf) { }
                
                      _Ret
                      operator()(const _Tp& __r, _Arg __x) const
                      { return (__r.*_M_f)(__x); }
                
                    private:
                      _Ret (_Tp::*_M_f)(_Arg) const;
                    };
                
                  // Mem_fun adaptor helper functions.  There are only two:
                  // mem_fun and mem_fun_ref.
                  template<typename _Ret, typename _Tp>
                    inline mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)())
                    { return mem_fun_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline const_mem_fun_t<_Ret, _Tp>
                    mem_fun(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)())
                    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp>
                    inline const_mem_fun_ref_t<_Ret, _Tp>
                    mem_fun_ref(_Ret (_Tp::*__f)() const)
                    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
                    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
                    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  template<typename _Ret, typename _Tp, typename _Arg>
                    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
                    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
                    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
                
                  /** @}  */
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if (__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED
                # include <backward/binders.h>
                #endif
                
                #endif /* _STL_FUNCTION_H */


Top 10 Lines:

     Line      Count

      355     153172

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   153172   Total number of line executions
153172.00   Average executions per line


*** File /usr/include/c++/9/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994-2019 Free Software Foundation, Inc.
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <exception>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception 
                  {
                  public:
                    bad_alloc() throw() { }
                
                #if __cplusplus >= 201103L
                    bad_alloc(const bad_alloc&) = default;
                    bad_alloc& operator=(const bad_alloc&) = default;
                #endif
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                #if __cplusplus >= 201103L
                  class bad_array_new_length : public bad_alloc
                  {
                  public:
                    bad_array_new_length() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_array_new_length() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                #endif
                
                #if __cpp_aligned_new
                  enum class align_val_t: size_t {};
                #endif
                
                  struct nothrow_t
                  {
                #if __cplusplus >= 201103L
                    explicit nothrow_t() = default;
                #endif
                  };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                
                #if __cplusplus >= 201103L
                  /// Return the current new handler.
                  new_handler get_new_handler() noexcept;
                #endif
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #endif
                _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __malloc__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __malloc__));
                void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_aligned_new
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
                void operator delete(void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete(void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __malloc__));
                void operator delete[](void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #endif // __cpp_sized_deallocation
                #endif // __cpp_aligned_new
                
                // Default placement versions of operator new.
                _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
     2062857 -> { return __p; }
                _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
                { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                //@}
                } // extern "C++"
                
                #if __cplusplus >= 201703L
                #ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER
                namespace std
                {
                #define __cpp_lib_launder 201606
                  /// Pointer optimization barrier [ptr.launder]
                  template<typename _Tp>
                    [[nodiscard]] constexpr _Tp*
                    launder(_Tp* __p) noexcept
                    { return __builtin_launder(__p); }
                
                  // The program is ill-formed if T is a function type or
                  // (possibly cv-qualified) void.
                
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args...) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args......) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                
                  void launder(void*) = delete;
                  void launder(const void*) = delete;
                  void launder(volatile void*) = delete;
                  void launder(const volatile void*) = delete;
                }
                #endif // _GLIBCXX_HAVE_BUILTIN_LAUNDER
                #endif // C++17
                
                #if __cplusplus > 201703L
                namespace std
                {
                  struct destroying_delete_t
                  {
                    explicit destroying_delete_t() = default;
                  };
                  inline constexpr destroying_delete_t destroying_delete{};
                }
                // Only define the feature test macro if the compiler supports the feature:
                #if __cpp_impl_destroying_delete
                # define __cpp_lib_destroying_delete 201806L
                #endif
                #endif // C++20
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      174    2062857

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

  2062857   Total number of line executions
1031428.50   Average executions per line


*** File /usr/include/c++/9/bits/stl_numeric.h:
                // Numeric functions implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_numeric.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{numeric}
                 */
                
                #ifndef _STL_NUMERIC_H
                #define _STL_NUMERIC_H 1
                
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For _GLIBCXX_MOVE
                
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /** @defgroup numeric_ops Generalized Numeric operations
                   *  @ingroup algorithms
                   */
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Create a range of sequentially increasing values.
                   *
                   *  For each element in the range @p [first,last) assigns @p value and
                   *  increments @p value as if by @p ++value.
                   *
                   *  @param  __first  Start of range.
                   *  @param  __last  End of range.
                   *  @param  __value  Starting value.
                   *  @return  Nothing.
                   *  @ingroup numeric_ops
                   */
                  template<typename _ForwardIterator, typename _Tp>
                    void
           1 ->     iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	{
                	  *__first = __value;
                	  ++__value;
                	}
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                #if __cplusplus > 201703L
                // _GLIBCXX_RESOLVE_LIB_DEFECTS
                // DR 2055. std::move in std::accumulate and other algorithms
                # define _GLIBCXX_MOVE_IF_20(_E) std::move(_E)
                #else
                # define _GLIBCXX_MOVE_IF_20(_E) _E
                #endif
                
                  /// @addtogroup numeric_ops
                  /// @{
                
                  /**
                   *  @brief  Accumulate values in a range.
                   *
                   *  Accumulates the values in the range [first,last) using operator+().  The
                   *  initial value is @a init.  The values are processed in order.
                   *
                   *  @param  __first  Start of range.
                   *  @param  __last  End of range.
                   *  @param  __init  Starting value to add other values to.
                   *  @return  The final sum.
                   */
                  template<typename _InputIterator, typename _Tp>
                    inline _Tp
                    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	__init = _GLIBCXX_MOVE_IF_20(__init) + *__first;
                      return __init;
                    }
                
                  /**
                   *  @brief  Accumulate values in a range with operation.
                   *
                   *  Accumulates the values in the range `[first,last)` using the function
                   *  object `__binary_op`.  The initial value is `__init`.  The values are
                   *  processed in order.
                   *
                   *  @param  __first  Start of range.
                   *  @param  __last  End of range.
                   *  @param  __init  Starting value to add other values to.
                   *  @param  __binary_op  Function object to accumulate with.
                   *  @return  The final sum.
                   */
                  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
                    inline _Tp
                    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
                	       _BinaryOperation __binary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	__init = __binary_op(_GLIBCXX_MOVE_IF_20(__init), *__first);
                      return __init;
                    }
                
                  /**
                   *  @brief  Compute inner product of two ranges.
                   *
                   *  Starting with an initial value of @p __init, multiplies successive
                   *  elements from the two ranges and adds each product into the accumulated
                   *  value using operator+().  The values in the ranges are processed in
                   *  order.
                   *
                   *  @param  __first1  Start of range 1.
                   *  @param  __last1  End of range 1.
                   *  @param  __first2  Start of range 2.
                   *  @param  __init  Starting value to add other values to.
                   *  @return  The final inner product.
                   */
                  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
                    inline _Tp
                    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
                		  _InputIterator2 __first2, _Tp __init)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	__init = _GLIBCXX_MOVE_IF_20(__init) + (*__first1 * *__first2);
                      return __init;
                    }
                
                  /**
                   *  @brief  Compute inner product of two ranges.
                   *
                   *  Starting with an initial value of @p __init, applies @p __binary_op2 to
                   *  successive elements from the two ranges and accumulates each result into
                   *  the accumulated value using @p __binary_op1.  The values in the ranges are
                   *  processed in order.
                   *
                   *  @param  __first1  Start of range 1.
                   *  @param  __last1  End of range 1.
                   *  @param  __first2  Start of range 2.
                   *  @param  __init  Starting value to add other values to.
                   *  @param  __binary_op1  Function object to accumulate with.
                   *  @param  __binary_op2  Function object to apply to pairs of input values.
                   *  @return  The final inner product.
                   */
                  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
                	   typename _BinaryOperation1, typename _BinaryOperation2>
                    inline _Tp
                    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
                		  _InputIterator2 __first2, _Tp __init,
                		  _BinaryOperation1 __binary_op1,
                		  _BinaryOperation2 __binary_op2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	__init = __binary_op1(_GLIBCXX_MOVE_IF_20(__init),
                			      __binary_op2(*__first1, *__first2));
                      return __init;
                    }
                
                  /**
                   *  @brief  Return list of partial sums
                   *
                   *  Accumulates the values in the range [first,last) using the @c + operator.
                   *  As each successive input value is added into the total, that partial sum
                   *  is written to @p __result.  Therefore, the first value in @p __result is
                   *  the first value of the input, the second value in @p __result is the sum
                   *  of the first and second input values, and so on.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sum.
                   *  @return  Iterator pointing just beyond the values written to __result.
                   */
                  template<typename _InputIterator, typename _OutputIterator>
                    _OutputIterator
                    partial_sum(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  __value = _GLIBCXX_MOVE_IF_20(__value) + *__first;
                	  *++__result = __value;
                	}
                      return ++__result;
                    }
                
                  /**
                   *  @brief  Return list of partial sums
                   *
                   *  Accumulates the values in the range [first,last) using @p __binary_op.
                   *  As each successive input value is added into the total, that partial sum
                   *  is written to @p __result.  Therefore, the first value in @p __result is
                   *  the first value of the input, the second value in @p __result is the sum
                   *  of the first and second input values, and so on.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sum.
                   *  @param  __binary_op  Function object.
                   *  @return  Iterator pointing just beyond the values written to __result.
                   */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryOperation>
                    _OutputIterator
                    partial_sum(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result, _BinaryOperation __binary_op)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  __value = __binary_op(_GLIBCXX_MOVE_IF_20(__value), *__first);
                	  *++__result = __value;
                	}
                      return ++__result;
                    }
                
                  /**
                   *  @brief  Return differences between adjacent values.
                   *
                   *  Computes the difference between adjacent values in the range
                   *  [first,last) using operator-() and writes the result to @p __result.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sums.
                   *  @return  Iterator pointing just beyond the values written to result.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 539. partial_sum and adjacent_difference should mention requirements
                   */
                  template<typename _InputIterator, typename _OutputIterator>
                    _OutputIterator
                    adjacent_difference(_InputIterator __first,
                			_InputIterator __last, _OutputIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  _ValueType __tmp = *__first;
                	  *++__result = __tmp - _GLIBCXX_MOVE_IF_20(__value);
                	  __value = _GLIBCXX_MOVE(__tmp);
                	}
                      return ++__result;
                    }
                
                  /**
                   *  @brief  Return differences between adjacent values.
                   *
                   *  Computes the difference between adjacent values in the range
                   *  [__first,__last) using the function object @p __binary_op and writes the
                   *  result to @p __result.
                   *
                   *  @param  __first  Start of input range.
                   *  @param  __last  End of input range.
                   *  @param  __result  Output sum.
                   *  @param  __binary_op Function object.
                   *  @return  Iterator pointing just beyond the values written to result.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 539. partial_sum and adjacent_difference should mention requirements
                   */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryOperation>
                    _OutputIterator
                    adjacent_difference(_InputIterator __first, _InputIterator __last,
                			_OutputIterator __result, _BinaryOperation __binary_op)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                				                         _ValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      _ValueType __value = *__first;
                      *__result = __value;
                      while (++__first != __last)
                	{
                	  _ValueType __tmp = *__first;
                	  *++__result = __binary_op(__tmp, _GLIBCXX_MOVE_IF_20(__value));
                	  __value = _GLIBCXX_MOVE(__tmp);
                	}
                      return ++__result;
                    }
                
                  /// @} group numeric_ops
                
                #undef _GLIBCXX_MOVE_IF_20
                
                _GLIBCXX_END_NAMESPACE_ALGO
                } // namespace std
                
                #endif /* _STL_NUMERIC_H */


Top 10 Lines:

     Line      Count

       87          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/c++/9/bits/functional_hash.h:
                // functional_hash.h header -*- C++ -*-
                
                // Copyright (C) 2007-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/functional_hash.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{functional}
                 */
                
                #ifndef _FUNCTIONAL_HASH_H
                #define _FUNCTIONAL_HASH_H 1
                
                #pragma GCC system_header
                
                #include <bits/hash_bytes.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /** @defgroup hashes Hashes
                   *  @ingroup functors
                   *
                   *   Hashing functors taking a variable type and returning a @c std::size_t.
                   *
                   *  @{
                   */
                
                  template<typename _Result, typename _Arg>
                    struct __hash_base
                    {
                      typedef _Result     result_type _GLIBCXX17_DEPRECATED;
                      typedef _Arg      argument_type _GLIBCXX17_DEPRECATED;
                    };
                
                  /// Primary class template hash.
                  template<typename _Tp>
                    struct hash;
                
                  template<typename _Tp, typename = void>
                    struct __poison_hash
                    {
                      static constexpr bool __enable_hash_call = false;
                    private:
                      // Private rather than deleted to be non-trivially-copyable.
                      __poison_hash(__poison_hash&&);
                      ~__poison_hash();
                    };
                
                  template<typename _Tp>
                    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
                    {
                      static constexpr bool __enable_hash_call = true;
                    };
                
                  // Helper struct for SFINAE-poisoning non-enum types.
                  template<typename _Tp, bool = is_enum<_Tp>::value>
                    struct __hash_enum
                    {
                    private:
                      // Private rather than deleted to be non-trivially-copyable.
                      __hash_enum(__hash_enum&&);
                      ~__hash_enum();
                    };
                
                  // Helper struct for hash with enum types.
                  template<typename _Tp>
                    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
                    {
                      size_t
                      operator()(_Tp __val) const noexcept
                      {
                       using __type = typename underlying_type<_Tp>::type;
                       return hash<__type>{}(static_cast<__type>(__val));
                      }
                    };
                
                  /// Primary class template hash, usable for enum types only.
                  // Use with non-enum types still SFINAES.
                  template<typename _Tp>
                    struct hash : __hash_enum<_Tp>
                    { };
                
                  /// Partial specializations for pointer types.
                  template<typename _Tp>
                    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
                    {
                      size_t
                      operator()(_Tp* __p) const noexcept
                      { return reinterpret_cast<size_t>(__p); }
                    };
                
                  // Explicit specializations for integer types.
                #define _Cxx_hashtable_define_trivial_hash(_Tp) 	\
                  template<>						\
                    struct hash<_Tp> : public __hash_base<size_t, _Tp>  \
                    {                                                   \
                      size_t                                            \
                      operator()(_Tp __val) const noexcept              \
                      { return static_cast<size_t>(__val); }            \
                    };
                
                  /// Explicit specialization for bool.
                  _Cxx_hashtable_define_trivial_hash(bool)
                
                  /// Explicit specialization for char.
                  _Cxx_hashtable_define_trivial_hash(char)
                
                  /// Explicit specialization for signed char.
                  _Cxx_hashtable_define_trivial_hash(signed char)
                
                  /// Explicit specialization for unsigned char.
                  _Cxx_hashtable_define_trivial_hash(unsigned char)
                
                  /// Explicit specialization for wchar_t.
                  _Cxx_hashtable_define_trivial_hash(wchar_t)
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  /// Explicit specialization for char8_t.
                  _Cxx_hashtable_define_trivial_hash(char8_t)
                #endif
                
                  /// Explicit specialization for char16_t.
                  _Cxx_hashtable_define_trivial_hash(char16_t)
                
                  /// Explicit specialization for char32_t.
                  _Cxx_hashtable_define_trivial_hash(char32_t)
                
                  /// Explicit specialization for short.
                  _Cxx_hashtable_define_trivial_hash(short)
                
                  /// Explicit specialization for int.
     2155229 ->   _Cxx_hashtable_define_trivial_hash(int)
                
                  /// Explicit specialization for long.
                  _Cxx_hashtable_define_trivial_hash(long)
                
                  /// Explicit specialization for long long.
                  _Cxx_hashtable_define_trivial_hash(long long)
                
                  /// Explicit specialization for unsigned short.
                  _Cxx_hashtable_define_trivial_hash(unsigned short)
                
                  /// Explicit specialization for unsigned int.
                  _Cxx_hashtable_define_trivial_hash(unsigned int)
                
                  /// Explicit specialization for unsigned long.
                  _Cxx_hashtable_define_trivial_hash(unsigned long)
                
                  /// Explicit specialization for unsigned long long.
                  _Cxx_hashtable_define_trivial_hash(unsigned long long)
                
                #ifdef __GLIBCXX_TYPE_INT_N_0
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_0)
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_0 unsigned)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_1
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_1)
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_1 unsigned)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_2
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_2)
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_2 unsigned)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_3
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_3)
                  _Cxx_hashtable_define_trivial_hash(__GLIBCXX_TYPE_INT_N_3 unsigned)
                #endif
                
                #undef _Cxx_hashtable_define_trivial_hash
                
                  struct _Hash_impl
                  {
                    static size_t
                    hash(const void* __ptr, size_t __clength,
                	 size_t __seed = static_cast<size_t>(0xc70f6907UL))
                    { return _Hash_bytes(__ptr, __clength, __seed); }
                
                    template<typename _Tp>
                      static size_t
                      hash(const _Tp& __val)
                      { return hash(&__val, sizeof(__val)); }
                
                    template<typename _Tp>
                      static size_t
                      __hash_combine(const _Tp& __val, size_t __hash)
                      { return hash(&__val, sizeof(__val), __hash); }
                  };
                
                  // A hash function similar to FNV-1a (see PR59406 for how it differs).
                  struct _Fnv_hash_impl
                  {
                    static size_t
                    hash(const void* __ptr, size_t __clength,
                	 size_t __seed = static_cast<size_t>(2166136261UL))
                    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }
                
                    template<typename _Tp>
                      static size_t
                      hash(const _Tp& __val)
                      { return hash(&__val, sizeof(__val)); }
                
                    template<typename _Tp>
                      static size_t
                      __hash_combine(const _Tp& __val, size_t __hash)
                      { return hash(&__val, sizeof(__val), __hash); }
                  };
                
                  /// Specialization for float.
                  template<>
                    struct hash<float> : public __hash_base<size_t, float>
                    {
                      size_t
                      operator()(float __val) const noexcept
                      {
                	// 0 and -0 both hash to zero.
                	return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
                      }
                    };
                
                  /// Specialization for double.
                  template<>
                    struct hash<double> : public __hash_base<size_t, double>
                    {
                      size_t
                      operator()(double __val) const noexcept
                      {
                	// 0 and -0 both hash to zero.
                	return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
                      }
                    };
                
                  /// Specialization for long double.
                  template<>
                    struct hash<long double>
                    : public __hash_base<size_t, long double>
                    {
                      _GLIBCXX_PURE size_t
                      operator()(long double __val) const noexcept;
                    };
                
                #if __cplusplus >= 201703L
                  template<>
                    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>
                    {
                      size_t
                      operator()(nullptr_t) const noexcept
                      { return 0; }
                    };
                #endif
                
                  /// @} group hashes
                
                  // Hint about performance of hash functor. If not fast the hash-based
                  // containers will cache the hash code.
                  // Default behavior is to consider that hashers are fast unless specified
                  // otherwise.
                  template<typename _Hash>
                    struct __is_fast_hash : public std::true_type
                    { };
                
                  template<>
                    struct __is_fast_hash<hash<long double>> : public std::false_type
                    { };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif // _FUNCTIONAL_HASH_H


Top 10 Lines:

     Line      Count

      153    2155229

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

  2155229   Total number of line executions
2155229.00   Average executions per line


*** File /usr/include/c++/9/bits/unordered_set.h:
                // unordered_set implementation -*- C++ -*-
                
                // Copyright (C) 2010-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/unordered_set.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{unordered_set}
                 */
                
                #ifndef _UNORDERED_SET_H
                #define _UNORDERED_SET_H
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// Base types for unordered_set.
                  template<bool _Cache>
                    using __uset_traits = __detail::_Hashtable_traits<_Cache, true, true>;
                
                  template<typename _Value,
                	   typename _Hash = hash<_Value>,
                	   typename _Pred = std::equal_to<_Value>,
                  	   typename _Alloc = std::allocator<_Value>,
                	   typename _Tr = __uset_traits<__cache_default<_Value, _Hash>::value>>
                    using __uset_hashtable = _Hashtable<_Value, _Value, _Alloc,
                					__detail::_Identity, _Pred, _Hash,
                					__detail::_Mod_range_hashing,
                					__detail::_Default_ranged_hash,
                					__detail::_Prime_rehash_policy, _Tr>;
                
                  /// Base types for unordered_multiset.
                  template<bool _Cache>
                    using __umset_traits = __detail::_Hashtable_traits<_Cache, true, false>;
                
                  template<typename _Value,
                	   typename _Hash = hash<_Value>,
                	   typename _Pred = std::equal_to<_Value>,
                	   typename _Alloc = std::allocator<_Value>,
                	   typename _Tr = __umset_traits<__cache_default<_Value, _Hash>::value>>
                    using __umset_hashtable = _Hashtable<_Value, _Value, _Alloc,
                					 __detail::_Identity,
                					 _Pred, _Hash,
                					 __detail::_Mod_range_hashing,
                					 __detail::_Default_ranged_hash,
                					 __detail::_Prime_rehash_policy, _Tr>;
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    class unordered_multiset;
                
                  /**
                   *  @brief A standard container composed of unique keys (containing
                   *  at most one of each key value) in which the elements' keys are
                   *  the elements themselves.
                   *
                   *  @ingroup unordered_associative_containers
                   *
                   *  @tparam  _Value  Type of key objects.
                   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.
                
                   *  @tparam _Pred Predicate function object type, defaults to
                   *                equal_to<_Value>.
                   *
                   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
                   *  <a href="tables.html#xx">unordered associative container</a>
                   *
                   *  Base is _Hashtable, dispatched at compile time via template
                   *  alias __uset_hashtable.
                   */
                  template<typename _Value,
                	   typename _Hash = hash<_Value>,
                	   typename _Pred = equal_to<_Value>,
                	   typename _Alloc = allocator<_Value>>
         900 ->     class unordered_set
                    {
                      typedef __uset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Hashtable;
                      _Hashtable _M_h;
                
                    public:
                      // typedefs:
                      ///@{
                      /// Public typedefs.
                      typedef typename _Hashtable::key_type	key_type;
                      typedef typename _Hashtable::value_type	value_type;
                      typedef typename _Hashtable::hasher	hasher;
                      typedef typename _Hashtable::key_equal	key_equal;
                      typedef typename _Hashtable::allocator_type allocator_type;
                      ///@}
                
                      ///@{
                      ///  Iterator-related typedefs.
                      typedef typename _Hashtable::pointer		pointer;
                      typedef typename _Hashtable::const_pointer	const_pointer;
                      typedef typename _Hashtable::reference		reference;
                      typedef typename _Hashtable::const_reference	const_reference;
                      typedef typename _Hashtable::iterator		iterator;
                      typedef typename _Hashtable::const_iterator	const_iterator;
                      typedef typename _Hashtable::local_iterator	local_iterator;
                      typedef typename _Hashtable::const_local_iterator	const_local_iterator;
                      typedef typename _Hashtable::size_type		size_type;
                      typedef typename _Hashtable::difference_type	difference_type;
                      ///@}
                
                #if __cplusplus > 201402L
                      using node_type = typename _Hashtable::node_type;
                      using insert_return_type = typename _Hashtable::insert_return_type;
                #endif
                
                      // construct/destroy/copy
                
                      /// Default constructor.
         900 ->       unordered_set() = default;
                
                      /**
                       *  @brief  Default constructor creates no elements.
                       *  @param __n  Minimal initial number of buckets.
                       *  @param __hf  A hash functor.
                       *  @param __eql  A key equality functor.
                       *  @param __a  An allocator object.
                       */
                      explicit
                      unordered_set(size_type __n,
                		    const hasher& __hf = hasher(),
                		    const key_equal& __eql = key_equal(),
                		    const allocator_type& __a = allocator_type())
                      : _M_h(__n, __hf, __eql, __a)
                      { }
                
                      /**
                       *  @brief  Builds an %unordered_set from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param __n  Minimal initial number of buckets.
                       *  @param __hf  A hash functor.
                       *  @param __eql  A key equality functor.
                       *  @param __a  An allocator object.
                       *
                       *  Create an %unordered_set consisting of copies of the elements from
                       *  [__first,__last).  This is linear in N (where N is
                       *  distance(__first,__last)).
                       */
                      template<typename _InputIterator>
                	unordered_set(_InputIterator __first, _InputIterator __last,
                		      size_type __n = 0,
                		      const hasher& __hf = hasher(),
                		      const key_equal& __eql = key_equal(),
                		      const allocator_type& __a = allocator_type())
                	: _M_h(__first, __last, __n, __hf, __eql, __a)
                	{ }
                
                      /// Copy constructor.
                      unordered_set(const unordered_set&) = default;
                
                      /// Move constructor.
                      unordered_set(unordered_set&&) = default;
                
                      /**
                       *  @brief Creates an %unordered_set with no elements.
                       *  @param __a An allocator object.
                       */
                      explicit
                      unordered_set(const allocator_type& __a)
                      : _M_h(__a)
                      { }
                
                      /*
                       *  @brief Copy constructor with allocator argument.
                       * @param  __uset  Input %unordered_set to copy.
                       * @param  __a  An allocator object.
                       */
                      unordered_set(const unordered_set& __uset,
                		    const allocator_type& __a)
                      : _M_h(__uset._M_h, __a)
                      { }
                
                      /*
                       *  @brief  Move constructor with allocator argument.
                       *  @param  __uset Input %unordered_set to move.
                       *  @param  __a    An allocator object.
                       */
                      unordered_set(unordered_set&& __uset,
                		    const allocator_type& __a)
                	noexcept( noexcept(_Hashtable(std::move(__uset._M_h), __a)) )
                      : _M_h(std::move(__uset._M_h), __a)
                      { }
                
                      /**
                       *  @brief  Builds an %unordered_set from an initializer_list.
                       *  @param  __l  An initializer_list.
                       *  @param __n  Minimal initial number of buckets.
                       *  @param __hf  A hash functor.
                       *  @param __eql  A key equality functor.
                       *  @param  __a  An allocator object.
                       *
                       *  Create an %unordered_set consisting of copies of the elements in the
                       *  list. This is linear in N (where N is @a __l.size()).
                       */
                      unordered_set(initializer_list<value_type> __l,
                		    size_type __n = 0,
                		    const hasher& __hf = hasher(),
                		    const key_equal& __eql = key_equal(),
                		    const allocator_type& __a = allocator_type())
                      : _M_h(__l, __n, __hf, __eql, __a)
                      { }
                
                      unordered_set(size_type __n, const allocator_type& __a)
                      : unordered_set(__n, hasher(), key_equal(), __a)
                      { }
                
                      unordered_set(size_type __n, const hasher& __hf,
                		    const allocator_type& __a)
                      : unordered_set(__n, __hf, key_equal(), __a)
                      { }
                
                      template<typename _InputIterator>
                	unordered_set(_InputIterator __first, _InputIterator __last,
                		      size_type __n,
                		      const allocator_type& __a)
                	: unordered_set(__first, __last, __n, hasher(), key_equal(), __a)
                	{ }
                
                      template<typename _InputIterator>
                	unordered_set(_InputIterator __first, _InputIterator __last,
                		      size_type __n, const hasher& __hf,
                		      const allocator_type& __a)
                	: unordered_set(__first, __last, __n, __hf, key_equal(), __a)
                	{ }
                
                      unordered_set(initializer_list<value_type> __l,
                		    size_type __n,
                		    const allocator_type& __a)
                      : unordered_set(__l, __n, hasher(), key_equal(), __a)
                      { }
                
                      unordered_set(initializer_list<value_type> __l,
                		    size_type __n, const hasher& __hf,
                		    const allocator_type& __a)
                      : unordered_set(__l, __n, __hf, key_equal(), __a)
                      { }
                
                      /// Copy assignment operator.
                      unordered_set&
                      operator=(const unordered_set&) = default;
                
                      /// Move assignment operator.
                      unordered_set&
                      operator=(unordered_set&&) = default;
                
                      /**
                       *  @brief  %Unordered_set list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills an %unordered_set with copies of the elements in
                       *  the initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %unordered_set and
                       *  that the resulting %unordered_set's size is the same as the number
                       *  of elements assigned.
                       */
                      unordered_set&
                      operator=(initializer_list<value_type> __l)
                      {
                	_M_h = __l;
                	return *this;
                      }
                
                      ///  Returns the allocator object used by the %unordered_set.
                      allocator_type
                      get_allocator() const noexcept
                      { return _M_h.get_allocator(); }
                
                      // size and capacity:
                
                      ///  Returns true if the %unordered_set is empty.
                      _GLIBCXX_NODISCARD bool
                      empty() const noexcept
                      { return _M_h.empty(); }
                
                      ///  Returns the size of the %unordered_set.
                      size_type
                      size() const noexcept
                      { return _M_h.size(); }
                
                      ///  Returns the maximum size of the %unordered_set.
                      size_type
                      max_size() const noexcept
                      { return _M_h.max_size(); }
                
                      // iterators.
                
                      ///@{
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %unordered_set.
                       */
                      iterator
         900 ->       begin() noexcept
                      { return _M_h.begin(); }
                
                      const_iterator
                      begin() const noexcept
                      { return _M_h.begin(); }
                      ///@}
                
                      ///@{
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  element in the %unordered_set.
                       */
                      iterator
         900 ->       end() noexcept
                      { return _M_h.end(); }
                
                      const_iterator
                      end() const noexcept
                      { return _M_h.end(); }
                      ///@}
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %unordered_set.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return _M_h.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  element in the %unordered_set.
                       */
                      const_iterator
                      cend() const noexcept
                      { return _M_h.end(); }
                
                      // modifiers.
                
                      /**
                       *  @brief Attempts to build and insert an element into the
                       *  %unordered_set.
                       *  @param __args  Arguments used to generate an element.
                       *  @return  A pair, of which the first element is an iterator that points
                       *           to the possibly inserted element, and the second is a bool
                       *           that is true if the element was actually inserted.
                       *
                       *  This function attempts to build and insert an element into the
                       *  %unordered_set. An %unordered_set relies on unique keys and thus an
                       *  element is only inserted if it is not already present in the
                       *  %unordered_set.
                       *
                       *  Insertion requires amortized constant time.
                       */
                      template<typename... _Args>
                	std::pair<iterator, bool>
                	emplace(_Args&&... __args)
                	{ return _M_h.emplace(std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief Attempts to insert an element into the %unordered_set.
                       *  @param  __pos  An iterator that serves as a hint as to where the
                       *                element should be inserted.
                       *  @param  __args  Arguments used to generate the element to be
                       *                 inserted.
                       *  @return An iterator that points to the element with key equivalent to
                       *          the one generated from @a __args (may or may not be the
                       *          element itself).
                       *
                       *  This function is not concerned about whether the insertion took place,
                       *  and thus does not return a boolean like the single-argument emplace()
                       *  does.  Note that the first parameter is only a hint and can
                       *  potentially improve the performance of the insertion process.  A bad
                       *  hint would cause no gains in efficiency.
                       *
                       *  For more on @a hinting, see:
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *
                       *  Insertion requires amortized constant time.
                       */
                      template<typename... _Args>
                	iterator
                	emplace_hint(const_iterator __pos, _Args&&... __args)
                	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
                
                      ///@{
                      /**
                       *  @brief Attempts to insert an element into the %unordered_set.
                       *  @param  __x  Element to be inserted.
                       *  @return  A pair, of which the first element is an iterator that points
                       *           to the possibly inserted element, and the second is a bool
                       *           that is true if the element was actually inserted.
                       *
                       *  This function attempts to insert an element into the %unordered_set.
                       *  An %unordered_set relies on unique keys and thus an element is only
                       *  inserted if it is not already present in the %unordered_set.
                       *
                       *  Insertion requires amortized constant time.
                       */
                      std::pair<iterator, bool>
      614700 ->       insert(const value_type& __x)
                      { return _M_h.insert(__x); }
                
                      std::pair<iterator, bool>
                      insert(value_type&& __x)
                      { return _M_h.insert(std::move(__x)); }
                      ///@}
                
                      ///@{
                      /**
                       *  @brief Attempts to insert an element into the %unordered_set.
                       *  @param  __hint  An iterator that serves as a hint as to where the
                       *                 element should be inserted.
                       *  @param  __x  Element to be inserted.
                       *  @return An iterator that points to the element with key of
                       *           @a __x (may or may not be the element passed in).
                       *
                       *  This function is not concerned about whether the insertion took place,
                       *  and thus does not return a boolean like the single-argument insert()
                       *  does.  Note that the first parameter is only a hint and can
                       *  potentially improve the performance of the insertion process.  A bad
                       *  hint would cause no gains in efficiency.
                       *
                       *  For more on @a hinting, see:
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *
                       *  Insertion requires amortized constant.
                       */
                      iterator
                      insert(const_iterator __hint, const value_type& __x)
                      { return _M_h.insert(__hint, __x); }
                
                      iterator
                      insert(const_iterator __hint, value_type&& __x)
                      { return _M_h.insert(__hint, std::move(__x)); }
                      ///@}
                
                      /**
                       *  @brief A template function that attempts to insert a range of
                       *  elements.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                   inserted.
                       *  @param  __last  Iterator pointing to the end of the range.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      template<typename _InputIterator>
                	void
                	insert(_InputIterator __first, _InputIterator __last)
                	{ _M_h.insert(__first, __last); }
                
                      /**
                       *  @brief Attempts to insert a list of elements into the %unordered_set.
                       *  @param  __l  A std::initializer_list<value_type> of elements
                       *               to be inserted.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      void
                      insert(initializer_list<value_type> __l)
                      { _M_h.insert(__l); }
                
                #if __cplusplus > 201402L
                      /// Extract a node.
                      node_type
                      extract(const_iterator __pos)
                      {
                	__glibcxx_assert(__pos != end());
                	return _M_h.extract(__pos);
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const key_type& __key)
                      { return _M_h.extract(__key); }
                
                      /// Re-insert an extracted node.
                      insert_return_type
                      insert(node_type&& __nh)
                      { return _M_h._M_reinsert_node(std::move(__nh)); }
                
                      /// Re-insert an extracted node.
                      iterator
                      insert(const_iterator, node_type&& __nh)
                      { return _M_h._M_reinsert_node(std::move(__nh)).position; }
                #endif // C++17
                
                      ///@{
                      /**
                       *  @brief Erases an element from an %unordered_set.
                       *  @param  __position  An iterator pointing to the element to be erased.
                       *  @return An iterator pointing to the element immediately following
                       *          @a __position prior to the element being erased. If no such
                       *          element exists, end() is returned.
                       *
                       *  This function erases an element, pointed to by the given iterator,
                       *  from an %unordered_set.  Note that this function only erases the
                       *  element, and that if the element is itself a pointer, the pointed-to
                       *  memory is not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
                      iterator
                      erase(const_iterator __position)
                      { return _M_h.erase(__position); }
                
                      // LWG 2059.
                      iterator
                      erase(iterator __position)
                      { return _M_h.erase(__position); }
                      ///@}
                
                      /**
                       *  @brief Erases elements according to the provided key.
                       *  @param  __x  Key of element to be erased.
                       *  @return  The number of elements erased.
                       *
                       *  This function erases all the elements located by the given key from
                       *  an %unordered_set. For an %unordered_set the result of this function
                       *  can only be 0 (not present) or 1 (present).
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      size_type
                      erase(const key_type& __x)
                      { return _M_h.erase(__x); }
                
                      /**
                       *  @brief Erases a [__first,__last) range of elements from an
                       *  %unordered_set.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                  erased.
                       *  @param __last  Iterator pointing to the end of the range to
                       *                be erased.
                       *  @return The iterator @a __last.
                       *
                       *  This function erases a sequence of elements from an %unordered_set.
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      { return _M_h.erase(__first, __last); }
                
                      /**
                       *  Erases all elements in an %unordered_set. Note that this function only
                       *  erases the elements, and that if the elements themselves are pointers,
                       *  the pointed-to memory is not touched in any way. Managing the pointer
                       *  is the user's responsibility.
                       */
                      void
                      clear() noexcept
                      { _M_h.clear(); }
                
                      /**
                       *  @brief  Swaps data with another %unordered_set.
                       *  @param  __x  An %unordered_set of the same element and allocator
                       *  types.
                       *
                       *  This exchanges the elements between two sets in constant time.
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(s1,s2) will feed to this function.
                       */
                      void
                      swap(unordered_set& __x)
                      noexcept( noexcept(_M_h.swap(__x._M_h)) )
                      { _M_h.swap(__x._M_h); }
                
                #if __cplusplus > 201402L
                      template<typename, typename, typename>
                	friend class std::_Hash_merge_helper;
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_set<_Value, _H2, _P2, _Alloc>& __source)
                	{
                	  using _Merge_helper = _Hash_merge_helper<unordered_set, _H2, _P2>;
                	  _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
                	}
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_set<_Value, _H2, _P2, _Alloc>&& __source)
                	{ merge(__source); }
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_multiset<_Value, _H2, _P2, _Alloc>& __source)
                	{
                	  using _Merge_helper = _Hash_merge_helper<unordered_set, _H2, _P2>;
                	  _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
                	}
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_multiset<_Value, _H2, _P2, _Alloc>&& __source)
                	{ merge(__source); }
                #endif // C++17
                
                      // observers.
                
                      ///  Returns the hash functor object with which the %unordered_set was
                      ///  constructed.
                      hasher
                      hash_function() const
                      { return _M_h.hash_function(); }
                
                      ///  Returns the key comparison object with which the %unordered_set was
                      ///  constructed.
                      key_equal
                      key_eq() const
                      { return _M_h.key_eq(); }
                
                      // lookup.
                
                      ///@{
                      /**
                       *  @brief Tries to locate an element in an %unordered_set.
                       *  @param  __x  Element to be located.
                       *  @return  Iterator pointing to sought-after element, or end() if not
                       *           found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns an iterator
                       *  pointing to the sought after element.  If unsuccessful it returns the
                       *  past-the-end ( @c end() ) iterator.
                       */
                      iterator
                      find(const key_type& __x)
                      { return _M_h.find(__x); }
                
                      const_iterator
                      find(const key_type& __x) const
                      { return _M_h.find(__x); }
                      ///@}
                
                      /**
                       *  @brief  Finds the number of elements.
                       *  @param  __x  Element to located.
                       *  @return  Number of elements with specified key.
                       *
                       *  This function only makes sense for unordered_multisets; for
                       *  unordered_set the result will either be 0 (not present) or 1
                       *  (present).
                       */
                      size_type
                      count(const key_type& __x) const
                      { return _M_h.count(__x); }
                
                #if __cplusplus > 201703L
                      /**
                       *  @brief  Finds whether an element with the given key exists.
                       *  @param  __x  Key of elements to be located.
                       *  @return  True if there is any element with the specified key.
                       */
                      bool
                      contains(const key_type& __x) const
                      { return _M_h.find(__x) != _M_h.end(); }
                #endif
                
                      ///@{
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  __x  Key to be located.
                       *  @return  Pair of iterators that possibly points to the subsequence
                       *           matching given key.
                       *
                       *  This function probably only makes sense for multisets.
                       */
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __x)
                      { return _M_h.equal_range(__x); }
                
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __x) const
                      { return _M_h.equal_range(__x); }
                      ///@}
                
                      // bucket interface.
                
                      /// Returns the number of buckets of the %unordered_set.
                      size_type
                      bucket_count() const noexcept
                      { return _M_h.bucket_count(); }
                
                      /// Returns the maximum number of buckets of the %unordered_set.
                      size_type
                      max_bucket_count() const noexcept
                      { return _M_h.max_bucket_count(); }
                
                      /*
                       * @brief  Returns the number of elements in a given bucket.
                       * @param  __n  A bucket index.
                       * @return  The number of elements in the bucket.
                       */
                      size_type
                      bucket_size(size_type __n) const
                      { return _M_h.bucket_size(__n); }
                
                      /*
                       * @brief  Returns the bucket index of a given element.
                       * @param  __key  A key instance.
                       * @return  The key bucket index.
                       */
                      size_type
                      bucket(const key_type& __key) const
                      { return _M_h.bucket(__key); }
                
                      ///@{
                      /**
                       *  @brief  Returns a read-only (constant) iterator pointing to the first
                       *         bucket element.
                       *  @param  __n The bucket index.
                       *  @return  A read-only local iterator.
                       */
                      local_iterator
                      begin(size_type __n)
                      { return _M_h.begin(__n); }
                
                      const_local_iterator
                      begin(size_type __n) const
                      { return _M_h.begin(__n); }
                
                      const_local_iterator
                      cbegin(size_type __n) const
                      { return _M_h.cbegin(__n); }
                      ///@}
                
                      ///@{
                      /**
                       *  @brief  Returns a read-only (constant) iterator pointing to one past
                       *         the last bucket elements.
                       *  @param  __n The bucket index.
                       *  @return  A read-only local iterator.
                       */
                      local_iterator
                      end(size_type __n)
                      { return _M_h.end(__n); }
                
                      const_local_iterator
                      end(size_type __n) const
                      { return _M_h.end(__n); }
                
                      const_local_iterator
                      cend(size_type __n) const
                      { return _M_h.cend(__n); }
                      ///@}
                
                      // hash policy.
                
                      /// Returns the average number of elements per bucket.
                      float
                      load_factor() const noexcept
                      { return _M_h.load_factor(); }
                
                      /// Returns a positive number that the %unordered_set tries to keep the
                      /// load factor less than or equal to.
                      float
                      max_load_factor() const noexcept
                      { return _M_h.max_load_factor(); }
                
                      /**
                       *  @brief  Change the %unordered_set maximum load factor.
                       *  @param  __z The new maximum load factor.
                       */
                      void
                      max_load_factor(float __z)
                      { _M_h.max_load_factor(__z); }
                
                      /**
                       *  @brief  May rehash the %unordered_set.
                       *  @param  __n The new number of buckets.
                       *
                       *  Rehash will occur only if the new number of buckets respect the
                       *  %unordered_set maximum load factor.
                       */
                      void
                      rehash(size_type __n)
                      { _M_h.rehash(__n); }
                
                      /**
                       *  @brief  Prepare the %unordered_set for a specified number of
                       *          elements.
                       *  @param  __n Number of elements required.
                       *
                       *  Same as rehash(ceil(n / max_load_factor())).
                       */
                      void
                      reserve(size_type __n)
                      { _M_h.reserve(__n); }
                
                      template<typename _Value1, typename _Hash1, typename _Pred1,
                	       typename _Alloc1>
                        friend bool
                        operator==(const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&,
                		   const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>&);
                    };
                
                #if __cpp_deduction_guides >= 201606
                
                  template<typename _InputIterator,
                	   typename _Hash =
                	     hash<typename iterator_traits<_InputIterator>::value_type>,
                	   typename _Pred =
                	     equal_to<typename iterator_traits<_InputIterator>::value_type>,
                	   typename _Allocator =
                	     allocator<typename iterator_traits<_InputIterator>::value_type>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireNotAllocator<_Pred>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_set(_InputIterator, _InputIterator,
                		  unordered_set<int>::size_type = {},
                		  _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
                    -> unordered_set<typename iterator_traits<_InputIterator>::value_type,
                		     _Hash, _Pred, _Allocator>;
                
                  template<typename _Tp, typename _Hash = hash<_Tp>,
                	   typename _Pred = equal_to<_Tp>,
                	   typename _Allocator = allocator<_Tp>,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireNotAllocator<_Pred>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_set(initializer_list<_Tp>,
                		  unordered_set<int>::size_type = {},
                		  _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
                    -> unordered_set<_Tp, _Hash, _Pred, _Allocator>;
                
                  template<typename _InputIterator, typename _Allocator,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_set(_InputIterator, _InputIterator,
                		  unordered_set<int>::size_type, _Allocator)
                    -> unordered_set<typename iterator_traits<_InputIterator>::value_type,
                		     hash<
                		       typename iterator_traits<_InputIterator>::value_type>,
                		     equal_to<
                		       typename iterator_traits<_InputIterator>::value_type>,
                		     _Allocator>;
                
                  template<typename _InputIterator, typename _Hash, typename _Allocator,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_set(_InputIterator, _InputIterator,
                		  unordered_set<int>::size_type,
                		  _Hash, _Allocator)
                    -> unordered_set<typename iterator_traits<_InputIterator>::value_type,
                		     _Hash,
                		     equal_to<
                		       typename iterator_traits<_InputIterator>::value_type>,
                		     _Allocator>;
                
                  template<typename _Tp, typename _Allocator,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_set(initializer_list<_Tp>,
                		  unordered_set<int>::size_type, _Allocator)
                    -> unordered_set<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;
                
                  template<typename _Tp, typename _Hash, typename _Allocator,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_set(initializer_list<_Tp>,
                		  unordered_set<int>::size_type, _Hash, _Allocator)
                    -> unordered_set<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
                
                #endif
                
                  /**
                   *  @brief A standard container composed of equivalent keys
                   *  (possibly containing multiple of each key value) in which the
                   *  elements' keys are the elements themselves.
                   *
                   *  @ingroup unordered_associative_containers
                   *
                   *  @tparam  _Value  Type of key objects.
                   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.
                   *  @tparam  _Pred  Predicate function object type, defaults
                   *                  to equal_to<_Value>.
                   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
                   *  <a href="tables.html#xx">unordered associative container</a>
                   *
                   *  Base is _Hashtable, dispatched at compile time via template
                   *  alias __umset_hashtable.
                   */
                  template<typename _Value,
                	   typename _Hash = hash<_Value>,
                	   typename _Pred = equal_to<_Value>,
                	   typename _Alloc = allocator<_Value>>
                    class unordered_multiset
                    {
                      typedef __umset_hashtable<_Value, _Hash, _Pred, _Alloc>  _Hashtable;
                      _Hashtable _M_h;
                
                    public:
                      // typedefs:
                      ///@{
                      /// Public typedefs.
                      typedef typename _Hashtable::key_type	key_type;
                      typedef typename _Hashtable::value_type	value_type;
                      typedef typename _Hashtable::hasher	hasher;
                      typedef typename _Hashtable::key_equal	key_equal;
                      typedef typename _Hashtable::allocator_type allocator_type;
                      ///@}
                
                      ///@{
                      ///  Iterator-related typedefs.
                      typedef typename _Hashtable::pointer		pointer;
                      typedef typename _Hashtable::const_pointer	const_pointer;
                      typedef typename _Hashtable::reference		reference;
                      typedef typename _Hashtable::const_reference	const_reference;
                      typedef typename _Hashtable::iterator		iterator;
                      typedef typename _Hashtable::const_iterator	const_iterator;
                      typedef typename _Hashtable::local_iterator	local_iterator;
                      typedef typename _Hashtable::const_local_iterator	const_local_iterator;
                      typedef typename _Hashtable::size_type		size_type;
                      typedef typename _Hashtable::difference_type	difference_type;
                      ///@}
                
                #if __cplusplus > 201402L
                      using node_type = typename _Hashtable::node_type;
                #endif
                
                      // construct/destroy/copy
                
                      /// Default constructor.
                      unordered_multiset() = default;
                
                      /**
                       *  @brief  Default constructor creates no elements.
                       *  @param __n  Minimal initial number of buckets.
                       *  @param __hf  A hash functor.
                       *  @param __eql  A key equality functor.
                       *  @param __a  An allocator object.
                       */
                      explicit
                      unordered_multiset(size_type __n,
                			 const hasher& __hf = hasher(),
                			 const key_equal& __eql = key_equal(),
                			 const allocator_type& __a = allocator_type())
                      : _M_h(__n, __hf, __eql, __a)
                      { }
                
                      /**
                       *  @brief  Builds an %unordered_multiset from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @param __n       Minimal initial number of buckets.
                       *  @param __hf      A hash functor.
                       *  @param __eql     A key equality functor.
                       *  @param __a       An allocator object.
                       *
                       *  Create an %unordered_multiset consisting of copies of the elements
                       *  from [__first,__last).  This is linear in N (where N is
                       *  distance(__first,__last)).
                       */
                      template<typename _InputIterator>
                	unordered_multiset(_InputIterator __first, _InputIterator __last,
                			   size_type __n = 0,
                			   const hasher& __hf = hasher(),
                			   const key_equal& __eql = key_equal(),
                			   const allocator_type& __a = allocator_type())
                	: _M_h(__first, __last, __n, __hf, __eql, __a)
                	{ }
                
                      /// Copy constructor.
                      unordered_multiset(const unordered_multiset&) = default;
                
                      /// Move constructor.
                      unordered_multiset(unordered_multiset&&) = default;
                
                      /**
                       *  @brief  Builds an %unordered_multiset from an initializer_list.
                       *  @param  __l  An initializer_list.
                       *  @param __n  Minimal initial number of buckets.
                       *  @param __hf  A hash functor.
                       *  @param __eql  A key equality functor.
                       *  @param  __a  An allocator object.
                       *
                       *  Create an %unordered_multiset consisting of copies of the elements in
                       *  the list. This is linear in N (where N is @a __l.size()).
                       */
                      unordered_multiset(initializer_list<value_type> __l,
                			 size_type __n = 0,
                			 const hasher& __hf = hasher(),
                			 const key_equal& __eql = key_equal(),
                			 const allocator_type& __a = allocator_type())
                      : _M_h(__l, __n, __hf, __eql, __a)
                      { }
                
                      /// Copy assignment operator.
                      unordered_multiset&
                      operator=(const unordered_multiset&) = default;
                
                      /// Move assignment operator.
                      unordered_multiset&
                      operator=(unordered_multiset&&) = default;
                
                      /**
                       *  @brief Creates an %unordered_multiset with no elements.
                       *  @param __a An allocator object.
                       */
                      explicit
                      unordered_multiset(const allocator_type& __a)
                      : _M_h(__a)
                      { }
                
                      /*
                       *  @brief Copy constructor with allocator argument.
                       * @param  __uset  Input %unordered_multiset to copy.
                       * @param  __a  An allocator object.
                       */
                      unordered_multiset(const unordered_multiset& __umset,
                			 const allocator_type& __a)
                      : _M_h(__umset._M_h, __a)
                      { }
                
                      /*
                       *  @brief  Move constructor with allocator argument.
                       *  @param  __umset  Input %unordered_multiset to move.
                       *  @param  __a  An allocator object.
                       */
                      unordered_multiset(unordered_multiset&& __umset,
                			 const allocator_type& __a)
                	noexcept( noexcept(_Hashtable(std::move(__umset._M_h), __a)) )
                      : _M_h(std::move(__umset._M_h), __a)
                      { }
                
                      unordered_multiset(size_type __n, const allocator_type& __a)
                      : unordered_multiset(__n, hasher(), key_equal(), __a)
                      { }
                
                      unordered_multiset(size_type __n, const hasher& __hf,
                			 const allocator_type& __a)
                      : unordered_multiset(__n, __hf, key_equal(), __a)
                      { }
                
                      template<typename _InputIterator>
                	unordered_multiset(_InputIterator __first, _InputIterator __last,
                			   size_type __n,
                			   const allocator_type& __a)
                	: unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a)
                	{ }
                
                      template<typename _InputIterator>
                	unordered_multiset(_InputIterator __first, _InputIterator __last,
                			   size_type __n, const hasher& __hf,
                			   const allocator_type& __a)
                	: unordered_multiset(__first, __last, __n, __hf, key_equal(), __a)
                	{ }
                
                      unordered_multiset(initializer_list<value_type> __l,
                			 size_type __n,
                			 const allocator_type& __a)
                      : unordered_multiset(__l, __n, hasher(), key_equal(), __a)
                      { }
                
                      unordered_multiset(initializer_list<value_type> __l,
                			 size_type __n, const hasher& __hf,
                			 const allocator_type& __a)
                      : unordered_multiset(__l, __n, __hf, key_equal(), __a)
                      { }
                
                      /**
                       *  @brief  %Unordered_multiset list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills an %unordered_multiset with copies of the elements
                       *  in the initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %unordered_multiset
                       *  and that the resulting %unordered_multiset's size is the same as the
                       *  number of elements assigned.
                       */
                      unordered_multiset&
                      operator=(initializer_list<value_type> __l)
                      {
                	_M_h = __l;
                	return *this;
                      }
                
                      ///  Returns the allocator object used by the %unordered_multiset.
                      allocator_type
                      get_allocator() const noexcept
                      { return _M_h.get_allocator(); }
                
                      // size and capacity:
                
                      ///  Returns true if the %unordered_multiset is empty.
                      _GLIBCXX_NODISCARD bool
                      empty() const noexcept
                      { return _M_h.empty(); }
                
                      ///  Returns the size of the %unordered_multiset.
                      size_type
                      size() const noexcept
                      { return _M_h.size(); }
                
                      ///  Returns the maximum size of the %unordered_multiset.
                      size_type
                      max_size() const noexcept
                      { return _M_h.max_size(); }
                
                      // iterators.
                
                      ///@{
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %unordered_multiset.
                       */
                      iterator
                      begin() noexcept
                      { return _M_h.begin(); }
                
                      const_iterator
                      begin() const noexcept
                      { return _M_h.begin(); }
                      ///@}
                
                      ///@{
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  element in the %unordered_multiset.
                       */
                      iterator
                      end() noexcept
                      { return _M_h.end(); }
                
                      const_iterator
                      end() const noexcept
                      { return _M_h.end(); }
                      ///@}
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  element in the %unordered_multiset.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return _M_h.begin(); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the last
                       *  element in the %unordered_multiset.
                       */
                      const_iterator
                      cend() const noexcept
                      { return _M_h.end(); }
                
                      // modifiers.
                
                      /**
                       *  @brief Builds and insert an element into the %unordered_multiset.
                       *  @param __args  Arguments used to generate an element.
                       *  @return  An iterator that points to the inserted element.
                       *
                       *  Insertion requires amortized constant time.
                       */
                      template<typename... _Args>
                	iterator
                	emplace(_Args&&... __args)
                	{ return _M_h.emplace(std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief Inserts an element into the %unordered_multiset.
                       *  @param  __pos  An iterator that serves as a hint as to where the
                       *                element should be inserted.
                       *  @param  __args  Arguments used to generate the element to be
                       *                 inserted.
                       *  @return An iterator that points to the inserted element.
                       *
                       *  Note that the first parameter is only a hint and can potentially
                       *  improve the performance of the insertion process.  A bad hint would
                       *  cause no gains in efficiency.
                       *
                       *  For more on @a hinting, see:
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *
                       *  Insertion requires amortized constant time.
                       */
                      template<typename... _Args>
                	iterator
                	emplace_hint(const_iterator __pos, _Args&&... __args)
                	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
                
                      ///@{
                      /**
                       *  @brief Inserts an element into the %unordered_multiset.
                       *  @param  __x  Element to be inserted.
                       *  @return  An iterator that points to the inserted element.
                       *
                       *  Insertion requires amortized constant time.
                       */
                      iterator
                      insert(const value_type& __x)
                      { return _M_h.insert(__x); }
                
                      iterator
                      insert(value_type&& __x)
                      { return _M_h.insert(std::move(__x)); }
                      ///@}
                
                      ///@{
                      /**
                       *  @brief Inserts an element into the %unordered_multiset.
                       *  @param  __hint  An iterator that serves as a hint as to where the
                       *                 element should be inserted.
                       *  @param  __x  Element to be inserted.
                       *  @return An iterator that points to the inserted element.
                       *
                       *  Note that the first parameter is only a hint and can potentially
                       *  improve the performance of the insertion process.  A bad hint would
                       *  cause no gains in efficiency.
                       *
                       *  For more on @a hinting, see:
                       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
                       *
                       *  Insertion requires amortized constant.
                       */
                      iterator
                      insert(const_iterator __hint, const value_type& __x)
                      { return _M_h.insert(__hint, __x); }
                
                      iterator
                      insert(const_iterator __hint, value_type&& __x)
                      { return _M_h.insert(__hint, std::move(__x)); }
                      ///@}
                
                      /**
                       *  @brief A template function that inserts a range of elements.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                   inserted.
                       *  @param  __last  Iterator pointing to the end of the range.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      template<typename _InputIterator>
                	void
                	insert(_InputIterator __first, _InputIterator __last)
                	{ _M_h.insert(__first, __last); }
                
                      /**
                       *  @brief Inserts a list of elements into the %unordered_multiset.
                       *  @param  __l  A std::initializer_list<value_type> of elements to be
                       *              inserted.
                       *
                       *  Complexity similar to that of the range constructor.
                       */
                      void
                      insert(initializer_list<value_type> __l)
                      { _M_h.insert(__l); }
                
                #if __cplusplus > 201402L
                      /// Extract a node.
                      node_type
                      extract(const_iterator __pos)
                      {
                	__glibcxx_assert(__pos != end());
                	return _M_h.extract(__pos);
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const key_type& __key)
                      { return _M_h.extract(__key); }
                
                      /// Re-insert an extracted node.
                      iterator
                      insert(node_type&& __nh)
                      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }
                
                      /// Re-insert an extracted node.
                      iterator
                      insert(const_iterator __hint, node_type&& __nh)
                      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
                #endif // C++17
                
                      ///@{
                      /**
                       *  @brief Erases an element from an %unordered_multiset.
                       *  @param  __position  An iterator pointing to the element to be erased.
                       *  @return An iterator pointing to the element immediately following
                       *          @a __position prior to the element being erased. If no such
                       *          element exists, end() is returned.
                       *
                       *  This function erases an element, pointed to by the given iterator,
                       *  from an %unordered_multiset.
                       *
                       *  Note that this function only erases the element, and that if the
                       *  element is itself a pointer, the pointed-to memory is not touched in
                       *  any way.  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(const_iterator __position)
                      { return _M_h.erase(__position); }
                
                      // LWG 2059.
                      iterator
                      erase(iterator __position)
                      { return _M_h.erase(__position); }
                      ///@}
                
                
                      /**
                       *  @brief Erases elements according to the provided key.
                       *  @param  __x  Key of element to be erased.
                       *  @return  The number of elements erased.
                       *
                       *  This function erases all the elements located by the given key from
                       *  an %unordered_multiset.
                       *
                       *  Note that this function only erases the element, and that if the
                       *  element is itself a pointer, the pointed-to memory is not touched in
                       *  any way.  Managing the pointer is the user's responsibility.
                       */
                      size_type
                      erase(const key_type& __x)
                      { return _M_h.erase(__x); }
                
                      /**
                       *  @brief Erases a [__first,__last) range of elements from an
                       *  %unordered_multiset.
                       *  @param  __first  Iterator pointing to the start of the range to be
                       *                  erased.
                       *  @param __last  Iterator pointing to the end of the range to
                       *                be erased.
                       *  @return The iterator @a __last.
                       *
                       *  This function erases a sequence of elements from an
                       *  %unordered_multiset.
                       *
                       *  Note that this function only erases the element, and that if
                       *  the element is itself a pointer, the pointed-to memory is not touched
                       *  in any way.  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(const_iterator __first, const_iterator __last)
                      { return _M_h.erase(__first, __last); }
                
                      /**
                       *  Erases all elements in an %unordered_multiset.
                       *
                       *  Note that this function only erases the elements, and that if the
                       *  elements themselves are pointers, the pointed-to memory is not touched
                       *  in any way. Managing the pointer is the user's responsibility.
                       */
                      void
                      clear() noexcept
                      { _M_h.clear(); }
                
                      /**
                       *  @brief  Swaps data with another %unordered_multiset.
                       *  @param  __x  An %unordered_multiset of the same element and allocator
                       *  types.
                       *
                       *  This exchanges the elements between two sets in constant time.
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(s1,s2) will feed to this function.
                       */
                      void
                      swap(unordered_multiset& __x)
                      noexcept( noexcept(_M_h.swap(__x._M_h)) )
                      { _M_h.swap(__x._M_h); }
                
                #if __cplusplus > 201402L
                      template<typename, typename, typename>
                	friend class std::_Hash_merge_helper;
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_multiset<_Value, _H2, _P2, _Alloc>& __source)
                	{
                	  using _Merge_helper
                	    = _Hash_merge_helper<unordered_multiset, _H2, _P2>;
                	  _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
                	}
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_multiset<_Value, _H2, _P2, _Alloc>&& __source)
                	{ merge(__source); }
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_set<_Value, _H2, _P2, _Alloc>& __source)
                	{
                	  using _Merge_helper
                	    = _Hash_merge_helper<unordered_multiset, _H2, _P2>;
                	  _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
                	}
                
                      template<typename _H2, typename _P2>
                	void
                	merge(unordered_set<_Value, _H2, _P2, _Alloc>&& __source)
                	{ merge(__source); }
                #endif // C++17
                
                      // observers.
                
                      ///  Returns the hash functor object with which the %unordered_multiset
                      ///  was constructed.
                      hasher
                      hash_function() const
                      { return _M_h.hash_function(); }
                
                      ///  Returns the key comparison object with which the %unordered_multiset
                      ///  was constructed.
                      key_equal
                      key_eq() const
                      { return _M_h.key_eq(); }
                
                      // lookup.
                
                      ///@{
                      /**
                       *  @brief Tries to locate an element in an %unordered_multiset.
                       *  @param  __x  Element to be located.
                       *  @return  Iterator pointing to sought-after element, or end() if not
                       *           found.
                       *
                       *  This function takes a key and tries to locate the element with which
                       *  the key matches.  If successful the function returns an iterator
                       *  pointing to the sought after element.  If unsuccessful it returns the
                       *  past-the-end ( @c end() ) iterator.
                       */
                      iterator
                      find(const key_type& __x)
                      { return _M_h.find(__x); }
                
                      const_iterator
                      find(const key_type& __x) const
                      { return _M_h.find(__x); }
                      ///@}
                
                      /**
                       *  @brief  Finds the number of elements.
                       *  @param  __x  Element to located.
                       *  @return  Number of elements with specified key.
                       */
                      size_type
                      count(const key_type& __x) const
                      { return _M_h.count(__x); }
                
                #if __cplusplus > 201703L
                      /**
                       *  @brief  Finds whether an element with the given key exists.
                       *  @param  __x  Key of elements to be located.
                       *  @return  True if there is any element with the specified key.
                       */
                      bool
                      contains(const key_type& __x) const
                      { return _M_h.find(__x) != _M_h.end(); }
                #endif
                
                      ///@{
                      /**
                       *  @brief Finds a subsequence matching given key.
                       *  @param  __x  Key to be located.
                       *  @return  Pair of iterators that possibly points to the subsequence
                       *           matching given key.
                       */
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __x)
                      { return _M_h.equal_range(__x); }
                
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __x) const
                      { return _M_h.equal_range(__x); }
                      ///@}
                
                      // bucket interface.
                
                      /// Returns the number of buckets of the %unordered_multiset.
                      size_type
                      bucket_count() const noexcept
                      { return _M_h.bucket_count(); }
                
                      /// Returns the maximum number of buckets of the %unordered_multiset.
                      size_type
                      max_bucket_count() const noexcept
                      { return _M_h.max_bucket_count(); }
                
                      /*
                       * @brief  Returns the number of elements in a given bucket.
                       * @param  __n  A bucket index.
                       * @return  The number of elements in the bucket.
                       */
                      size_type
                      bucket_size(size_type __n) const
                      { return _M_h.bucket_size(__n); }
                
                      /*
                       * @brief  Returns the bucket index of a given element.
                       * @param  __key  A key instance.
                       * @return  The key bucket index.
                       */
                      size_type
                      bucket(const key_type& __key) const
                      { return _M_h.bucket(__key); }
                
                      ///@{
                      /**
                       *  @brief  Returns a read-only (constant) iterator pointing to the first
                       *         bucket element.
                       *  @param  __n The bucket index.
                       *  @return  A read-only local iterator.
                       */
                      local_iterator
                      begin(size_type __n)
                      { return _M_h.begin(__n); }
                
                      const_local_iterator
                      begin(size_type __n) const
                      { return _M_h.begin(__n); }
                
                      const_local_iterator
                      cbegin(size_type __n) const
                      { return _M_h.cbegin(__n); }
                      ///@}
                
                      ///@{
                      /**
                       *  @brief  Returns a read-only (constant) iterator pointing to one past
                       *         the last bucket elements.
                       *  @param  __n The bucket index.
                       *  @return  A read-only local iterator.
                       */
                      local_iterator
                      end(size_type __n)
                      { return _M_h.end(__n); }
                
                      const_local_iterator
                      end(size_type __n) const
                      { return _M_h.end(__n); }
                
                      const_local_iterator
                      cend(size_type __n) const
                      { return _M_h.cend(__n); }
                      ///@}
                
                      // hash policy.
                
                      /// Returns the average number of elements per bucket.
                      float
                      load_factor() const noexcept
                      { return _M_h.load_factor(); }
                
                      /// Returns a positive number that the %unordered_multiset tries to keep the
                      /// load factor less than or equal to.
                      float
                      max_load_factor() const noexcept
                      { return _M_h.max_load_factor(); }
                
                      /**
                       *  @brief  Change the %unordered_multiset maximum load factor.
                       *  @param  __z The new maximum load factor.
                       */
                      void
                      max_load_factor(float __z)
                      { _M_h.max_load_factor(__z); }
                
                      /**
                       *  @brief  May rehash the %unordered_multiset.
                       *  @param  __n The new number of buckets.
                       *
                       *  Rehash will occur only if the new number of buckets respect the
                       *  %unordered_multiset maximum load factor.
                       */
                      void
                      rehash(size_type __n)
                      { _M_h.rehash(__n); }
                
                      /**
                       *  @brief  Prepare the %unordered_multiset for a specified number of
                       *          elements.
                       *  @param  __n Number of elements required.
                       *
                       *  Same as rehash(ceil(n / max_load_factor())).
                       */
                      void
                      reserve(size_type __n)
                      { _M_h.reserve(__n); }
                
                      template<typename _Value1, typename _Hash1, typename _Pred1,
                	       typename _Alloc1>
                        friend bool
                      operator==(const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&,
                		 const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>&);
                    };
                
                
                #if __cpp_deduction_guides >= 201606
                
                  template<typename _InputIterator,
                	   typename _Hash =
                	     hash<typename iterator_traits<_InputIterator>::value_type>,
                	   typename _Pred =
                	     equal_to<typename iterator_traits<_InputIterator>::value_type>,
                	   typename _Allocator =
                	     allocator<typename iterator_traits<_InputIterator>::value_type>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireNotAllocator<_Pred>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_multiset(_InputIterator, _InputIterator,
                		       unordered_multiset<int>::size_type = {},
                		       _Hash = _Hash(), _Pred = _Pred(),
                		       _Allocator = _Allocator())
                    -> unordered_multiset<typename iterator_traits<_InputIterator>::value_type,
                                          _Hash, _Pred, _Allocator>;
                
                  template<typename _Tp, typename _Hash = hash<_Tp>,
                	   typename _Pred = equal_to<_Tp>,
                	   typename _Allocator = allocator<_Tp>,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireNotAllocator<_Pred>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_multiset(initializer_list<_Tp>,
                		       unordered_multiset<int>::size_type = {},
                		       _Hash = _Hash(), _Pred = _Pred(),
                		       _Allocator = _Allocator())
                    -> unordered_multiset<_Tp, _Hash, _Pred, _Allocator>;
                
                  template<typename _InputIterator, typename _Allocator,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_multiset(_InputIterator, _InputIterator,
                		       unordered_multiset<int>::size_type, _Allocator)
                    -> unordered_multiset<typename iterator_traits<_InputIterator>::value_type,
                			  hash<typename
                			       iterator_traits<_InputIterator>::value_type>,
                			  equal_to<typename
                				   iterator_traits<_InputIterator>::value_type>,
                			  _Allocator>;
                
                  template<typename _InputIterator, typename _Hash, typename _Allocator,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_multiset(_InputIterator, _InputIterator,
                		       unordered_multiset<int>::size_type,
                		       _Hash, _Allocator)
                    -> unordered_multiset<typename
                			  iterator_traits<_InputIterator>::value_type,
                			  _Hash,
                			  equal_to<
                			    typename
                			    iterator_traits<_InputIterator>::value_type>,
                			  _Allocator>;
                
                  template<typename _Tp, typename _Allocator,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_multiset(initializer_list<_Tp>,
                		       unordered_multiset<int>::size_type, _Allocator)
                    -> unordered_multiset<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;
                
                  template<typename _Tp, typename _Hash, typename _Allocator,
                	   typename = _RequireNotAllocatorOrIntegral<_Hash>,
                	   typename = _RequireAllocator<_Allocator>>
                    unordered_multiset(initializer_list<_Tp>,
                		       unordered_multiset<int>::size_type, _Hash, _Allocator)
                    -> unordered_multiset<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
                
                #endif
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    inline void
                    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
                	 unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    inline void
                    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
                	 unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
                    { return __x._M_h._M_equal(__y._M_h); }
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
                    { return __x._M_h._M_equal(__y._M_h); }
                
                  template<class _Value, class _Hash, class _Pred, class _Alloc>
                    inline bool
                    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
                	       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
                    { return !(__x == __y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                #if __cplusplus > 201402L
                  // Allow std::unordered_set access to internals of compatible sets.
                  template<typename _Val, typename _Hash1, typename _Eq1, typename _Alloc,
                	   typename _Hash2, typename _Eq2>
                    struct _Hash_merge_helper<
                      _GLIBCXX_STD_C::unordered_set<_Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>
                    {
                    private:
                      template<typename... _Tp>
                	using unordered_set = _GLIBCXX_STD_C::unordered_set<_Tp...>;
                      template<typename... _Tp>
                	using unordered_multiset = _GLIBCXX_STD_C::unordered_multiset<_Tp...>;
                
                      friend unordered_set<_Val, _Hash1, _Eq1, _Alloc>;
                
                      static auto&
                      _S_get_table(unordered_set<_Val, _Hash2, _Eq2, _Alloc>& __set)
                      { return __set._M_h; }
                
                      static auto&
                      _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)
                      { return __set._M_h; }
                    };
                
                  // Allow std::unordered_multiset access to internals of compatible sets.
                  template<typename _Val, typename _Hash1, typename _Eq1, typename _Alloc,
                	   typename _Hash2, typename _Eq2>
                    struct _Hash_merge_helper<
                      _GLIBCXX_STD_C::unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>,
                      _Hash2, _Eq2>
                    {
                    private:
                      template<typename... _Tp>
                	using unordered_set = _GLIBCXX_STD_C::unordered_set<_Tp...>;
                      template<typename... _Tp>
                	using unordered_multiset = _GLIBCXX_STD_C::unordered_multiset<_Tp...>;
                
                      friend unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>;
                
                      static auto&
                      _S_get_table(unordered_set<_Val, _Hash2, _Eq2, _Alloc>& __set)
                      { return __set._M_h; }
                
                      static auto&
                      _S_get_table(unordered_multiset<_Val, _Hash2, _Eq2, _Alloc>& __set)
                      { return __set._M_h; }
                    };
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _UNORDERED_SET_H */


Top 10 Lines:

     Line      Count

      421     614700
       97        900
      135        900
      320        900
      334        900

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   618300   Total number of line executions
123660.00   Average executions per line


*** File /usr/include/c++/9/bits/cpp_type_traits.h:
                // The  -*- C++ -*- type traits classes for internal use in libstdc++
                
                // Copyright (C) 2000-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/cpp_type_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{ext/type_traits}
                 */
                
                // Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
                
                #ifndef _CPP_TYPE_TRAITS_H
                #define _CPP_TYPE_TRAITS_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                //
                // This file provides some compile-time information about various types.
                // These representations were designed, on purpose, to be constant-expressions
                // and not types as found in <bits/type_traits.h>.  In particular, they
                // can be used in control structures and the optimizer hopefully will do
                // the obvious thing.
                //
                // Why integral expressions, and not functions nor types?
                // Firstly, these compile-time entities are used as template-arguments
                // so function return values won't work:  We need compile-time entities.
                // We're left with types and constant  integral expressions.
                // Secondly, from the point of view of ease of use, type-based compile-time
                // information is -not- *that* convenient.  One has to write lots of
                // overloaded functions and to hope that the compiler will select the right
                // one. As a net effect, the overall structure isn't very clear at first
                // glance.
                // Thirdly, partial ordering and overload resolution (of function templates)
                // is highly costly in terms of compiler-resource.  It is a Good Thing to
                // keep these resource consumption as least as possible.
                //
                // See valarray_array.h for a case use.
                //
                // -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
                //
                // Update 2005: types are also provided and <bits/type_traits.h> has been
                // removed.
                //
                
                extern "C++" {
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  struct __true_type { };
                  struct __false_type { };
                
                  template<bool>
                    struct __truth_type
                    { typedef __false_type __type; };
                
                  template<>
                    struct __truth_type<true>
                    { typedef __true_type __type; };
                
                  // N.B. The conversions to bool are needed due to the issue
                  // explained in c++/19404.
                  template<class _Sp, class _Tp>
                    struct __traitor
                    {
                      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
                      typedef typename __truth_type<__value>::__type __type;
                    };
                
                  // Compare for equality of types.
                  template<typename, typename>
                    struct __are_same
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __are_same<_Tp, _Tp>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  // Holds if the template-argument is a void type.
                  template<typename _Tp>
                    struct __is_void
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_void<void>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Integer types
                  //
                  template<typename _Tp>
                    struct __is_integer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Thirteen specializations (yes there are eleven standard integer
                  // types; <em>long long</em> and <em>unsigned long long</em> are
                  // supported as extensions).  Up to four target-specific __int<N>
                  // types are supported as well.
                  template<>
                    struct __is_integer<bool>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                # ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    struct __is_integer<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                # endif
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct __is_integer<char8_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __is_integer<char16_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char32_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<>
                    struct __is_integer<short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #define __INT_N(TYPE) 			\
                  template<>				\
                    struct __is_integer<TYPE>		\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };					\
                  template<>				\
                    struct __is_integer<unsigned TYPE>	\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };
                
                #ifdef __GLIBCXX_TYPE_INT_N_0
                __INT_N(__GLIBCXX_TYPE_INT_N_0)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_1
                __INT_N(__GLIBCXX_TYPE_INT_N_1)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_2
                __INT_N(__GLIBCXX_TYPE_INT_N_2)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_3
                __INT_N(__GLIBCXX_TYPE_INT_N_3)
                #endif
                
                #undef __INT_N
                
                  //
                  // Floating point types
                  //
                  template<typename _Tp>
                    struct __is_floating
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // three specializations (float, double and 'long double')
                  template<>
                    struct __is_floating<float>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<long double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Pointer types
                  //
                  template<typename _Tp>
                    struct __is_pointer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __is_pointer<_Tp*>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // An arithmetic type is an integer type or a floating point type
                  //
                  template<typename _Tp>
                    struct __is_arithmetic
                    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
                    { };
                
                  //
                  // A scalar type is an arithmetic type or a pointer type
                  // 
                  template<typename _Tp>
                    struct __is_scalar
                    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
                    { };
                
                  //
                  // For use in std::copy and std::find overloads for streambuf iterators.
                  //
                  template<typename _Tp>
                    struct __is_char
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_char<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    struct __is_char<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<typename _Tp>
                    struct __is_byte
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_byte<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #if __cplusplus >= 201703L
                  enum class byte : unsigned char;
                
                  template<>
                    struct __is_byte<byte>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif // C++17
                
                  //
                  // Move iterator type
                  //
                  template<typename _Tp>
                    struct __is_move_iterator
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the move_iterator wrapper.
                  template<typename _Iterator>
                    inline _Iterator
        5402 ->     __miter_base(_Iterator __it)
                    { return __it; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                } // extern "C++"
                
                #endif //_CPP_TYPE_TRAITS_H


Top 10 Lines:

     Line      Count

      428       5402

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     5402   Total number of line executions
  5402.00   Average executions per line


*** File /usr/include/c++/9/ext/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/alloc_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_ALLOC_TRAITS_H
                #define _EXT_ALLOC_TRAITS_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <bits/move.h>
                # include <bits/alloc_traits.h>
                #else
                # include <bits/allocator.h>  // for __alloc_swap
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                /**
                 * @brief  Uniform interface to C++98 and C++11 allocators.
                 * @ingroup allocators
                */
                template<typename _Alloc, typename = typename _Alloc::value_type>
                  struct __alloc_traits
                #if __cplusplus >= 201103L
                  : std::allocator_traits<_Alloc>
                #endif
                  {
                    typedef _Alloc allocator_type;
                #if __cplusplus >= 201103L
                    typedef std::allocator_traits<_Alloc>           _Base_type;
                    typedef typename _Base_type::value_type         value_type;
                    typedef typename _Base_type::pointer            pointer;
                    typedef typename _Base_type::const_pointer      const_pointer;
                    typedef typename _Base_type::size_type          size_type;
                    typedef typename _Base_type::difference_type    difference_type;
                    // C++11 allocators do not define reference or const_reference
                    typedef value_type&                             reference;
                    typedef const value_type&                       const_reference;
                    using _Base_type::allocate;
                    using _Base_type::deallocate;
                    using _Base_type::construct;
                    using _Base_type::destroy;
                    using _Base_type::max_size;
                
                  private:
                    template<typename _Ptr>
                      using __is_custom_pointer
                	= std::__and_<std::is_same<pointer, _Ptr>,
                		      std::__not_<std::is_pointer<_Ptr>>>;
                
                  public:
                    // overload construct for non-standard pointer types
                    template<typename _Ptr, typename... _Args>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
                      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
                					      std::forward<_Args>(__args)...)))
                      {
                	_Base_type::construct(__a, std::__to_address(__p),
                			      std::forward<_Args>(__args)...);
                      }
                
                    // overload destroy for non-standard pointer types
                    template<typename _Ptr>
                      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
                      destroy(_Alloc& __a, _Ptr __p)
                      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
                      { _Base_type::destroy(__a, std::__to_address(__p)); }
                
         900 ->     static _Alloc _S_select_on_copy(const _Alloc& __a)
                    { return _Base_type::select_on_container_copy_construction(__a); }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    { std::__alloc_on_swap(__a, __b); }
                
         900 ->     static constexpr bool _S_propagate_on_copy_assign()
                    { return _Base_type::propagate_on_container_copy_assignment::value; }
                
                    static constexpr bool _S_propagate_on_move_assign()
                    { return _Base_type::propagate_on_container_move_assignment::value; }
                
                    static constexpr bool _S_propagate_on_swap()
                    { return _Base_type::propagate_on_container_swap::value; }
                
       ##### ->     static constexpr bool _S_always_equal()
                    { return _Base_type::is_always_equal::value; }
                
                    static constexpr bool _S_nothrow_move()
                    { return _S_propagate_on_move_assign() || _S_always_equal(); }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
                #else
                
                    typedef typename _Alloc::pointer                pointer;
                    typedef typename _Alloc::const_pointer          const_pointer;
                    typedef typename _Alloc::value_type             value_type;
                    typedef typename _Alloc::reference              reference;
                    typedef typename _Alloc::const_reference        const_reference;
                    typedef typename _Alloc::size_type              size_type;
                    typedef typename _Alloc::difference_type        difference_type;
                
                    _GLIBCXX_NODISCARD static pointer
                    allocate(_Alloc& __a, size_type __n)
                    { return __a.allocate(__n); }
                
                    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                    { __a.deallocate(__p, __n); }
                
                    template<typename _Tp>
                      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
                      { __a.construct(__p, __arg); }
                
                    static void destroy(_Alloc& __a, pointer __p)
                    { __a.destroy(__p); }
                
                    static size_type max_size(const _Alloc& __a)
                    { return __a.max_size(); }
                
                    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Alloc::template rebind<_Tp>::other other; };
                #endif
                  };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

       97        900
      103        900

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

     1800   Total number of line executions
   600.00   Average executions per line


*** File /usr/include/c++/9/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp;
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __tmp = this->_M_allocate(__n);
                	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  __tmp, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __tmp = _M_allocate_and_copy(__n,
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	    }
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                #if __cplusplus > 201402L
                      typename vector<_Tp, _Alloc>::reference
                #else
                      void
                #endif
      307350 ->       vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
                #if __cplusplus > 201402L
                	return back();
                #endif
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == end())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  {
                #if __cplusplus >= 201103L
                	    const auto __pos = begin() + (__position - cbegin());
                	    // __x could be an existing element of this vector, so make a
                	    // copy of it before _M_insert_aux moves elements around.
                	    _Temporary_value __x_copy(this, __x);
                	    _M_insert_aux(__pos, std::move(__x_copy._M_val()));
                #else
                	    _M_insert_aux(__position, __x);
                #endif
                	  }
                      else
                #if __cplusplus >= 201103L
                	_M_realloc_insert(begin() + (__position - cbegin()), __x);
                #else
                	_M_realloc_insert(__position, __x);
                #endif
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
         900 ->     vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
           2 ->     vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp._M_impl._M_swap_data(this->_M_impl);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  const size_type __add = __n - size();
                	  _GLIBCXX_ASAN_ANNOTATE_GROW(__add);
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					  __add, __val, _M_get_Tp_allocator());
                	  _GLIBCXX_ASAN_ANNOTATE_GREW(__add);
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, (void)++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  _M_range_insert(end(), __first, __last,
                			  std::__iterator_category(__first));
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    _S_check_init_len(__len, _M_get_Tp_allocator());
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    const size_type __attribute__((__unused__)) __n = __len - size();
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    auto
                    vector<_Tp, _Alloc>::
                    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
                    {
                      const auto __n = __position - cbegin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == cend())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::move(__v));
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_insert_aux(begin() + __n, std::move(__v));
                      else
                	_M_realloc_insert(begin() + __n, std::move(__v));
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      auto
                      vector<_Tp, _Alloc>::
                      _M_emplace_aux(const_iterator __position, _Args&&... __args)
                      -> iterator
                      {
                	const auto __n = __position - cbegin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  if (__position == cend())
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				       std::forward<_Args>(__args)...);
                	      ++this->_M_impl._M_finish;
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	    }
                	  else
                	    {
                	      // We need to construct a temporary because something in __args...
                	      // could alias one of the elements of the container and so we
                	      // need to use it before _M_insert_aux moves elements around.
                	      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
                	      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
                	    }
                	else
                	  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
                
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _Arg>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Arg&& __arg)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			       _GLIBCXX_MOVE(*(this->_M_impl._M_finish - 1)));
                      ++this->_M_impl._M_finish;
                      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                #if __cplusplus < 201103L
                      _Tp __x_copy = __x;
                #endif
                      _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                			      this->_M_impl._M_finish - 2,
                			      this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                      *__position = __x_copy;
                #else
                      *__position = std::forward<_Arg>(__arg);
                #endif
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
          20 ->       vector<_Tp, _Alloc>::
                      _M_realloc_insert(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_realloc_insert(iterator __position, const _Tp& __x)
                #endif
                    {
                      const size_type __len =
                	_M_check_len(size_type(1), "vector::_M_realloc_insert");
                      pointer __old_start = this->_M_impl._M_start;
                      pointer __old_finish = this->_M_impl._M_finish;
                      const size_type __elems_before = __position - begin();
                      pointer __new_start(this->_M_allocate(__len));
                      pointer __new_finish(__new_start);
                      __try
                	{
                	  // The order of the three operations is dictated by the C++11
                	  // case, where the moves could alter a new element belonging
                	  // to the existing vector.  This is an issue only for callers
                	  // taking the element by lvalue ref (see last bullet of C++11
                	  // [res.on.arguments]).
                	  _Alloc_traits::construct(this->_M_impl,
                				   __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				   std::forward<_Args>(__args)...);
                #else
                				   __x);
                #endif
                	  __new_finish = pointer();
                
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __new_finish = _S_relocate(__old_start, __position.base(),
                					 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish = _S_relocate(__position.base(), __old_finish,
                					 __new_finish, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__old_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), __old_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                	}
                      __catch(...)
                	{
                	  if (!__new_finish)
                	    _Alloc_traits::destroy(this->_M_impl,
                				   __new_start + __elems_before);
                	  else
                	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	  _M_deallocate(__new_start, __len);
                	  __throw_exception_again;
                	}
                #if __cplusplus >= 201103L
                      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
                #endif
                	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      _M_deallocate(__old_start,
                		    this->_M_impl._M_end_of_storage - __old_start);
                      this->_M_impl._M_start = __new_start;
                      this->_M_impl._M_finish = __new_finish;
                      this->_M_impl._M_end_of_storage = __new_start + __len;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                #if __cplusplus < 201103L
                	      value_type __x_copy = __x;
                #else
                	      _Temporary_value __tmp(this, __x);
                	      value_type& __x_copy = __tmp._M_val();
                #endif
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  this->_M_impl._M_finish =
                		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						  __n - __elems_after,
                						  __x_copy,
                						  _M_get_Tp_allocator());
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_realloc_insert above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = pointer();
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  const size_type __size = size();
                	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
                					 - this->_M_impl._M_finish);
                
                	  if (__size > max_size() || __navail > max_size() - __size)
                	    __builtin_unreachable();
                
                	  if (__navail >= __n)
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	      this->_M_impl._M_finish =
                		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                						 __n, _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      pointer __new_start(this->_M_allocate(__len));
                	      if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                		{
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		}
                	      else
                		{
                		  pointer __destroy_from = pointer();
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		      __destroy_from = __new_start + __size;
                		      std::__uninitialized_move_if_noexcept_a(
                			      this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      if (__destroy_from)
                			std::_Destroy(__destroy_from, __destroy_from + __n,
                				      _M_get_Tp_allocator());
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                				_M_get_Tp_allocator());
                		}
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_start + __size + __n;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	if (__pos == end())
                	  {
                	    for (; __first != __last; ++__first)
                	      insert(end(), *__first);
                	  }
                	else if (__first != __last)
                	  {
                	    vector __tmp(__first, __last, _M_get_Tp_allocator());
                	    insert(__pos,
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.begin()),
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.end()));
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_GLIBCXX_ASAN_ANNOTATE_REINIT;
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_pointer __q = this->_M_allocate(__n);
                      iterator __start(std::__addressof(*__q), 0);
                      iterator __finish(_M_copy_aligned(begin(), end(), __start));
                      this->_M_deallocate();
                      this->_M_impl._M_start = __start;
                      this->_M_impl._M_finish = __finish;
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  iterator __finish = std::copy(__position, end(),
                					__i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_pointer __q = this->_M_allocate(__len);
                		iterator __start(std::__addressof(*__q), 0);
                		iterator __i = _M_copy_aligned(begin(), __position, __start);
                		__i = std::copy(__first, __last, __i);
                		iterator __finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = __start;
                		this->_M_impl._M_finish = __finish;
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  *__i++ = __x;
                	  iterator __finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      return __position;
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	_M_erase_at_end(std::copy(__last, end(), __first));
                      return __first;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  _M_reallocate(size());
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #undef _GLIBCXX_ASAN_ANNOTATE_REINIT
                #undef _GLIBCXX_ASAN_ANNOTATE_GROW
                #undef _GLIBCXX_ASAN_ANNOTATE_GREW
                #undef _GLIBCXX_ASAN_ANNOTATE_SHRINK
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      109     307350
      198        900
      426         20
      257          2

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

   308272   Total number of line executions
 77068.00   Average executions per line


*** File /usr/include/c++/9/bits/stl_iterator_base_funcs.h:
                // Functions used by iterators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_funcs.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility
                 *  functions, such as distance() and advance().
                 */
                
                #ifndef _STL_ITERATOR_BASE_FUNCS_H
                #define _STL_ITERATOR_BASE_FUNCS_H 1
                
                #pragma GCC system_header
                
                #include <bits/concept_check.h>
                #include <debug/assertions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                  // Forward declaration for the overloads of __distance.
                  template <typename> struct _List_iterator;
                  template <typename> struct _List_const_iterator;
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                  template<typename _InputIterator>
                    inline _GLIBCXX14_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
         900 ->     __distance(_InputIterator __first, _InputIterator __last,
                               input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      while (__first != __last)
                	{
                	  ++__first;
                	  ++__n;
                	}
                      return __n;
                    }
                
                  template<typename _RandomAccessIterator>
                    inline _GLIBCXX14_CONSTEXPR
                    typename iterator_traits<_RandomAccessIterator>::difference_type
           1 ->     __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      return __last - __first;
                    }
                
                #if _GLIBCXX_USE_CXX11_ABI
                  // Forward declaration because of the qualified call in distance.
                  template<typename _Tp>
                    ptrdiff_t
                    __distance(_GLIBCXX_STD_C::_List_iterator<_Tp>,
                	       _GLIBCXX_STD_C::_List_iterator<_Tp>,
                	       input_iterator_tag);
                
                  template<typename _Tp>
                    ptrdiff_t
                    __distance(_GLIBCXX_STD_C::_List_const_iterator<_Tp>,
                	       _GLIBCXX_STD_C::_List_const_iterator<_Tp>,
                	       input_iterator_tag);
                #endif
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __first  An input iterator.
                   *  @param  __last  An input iterator.
                   *  @return  The distance between them.
                   *
                   *  Returns @c n such that __first + n == __last.  This requires
                   *  that @p __last must be reachable from @p __first.  Note that @c
                   *  n may be negative.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator>
                    inline _GLIBCXX17_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
         901 ->     distance(_InputIterator __first, _InputIterator __last)
                    {
                      // concept requirements -- taken care of in __distance
                      return std::__distance(__first, __last,
                			     std::__iterator_category(__first));
                    }
                
                  template<typename _InputIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_assert(__n >= 0);
                      while (__n--)
                	++__i;
                    }
                
                  template<typename _BidirectionalIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_BidirectionalIterator& __i, _Distance __n,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      if (__n > 0)
                        while (__n--)
                	  ++__i;
                      else
                        while (__n++)
                	  --__i;
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_RandomAccessIterator& __i, _Distance __n,
                              random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      if (__builtin_constant_p(__n) && __n == 1)
                	++__i;
                      else if (__builtin_constant_p(__n) && __n == -1)
                	--__i;
                      else
                	__i += __n;
                    }
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __i  An input iterator.
                   *  @param  __n  The @a delta by which to change @p __i.
                   *  @return  Nothing.
                   *
                   *  This increments @p i by @p n.  For bidirectional and random access
                   *  iterators, @p __n may be negative, in which case @p __i is decremented.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator, typename _Distance>
                    inline _GLIBCXX17_CONSTEXPR void
                    advance(_InputIterator& __i, _Distance __n)
                    {
                      // concept requirements -- taken care of in __advance
                      typename iterator_traits<_InputIterator>::difference_type __d = __n;
                      std::__advance(__i, __d, std::__iterator_category(__i));
                    }
                
                #if __cplusplus >= 201103L
                
                  template<typename _InputIterator>
                    inline _GLIBCXX17_CONSTEXPR _InputIterator
                    next(_InputIterator __x, typename
                	 iterator_traits<_InputIterator>::difference_type __n = 1)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      std::advance(__x, __n);
                      return __x;
                    }
                
                  template<typename _BidirectionalIterator>
                    inline _GLIBCXX17_CONSTEXPR _BidirectionalIterator
                    prev(_BidirectionalIterator __x, typename
                	 iterator_traits<_BidirectionalIterator>::difference_type __n = 1) 
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      std::advance(__x, -__n);
                      return __x;
                    }
                
                #endif // C++11
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_FUNCS_H */


Top 10 Lines:

     Line      Count

      138        901
       80        900
       98          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

     1802   Total number of line executions
   600.67   Average executions per line


*** File /usr/include/c++/9/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _STL_PAIR_H
                #define _STL_PAIR_H 1
                
                #include <bits/move.h> // for std::move / std::forward, and std::swap
                
                #if __cplusplus >= 201103L
                #include <type_traits> // for std::__decay_and_strip too
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                #if __cplusplus >= 201103L
                  /// piecewise_construct_t
                  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
                
                  /// piecewise_construct
                  _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =
                    piecewise_construct_t();
                
                  // Forward declarations.
                  template<typename...>
                    class tuple;
                
                  template<std::size_t...>
                    struct _Index_tuple;
                
                  // Concept utility functions, reused in conditionally-explicit
                  // constructors.
                  // See PR 70437, don't look at is_constructible or
                  // is_convertible if the types are the same to
                  // avoid querying those properties for incomplete types.
                  template <bool, typename _T1, typename _T2>
                    struct _PCC
                    {
                      template <typename _U1, typename _U2>
                      static constexpr bool _ConstructiblePair()
                      {
                	return __and_<is_constructible<_T1, const _U1&>,
                		      is_constructible<_T2, const _U2&>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyConvertiblePair()
                      {
                	return __and_<is_convertible<const _U1&, _T1>,
                		      is_convertible<const _U2&, _T2>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _MoveConstructiblePair()
                      {
                	return __and_<is_constructible<_T1, _U1&&>,
                		      is_constructible<_T2, _U2&&>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyMoveConvertiblePair()
                      {
                	return __and_<is_convertible<_U1&&, _T1>,
                		      is_convertible<_U2&&, _T2>>::value;
                      }
                
                      template <bool __implicit, typename _U1, typename _U2>
                      static constexpr bool _CopyMovePair()
                      {
                	using __do_converts = __and_<is_convertible<const _U1&, _T1>,
                				  is_convertible<_U2&&, _T2>>;
                	using __converts = typename conditional<__implicit,
                				       __do_converts,
                				       __not_<__do_converts>>::type;
                	return __and_<is_constructible<_T1, const _U1&>,
                		      is_constructible<_T2, _U2&&>,
                		      __converts
                		      >::value;
                      }
                
                      template <bool __implicit, typename _U1, typename _U2>
                      static constexpr bool _MoveCopyPair()
                      {
                	using __do_converts = __and_<is_convertible<_U1&&, _T1>,
                				  is_convertible<const _U2&, _T2>>;
                	using __converts = typename conditional<__implicit,
                				       __do_converts,
                				       __not_<__do_converts>>::type;
                	return __and_<is_constructible<_T1, _U1&&>,
                		      is_constructible<_T2, const _U2&&>,
                		      __converts
                		      >::value;
                      }
                  };
                
                  template <typename _T1, typename _T2>
                    struct _PCC<false, _T1, _T2>
                    {
                      template <typename _U1, typename _U2>
                      static constexpr bool _ConstructiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyConvertiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _MoveConstructiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyMoveConvertiblePair()
                      {
                	return false;
                      }
                  };
                
                  // PR libstdc++/79141, a utility type for preventing
                  // initialization of an argument of a disabled assignment
                  // operator from a pair of empty braces.
                  struct __nonesuch_no_braces : std::__nonesuch {
                    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
                  };
                #endif // C++11
                
                  template<typename _U1, typename _U2> class __pair_base
                  {
                #if __cplusplus >= 201103L
                    template<typename _T1, typename _T2> friend struct pair;
                    __pair_base() = default;
                    ~__pair_base() = default;
                    __pair_base(const __pair_base&) = default;
                    __pair_base& operator=(const __pair_base&) = delete;
                #endif // C++11
                  };
                
                 /**
                   *  @brief Struct holding two objects of arbitrary type.
                   *
                   *  @tparam _T1  Type of first object.
                   *  @tparam _T2  Type of second object.
                   */
                  template<typename _T1, typename _T2>
                    struct pair
                    : private __pair_base<_T1, _T2>
                    {
                      typedef _T1 first_type;    /// @c first_type is the first bound type
                      typedef _T2 second_type;   /// @c second_type is the second bound type
                
                      _T1 first;                 /// @c first is a copy of the first object
                      _T2 second;                /// @c second is a copy of the second object
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                #if __cplusplus >= 201103L
                      template <typename _U1 = _T1,
                                typename _U2 = _T2,
                                typename enable_if<__and_<
                                                     __is_implicitly_default_constructible<_U1>,
                                                     __is_implicitly_default_constructible<_U2>>
                                                   ::value, bool>::type = true>
                #endif
                      _GLIBCXX_CONSTEXPR pair()
                      : first(), second() { }
                
                #if __cplusplus >= 201103L
                      template <typename _U1 = _T1,
                                typename _U2 = _T2,
                                typename enable_if<__and_<
                                       is_default_constructible<_U1>,
                                       is_default_constructible<_U2>,
                                       __not_<
                                         __and_<__is_implicitly_default_constructible<_U1>,
                                                __is_implicitly_default_constructible<_U2>>>>
                                                   ::value, bool>::type = false>
                      explicit constexpr pair()
                      : first(), second() { }
                #endif
                
                      /** Two objects may be passed to a @c pair constructor to be copied.  */
                #if __cplusplus < 201103L
                      pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                #else
                      // Shortcut for constraining the templates that don't take pairs.
                      using _PCCP = _PCC<true, _T1, _T2>;
                
                      template<typename _U1 = _T1, typename _U2=_T2, typename
                	       enable_if<_PCCP::template
                			   _ConstructiblePair<_U1, _U2>()
                	                 && _PCCP::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
                      constexpr pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                       template<typename _U1 = _T1, typename _U2=_T2, typename
                		enable_if<_PCCP::template
                			    _ConstructiblePair<_U1, _U2>()
                	                  && !_PCCP::template
                			    _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                      explicit constexpr pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                #endif
                
                      /** There is also a templated copy ctor for the @c pair class itself.  */
                #if __cplusplus < 201103L
                      template<typename _U1, typename _U2>
                	pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #else
                      // Shortcut for constraining the templates that take pairs.
                      template <typename _U1, typename _U2>
                        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
                			    || !is_same<_T2, _U2>::value,
                			    _T1, _T2>;
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _ConstructiblePair<_U1, _U2>()
                	                 && _PCCFP<_U1, _U2>::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                			  bool>::type=true>
                        constexpr pair(const pair<_U1, _U2>& __p)
                        : first(__p.first), second(__p.second) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _ConstructiblePair<_U1, _U2>()
                			 && !_PCCFP<_U1, _U2>::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                
                      constexpr pair(const pair&) = default;
                      constexpr pair(pair&&) = default;
                
                      // DR 811.
                      template<typename _U1, typename
                	       enable_if<_PCCP::template
                			   _MoveCopyPair<true, _U1, _T2>(),
                                         bool>::type=true>
                       constexpr pair(_U1&& __x, const _T2& __y)
                       : first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<typename _U1, typename
                	       enable_if<_PCCP::template
                			   _MoveCopyPair<false, _U1, _T2>(),
                                         bool>::type=false>
                       explicit constexpr pair(_U1&& __x, const _T2& __y)
                       : first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<typename _U2, typename
                	       enable_if<_PCCP::template
                			   _CopyMovePair<true, _T1, _U2>(),
                                         bool>::type=true>
                       constexpr pair(const _T1& __x, _U2&& __y)
                       : first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U2, typename
                	       enable_if<_PCCP::template
                			   _CopyMovePair<false, _T1, _U2>(),
                                         bool>::type=false>
                       explicit pair(const _T1& __x, _U2&& __y)
                       : first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCP::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && _PCCP::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
      922050 -> 	constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCP::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && !_PCCP::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && _PCCFP<_U1, _U2>::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
                	constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && !_PCCFP<_U1, _U2>::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename... _Args1, typename... _Args2>
                        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
                
                      pair&
                      operator=(typename conditional<
                		__and_<is_copy_assignable<_T1>,
                		       is_copy_assignable<_T2>>::value,
                		const pair&, const __nonesuch_no_braces&>::type __p)
                      {
                	first = __p.first;
                	second = __p.second;
                	return *this;
                      }
                
                      pair&
                      operator=(typename conditional<
                		__and_<is_move_assignable<_T1>,
                		       is_move_assignable<_T2>>::value,
                		pair&&, __nonesuch_no_braces&&>::type __p)
                      noexcept(__and_<is_nothrow_move_assignable<_T1>,
                		      is_nothrow_move_assignable<_T2>>::value)
                      {
                	first = std::forward<first_type>(__p.first);
                	second = std::forward<second_type>(__p.second);
                	return *this;
                      }
                
                      template<typename _U1, typename _U2>
                      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
                				is_assignable<_T2&, const _U2&>>::value,
                			 pair&>::type
                	operator=(const pair<_U1, _U2>& __p)
                	{
                	  first = __p.first;
                	  second = __p.second;
                	  return *this;
                	}
                
                      template<typename _U1, typename _U2>
                      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
                				is_assignable<_T2&, _U2&&>>::value,
                			 pair&>::type
                	operator=(pair<_U1, _U2>&& __p)
                	{
                	  first = std::forward<_U1>(__p.first);
                	  second = std::forward<_U2>(__p.second);
                	  return *this;
                	}
                
                      void
                      swap(pair& __p)
                      noexcept(__and_<__is_nothrow_swappable<_T1>,
                                      __is_nothrow_swappable<_T2>>::value)
                      {
                	using std::swap;
                	swap(first, __p.first);
                	swap(second, __p.second);
                      }
                
                    private:
                      template<typename... _Args1, std::size_t... _Indexes1,
                               typename... _Args2, std::size_t... _Indexes2>
                        pair(tuple<_Args1...>&, tuple<_Args2...>&,
                             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
                #endif
                    };
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
                #endif
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                
                #if __cplusplus >= 201103L
                  /// See std::pair::swap().
                  // Note:  no std::swap overloads in C++03 mode, this has performance
                  //        implications, see, eg, libstdc++/38466.
                  template<typename _T1, typename _T2>
                    inline
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                    // Constrained free swap overload, see p0185r1
                    typename enable_if<__and_<__is_swappable<_T1>,
                                              __is_swappable<_T2>>::value>::type
                #else
                    void
                #endif
                    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                  template<typename _T1, typename _T2>
                    typename enable_if<!__and_<__is_swappable<_T1>,
                			       __is_swappable<_T2>>::value>::type
                    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
                #endif
                #endif // __cplusplus >= 201103L
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  __x  The first object.
                   *  @param  __y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The standard requires that the objects be passed by reference-to-const,
                   *  but LWG issue #181 says they should be passed by const value.  We follow
                   *  the LWG by default.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                #if __cplusplus >= 201103L
                  // NB: DR 706.
                  template<typename _T1, typename _T2>
                    constexpr pair<typename __decay_and_strip<_T1>::__type,
                                   typename __decay_and_strip<_T2>::__type>
       ##### ->     make_pair(_T1&& __x, _T2&& __y)
                    {
                      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
                      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
                      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
                      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
                    }
                #else
                  template<typename _T1, typename _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                #endif
                
                  /// @}
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_PAIR_H */


Top 10 Lines:

     Line      Count

      341     922050

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   922050   Total number of line executions
461025.00   Average executions per line


*** File /usr/include/c++/9/bits/stl_iterator_base_types.h:
                // Types used in iterator implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_types.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility types,
                 *  such as iterator_traits and struct iterator.
                 */
                
                #ifndef _STL_ITERATOR_BASE_TYPES_H
                #define _STL_ITERATOR_BASE_TYPES_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>  // For __void_t, is_convertible
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @defgroup iterators Iterators
                   *  Abstractions for uniform iterating through various underlying types.
                  */
                  ///@{
                
                  /**
                   *  @defgroup iterator_tags Iterator Tags
                   *  These are empty types, used to distinguish different iterators.  The
                   *  distinction is not made by what they contain, but simply by what they
                   *  are.  Different underlying algorithms can then be used based on the
                   *  different operations supported by different iterator types.
                  */
                  ///@{
                  ///  Marking input iterators.
                  struct input_iterator_tag { };
                
                  ///  Marking output iterators.
                  struct output_iterator_tag { };
                
                  /// Forward iterators support a superset of input iterator operations.
                  struct forward_iterator_tag : public input_iterator_tag { };
                
                  /// Bidirectional iterators support a superset of forward iterator
                  /// operations.
                  struct bidirectional_iterator_tag : public forward_iterator_tag { };
                
                  /// Random-access iterators support a superset of bidirectional
                  /// iterator operations.
                  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
                  ///@}
                
                  /**
                   *  @brief  Common %iterator class.
                   *
                   *  This class does nothing but define nested typedefs.  %Iterator classes
                   *  can inherit from this class to save some work.  The typedefs are then
                   *  used in specializations and overloading.
                   *
                   *  In particular, there are no default implementations of requirements
                   *  such as @c operator++ and the like.  (How could there be?)
                  */
                  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
                           typename _Pointer = _Tp*, typename _Reference = _Tp&>
                    struct iterator
                    {
                      /// One of the @link iterator_tags tag types@endlink.
                      typedef _Category  iterator_category;
                      /// The type "pointed to" by the iterator.
                      typedef _Tp        value_type;
                      /// Distance between iterators is represented as this type.
                      typedef _Distance  difference_type;
                      /// This type represents a pointer-to-value_type.
                      typedef _Pointer   pointer;
                      /// This type represents a reference-to-value_type.
                      typedef _Reference reference;
                    };
                
                  /**
                   *  @brief  Traits class for iterators.
                   *
                   *  This class does nothing but define nested typedefs.  The general
                   *  version simply @a forwards the nested typedefs from the Iterator
                   *  argument.  Specialized versions for pointers and pointers-to-const
                   *  provide tighter, more correct semantics.
                  */
                #if __cplusplus >= 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14
                  template<typename _Iterator, typename = __void_t<>>
                    struct __iterator_traits { };
                
                  template<typename _Iterator>
                    struct __iterator_traits<_Iterator,
                			     __void_t<typename _Iterator::iterator_category,
                				      typename _Iterator::value_type,
                				      typename _Iterator::difference_type,
                				      typename _Iterator::pointer,
                				      typename _Iterator::reference>>
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                
                  template<typename _Iterator>
                    struct iterator_traits
                    : public __iterator_traits<_Iterator> { };
                #else
                  template<typename _Iterator>
                    struct iterator_traits
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif
                
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct iterator_traits<_Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef _Tp*                        pointer;
                      typedef _Tp&                        reference;
                    };
                
                  /// Partial specialization for const pointer types.
                  template<typename _Tp>
                    struct iterator_traits<const _Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef const _Tp*                  pointer;
                      typedef const _Tp&                  reference;
                    };
                
                  /**
                   *  This function is not a part of the C++ standard but is syntactic
                   *  sugar for internal library use only.
                  */
                  template<typename _Iter>
                    inline _GLIBCXX_CONSTEXPR
                    typename iterator_traits<_Iter>::iterator_category
        1801 ->     __iterator_category(const _Iter&)
                    { return typename iterator_traits<_Iter>::iterator_category(); }
                
                  ///@}
                
                #if __cplusplus < 201103L
                  // If _Iterator has a base returns it otherwise _Iterator is returned
                  // untouched
                  template<typename _Iterator, bool _HasBase>
                    struct _Iter_base
                    {
                      typedef _Iterator iterator_type;
                      static iterator_type _S_base(_Iterator __it)
                      { return __it; }
                    };
                
                  template<typename _Iterator>
                    struct _Iter_base<_Iterator, true>
                    {
                      typedef typename _Iterator::iterator_type iterator_type;
                      static iterator_type _S_base(_Iterator __it)
                      { return __it.base(); }
                    };
                #endif
                
                #if __cplusplus >= 201103L
                  template<typename _InIter>
                    using _RequireInputIter = typename
                      enable_if<is_convertible<typename
                		iterator_traits<_InIter>::iterator_category,
                			       input_iterator_tag>::value>::type;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_TYPES_H */
                


Top 10 Lines:

     Line      Count

      205       1801

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1801   Total number of line executions
  1801.00   Average executions per line


*** File /usr/include/c++/9/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                #if __cplusplus > 201402L
                #include <utility>
                #endif
                
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
           1 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, (void)++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
        1800 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
        1801 ->     uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::copy
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
                	  "result type must be constructible from value type of input range");
                
                      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
                      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
                      // Trivial types can have deleted assignment, so using std::copy
                      // would be ill-formed. Require assignability before using std::copy:
                      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
                #endif
                
                      return std::__uninitialized_copy<__is_trivial(_ValueType1)
                				       && __is_trivial(_ValueType2)
                				       && __assignable>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill
                      // would be ill-formed. Require assignability before using std::fill:
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
           1 ->         __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
           2 ->         __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { return std::fill_n(__first, __n, __x); }
                    };
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 1339. uninitialized_fill_n should return the end of its range
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
           3 ->     uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill
                      // would be ill-formed. Require assignability before using std::fill:
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, (void)++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
        1801 ->     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
       ##### ->     __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline _ForwardIterator
           3 ->     __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { return std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  std::fill(__first, __last, _ValueType());
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
           1 ->         __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
           1 ->         __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  typedef typename iterator_traits<_ForwardIterator>::value_type
                	    _ValueType;
                
                	  return std::fill_n(__first, __n, _ValueType());
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)
                				     && __assignable>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default constructed value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
           2 ->     __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      return __uninitialized_default_n_1<__is_trivial(_ValueType)
                				       && __assignable>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with std::distance(first, last) default
                  // constructed value_types(s), constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with n default constructed value_types(s),
                  // constructed with the allocator alloc.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
           2 ->     __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { return std::__uninitialized_default_n(__first, __n); }
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_1
                    {
                      template<typename _ForwardIterator>
                	static void
                	__uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{ return std::next(__first, __n); }
                    };
                
                  // __uninitialized_default_novalue
                  // Fills [first, last) with std::distance(first, last) default-initialized
                  // value_types(s).
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default_novalue(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_default_novalue_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with n default-initialized value_type(s).
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      return __uninitialized_default_novalue_n_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue_n(__first, __n);
                    }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return {__first, __cur};
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline pair<_RandomAccessIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    {
                      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
                      auto __first_res = std::next(__first, __n);
                      return {__first_res, __second_res};
                    }
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			      _ForwardIterator __result)
                    {
                      return
                	std::__uninitialized_copy_n_pair(__first, __n, __result,
                					 std::__iterator_category(__first));
                    }
                
                #endif
                
                #if __cplusplus >= 201703L
                # define __cpp_lib_raw_memory_algorithms 201606L
                
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_default_construct(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      __uninitialized_default_novalue(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_novalue_n(__first, __count);
                    }
                
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_value_construct(_ForwardIterator __first,
                				  _ForwardIterator __last)
                    {
                      return __uninitialized_default(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_n(__first, __count);
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_move(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      return std::uninitialized_copy
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_ITERATOR(__last), __result);
                    }
                
                  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    uninitialized_move_n(_InputIterator __first, _Size __count,
                			 _ForwardIterator __result)
                    {
                      auto __res = std::__uninitialized_copy_n_pair
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 __count, __result);
                      return {__res.first.base(), __res.second};
                    }
                #endif // C++17
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Up, typename _Allocator>
                    inline void
      524287 ->     __relocate_object_a(_Tp* __dest, _Up* __orig, _Allocator& __alloc)
                    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
                			 __dest, std::move(*__orig)))
                	     && noexcept(std::allocator_traits<_Allocator>::destroy(
                			    __alloc, std::__addressof(*__orig))))
                    {
                      typedef std::allocator_traits<_Allocator> __traits;
                      __traits::construct(__alloc, __dest, std::move(*__orig));
                      __traits::destroy(__alloc, std::__addressof(*__orig));
                    }
                
                  // This class may be specialized for specific types.
                  // Also known as is_trivially_relocatable.
                  template<typename _Tp, typename = void>
                    struct __is_bitwise_relocatable
                    : is_trivial<_Tp> { };
                
                  template <typename _Tp, typename _Up>
                    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
                    __relocate_a_1(_Tp* __first, _Tp* __last,
                		   _Tp* __result, allocator<_Up>&) noexcept
                    {
                      ptrdiff_t __count = __last - __first;
                      if (__count > 0)
                	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
                      return __result + __count;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
          40 ->     __relocate_a_1(_InputIterator __first, _InputIterator __last,
                		   _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
                					       std::addressof(*__first),
                					       __alloc)))
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                      static_assert(std::is_same<_ValueType, _ValueType2>::value,
                	  "relocation is only possible for values of the same type");
                      _ForwardIterator __cur = __result;
                      for (; __first != __last; ++__first, (void)++__cur)
                	std::__relocate_object_a(std::__addressof(*__cur),
                				 std::__addressof(*__first), __alloc);
                      return __cur;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
          40 ->     __relocate_a(_InputIterator __first, _InputIterator __last,
                		 _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
                				     std::__niter_base(__last),
                				     std::__niter_base(__result), __alloc)))
                    {
                      return __relocate_a_1(std::__niter_base(__first),
                			    std::__niter_base(__last),
                			    std::__niter_base(__result), __alloc);
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

      905     524287
      115       1801
      305       1801
       99       1800
      936         40
      958         40
      256          3
      382          3
      238          2
      592          2

Execution Summary:

       16   Executable lines in this file
       16   Lines executed
   100.00   Percent of the file executed

   529785   Total number of line executions
 33111.56   Average executions per line


*** File /usr/include/c++/9/ext/aligned_buffer.h:
                // Aligned memory buffer -*- C++ -*-
                
                // Copyright (C) 2013-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/aligned_buffer.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _ALIGNED_BUFFER_H
                #define _ALIGNED_BUFFER_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #else
                # include <bits/c++0x_warning.h>
                #endif
                
                namespace __gnu_cxx
                {
                  // A utility type containing a POD object that can hold an object of type
                  // _Tp initialized via placement new or allocator_traits::construct.
                  // Intended for use as a data member subobject, use __aligned_buffer for
                  // complete objects.
                  template<typename _Tp>
                    struct __aligned_membuf
                    {
                      // Target macro ADJUST_FIELD_ALIGN can produce different alignment for
                      // types when used as class members. __aligned_membuf is intended
                      // for use as a class member, so align the buffer as for a class member.
                      // Since GCC 8 we could just use alignof(_Tp) instead, but older
                      // versions of non-GNU compilers might still need this trick.
                      struct _Tp2 { _Tp _M_t; };
                
                      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
                
                      __aligned_membuf() = default;
                
                      // Can be used to avoid value-initialization zeroing _M_storage.
                      __aligned_membuf(std::nullptr_t) { }
                
                      void*
                      _M_addr() noexcept
                      { return static_cast<void*>(&_M_storage); }
                
                      const void*
                      _M_addr() const noexcept
                      { return static_cast<const void*>(&_M_storage); }
                
                      _Tp*
                      _M_ptr() noexcept
                      { return static_cast<_Tp*>(_M_addr()); }
                
                      const _Tp*
                      _M_ptr() const noexcept
                      { return static_cast<const _Tp*>(_M_addr()); }
                    };
                
                #if _GLIBCXX_INLINE_VERSION
                  template<typename _Tp>
                    using __aligned_buffer = __aligned_membuf<_Tp>;
                #else
                  // Similar to __aligned_membuf but aligned for complete objects, not members.
                  // This type is used in <forward_list>, <future>, <bits/shared_ptr_base.h>
                  // and <bits/hashtable_policy.h>, but ideally they would use __aligned_membuf
                  // instead, as it has smaller size for some types on some targets.
                  // This type is still used to avoid an ABI change.
                  template<typename _Tp>
                    struct __aligned_buffer
                    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
                    {
                      typename
                	std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
                
                      __aligned_buffer() = default;
                
                      // Can be used to avoid value-initialization
                      __aligned_buffer(std::nullptr_t) { }
                
                      void*
     2003572 ->       _M_addr() noexcept
                      {
                        return static_cast<void*>(&_M_storage);
                      }
                
                      const void*
     1540529 ->       _M_addr() const noexcept
                      {
                        return static_cast<const void*>(&_M_storage);
                      }
                
                      _Tp*
     2003572 ->       _M_ptr() noexcept
                      { return static_cast<_Tp*>(_M_addr()); }
                
                      const _Tp*
     1540529 ->       _M_ptr() const noexcept
                      { return static_cast<const _Tp*>(_M_addr()); }
                    };
                #endif
                
                } // namespace
                
                #endif /* _ALIGNED_BUFFER_H */


Top 10 Lines:

     Line      Count

      102    2003572
      114    2003572
      108    1540529
      118    1540529

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

  7088202   Total number of line executions
1772050.50   Average executions per line


*** File /usr/include/c++/9/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _STL_ITERATOR_H
                #define _STL_ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <bits/move.h>
                #include <bits/ptr_traits.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                
                #if __cplusplus >= 201703L
                # define __cpp_lib_array_constexpr 201803L
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.1 Reverse iterators
                  /**
                   *  Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  <em>This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array.</em> [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                    protected:
                      _Iterator current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      typedef typename __traits_type::pointer		pointer;
                      typedef typename __traits_type::reference		reference;
                
                      /**
                       *  The default constructor value-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      // 1012. reverse_iterator default ctor should value initialize
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit _GLIBCXX17_CONSTEXPR
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                #if __cplusplus >= 201103L
                      reverse_iterator& operator=(const reverse_iterator&) = default;
                #endif
                
                      /**
                       *  A %reverse_iterator across other types can be copied if the
                       *  underlying %iterator can be converted to the type of @c current.
                      */
                      template<typename _Iter>
                	_GLIBCXX17_CONSTEXPR
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.base()) { }
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      _GLIBCXX17_CONSTEXPR iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  A reference to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                       *
                       *  @warning This implementation requires that for an iterator of the
                       *           underlying iterator type, @c x, a reference obtained by
                       *           @c *x remains valid after @c x has been modified or
                       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  A pointer to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                      */
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 1052. operator-> should also support smart pointers
                	_Iterator __tmp = current;
                	--__tmp;
                	return _S_to_pointer(__tmp);
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  The original value of @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator with the previous value of @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator backwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator forwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  The value at @c current - @a __n - 1
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                
                    private:
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR _Tp*
                	_S_to_pointer(_Tp* __p)
                        { return __p; }
                
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR pointer
                	_S_to_pointer(_Tp __t)
                        { return __t.operator->(); }
                    };
                
                  ///@{
                  /**
                   *  @param  __x  A %reverse_iterator.
                   *  @param  __y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward many operations to their underlying base()
                   *  iterators.  Others are implemented in terms of one another.
                   *
                  */
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                  ///@}
                
                #if __cplusplus < 201103L
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() - __x.base(); }
                #else
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 685. reverse_iterator/move_iterator difference has invalid signatures
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    -> decltype(__y.base() - __x.base())
                    { return __y.base() - __x.base(); }
                #endif
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                #if __cplusplus >= 201103L
                  // Same as C++14 make_reverse_iterator but used in C++11 mode too.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    __make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                
                # if __cplusplus > 201103L
                #  define __cpp_lib_make_reverse_iterator 201402
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 2285. make_reverse_iterator
                  /// Generator function for reverse_iterator.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                # endif
                #endif
                
                #if __cplusplus >= 201103L
                  template<typename _Iterator>
                    auto
                    __niter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
                    { return __make_reverse_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<reverse_iterator<_Iterator> >
                      : __is_move_iterator<_Iterator>
                    { };
                
                  template<typename _Iterator>
                    auto
                    __miter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
                    { return __make_reverse_iterator(__miter_base(__it.base())); }
                #endif
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit
                      back_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                #if __cplusplus < 201103L
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                #else
                      back_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      back_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_back(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /// The only way to create this %iterator is with a container.
                      explicit front_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                #if __cplusplus < 201103L
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                #else
                      front_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      front_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_front(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                      typename _Container::iterator iter;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      insert_iterator(_Container& __x, typename _Container::iterator __i)
                      : container(std::__addressof(__x)), iter(__i) {}
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                #if __cplusplus < 201103L
                      insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                #else
                      insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	iter = container->insert(iter, std::move(__value));
                	++iter;
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param __x  A container of arbitrary type.
                   *  @param __i  An iterator into the container.
                   *  @return  An instance of insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, typename _Container::iterator __i)
                    { return insert_iterator<_Container>(__x, __i); }
                
                  /// @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // This iterator adapter is @a normal in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  using std::iterator_traits;
                  using std::iterator;
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type 	difference_type;
                      typedef typename __traits_type::reference 	reference;
                      typedef typename __traits_type::pointer   	pointer;
                
                      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
                      : _M_current(_Iterator()) { }
                
                      explicit
       10329 ->       __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
                      : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        __normal_iterator(const __normal_iterator<_Iter,
                			  typename __enable_if<
                      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      reference
     1253258 ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *_M_current; }
                
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                
                      __normal_iterator&
     1235662 ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	++_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator++(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      __normal_iterator&
        6598 ->       operator--() _GLIBCXX_NOEXCEPT
                      {
                	--_M_current;
                	return *this;
                      }
                
                      __normal_iterator
                      operator--(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      reference
                      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return _M_current[__n]; }
                
                      __normal_iterator&
                      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current += __n; return *this; }
                
                      __normal_iterator
        1187 ->       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current + __n); }
                
                      __normal_iterator&
                      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current -= __n; return *this; }
                
                      __normal_iterator
          94 ->       operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current - __n); }
                
                      const _Iterator&
     2475916 ->       base() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                  // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
           1 ->     operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
     1234805 ->     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
         125 ->     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                #if __cplusplus >= 201103L
                    // DR 685.
                    inline auto
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
                    -> decltype(__lhs.base() - __rhs.base())
                #else
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                #endif
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline typename __normal_iterator<_Iterator, _Container>::difference_type
         305 ->     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    _GLIBCXX_NOEXCEPT
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Iterator, typename _Container>
                    _Iterator
        5404 ->     __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it.base(); }
                
                #if __cplusplus >= 201103L
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                  // 24.4.3  Move iterators
                  /**
                   *  Class template move_iterator is an iterator adapter with the same
                   *  behavior as the underlying iterator except that its dereference
                   *  operator implicitly converts the value returned by the underlying
                   *  iterator's dereference operator to an rvalue reference.  Some
                   *  generic algorithms can be called with move iterators to replace
                   *  copying with moving.
                   */
                  template<typename _Iterator>
                    class move_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                      typedef typename __traits_type::reference		__base_ref;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      // NB: DR 680.
                      typedef _Iterator					pointer;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2106. move_iterator wrapping iterators returning prvalues
                      typedef typename conditional<is_reference<__base_ref>::value,
                			 typename remove_reference<__base_ref>::type&&,
                			 __base_ref>::type		reference;
                
                      _GLIBCXX17_CONSTEXPR
                      move_iterator()
                      : _M_current() { }
                
                      explicit _GLIBCXX17_CONSTEXPR
       ##### ->       move_iterator(iterator_type __i)
                      : _M_current(__i) { }
                
                      template<typename _Iter>
                	_GLIBCXX17_CONSTEXPR
                	move_iterator(const move_iterator<_Iter>& __i)
                	: _M_current(__i.base()) { }
                
                      _GLIBCXX17_CONSTEXPR iterator_type
       ##### ->       base() const
                      { return _M_current; }
                
                      _GLIBCXX17_CONSTEXPR reference
       ##### ->       operator*() const
                      { return static_cast<reference>(*_M_current); }
                
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                      { return _M_current; }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
       ##### ->       operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator++(int)
                      {
                	move_iterator __tmp = *this;
                	++_M_current;
                	return __tmp;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator--(int)
                      {
                	move_iterator __tmp = *this;
                	--_M_current;
                	return __tmp;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator+(difference_type __n) const
                      { return move_iterator(_M_current + __n); }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator+=(difference_type __n)
                      {
                	_M_current += __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator-(difference_type __n) const
                      { return move_iterator(_M_current - __n); }
                    
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator-=(difference_type __n)
                      { 
                	_M_current -= __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                      { return std::move(_M_current[__n]); }
                    };
                
                  // Note: See __normal_iterator operators note from Gaby to understand
                  // why there are always 2 versions for most of the move_iterator
                  // operators.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
       ##### ->     operator==(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
       ##### ->     operator!=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x < __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // DR 685.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    operator+(typename move_iterator<_Iterator>::difference_type __n,
                	      const move_iterator<_Iterator>& __x)
                    { return __x + __n; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    make_move_iterator(_Iterator __i)
                    { return move_iterator<_Iterator>(__i); }
                
                  template<typename _Iterator, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond
                      <typename iterator_traits<_Iterator>::value_type>::value,
                                _Iterator, move_iterator<_Iterator>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
                    __make_move_if_noexcept_iterator(_Iterator __i)
                    { return _ReturnType(__i); }
                
                  // Overload for pointers that matches std::move_if_noexcept more closely,
                  // returning a constant iterator when we don't want to move.
                  template<typename _Tp, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
                			   const _Tp*, move_iterator<_Tp*>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
       ##### ->     __make_move_if_noexcept_iterator(_Tp* __i)
                    { return _ReturnType(__i); }
                
                  /// @} group iterators
                
                  template<typename _Iterator>
                    auto
                    __niter_base(move_iterator<_Iterator> __it)
                    -> decltype(make_move_iterator(__niter_base(__it.base())))
                    { return make_move_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<move_iterator<_Iterator> >
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<typename _Iterator>
                    auto
                    __miter_base(move_iterator<_Iterator> __it)
                    -> decltype(__miter_base(__it.base()))
                    { return __miter_base(__it.base()); }
                
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                  std::__make_move_if_noexcept_iterator(_Iter)
                #else
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                #endif // C++11
                
                #if __cpp_deduction_guides >= 201606
                  // These helper traits are used for deduction guides
                  // of associative containers.
                  template<typename _InputIterator>
                    using __iter_key_t = remove_const_t<
                    typename iterator_traits<_InputIterator>::value_type::first_type>;
                
                  template<typename _InputIterator>
                    using __iter_val_t =
                    typename iterator_traits<_InputIterator>::value_type::second_type;
                
                  template<typename _T1, typename _T2>
                    struct pair;
                
                  template<typename _InputIterator>
                    using __iter_to_alloc_t =
                    pair<add_const_t<__iter_key_t<_InputIterator>>,
                	 __iter_val_t<_InputIterator>>;
                
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #ifdef _GLIBCXX_DEBUG
                # include <debug/stl_iterator.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      868    2475916
      816    1253258
      824    1235662
      904    1234805
      803      10329
      836       6598
     1007       5404
      856       1187
      986        305
      919        125

Execution Summary:

       19   Executable lines in this file
       19   Lines executed
   100.00   Percent of the file executed

  6223684   Total number of line executions
327562.32   Average executions per line


*** File /usr/include/c++/9/bits/hashtable_policy.h:
                // Internal policy header for unordered_set and unordered_map -*- C++ -*-
                
                // Copyright (C) 2010-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/hashtable_policy.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly.
                 *  @headername{unordered_map,unordered_set}
                 */
                
                #ifndef _HASHTABLE_POLICY_H
                #define _HASHTABLE_POLICY_H 1
                
                #include <tuple>		// for std::tuple, std::forward_as_tuple
                #include <limits>		// for std::numeric_limits
                #include <bits/stl_algobase.h>	// for std::min.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    class _Hashtable;
                
                namespace __detail
                {
                  /**
                   *  @defgroup hashtable-detail Base and Implementation Classes
                   *  @ingroup unordered_associative_containers
                   *  @{
                   */
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _Traits>
                    struct _Hashtable_base;
                
                  // Helper function: return distance(first, last) for forward
                  // iterators, or 0/1 for input iterators.
                  template<class _Iterator>
                    inline typename std::iterator_traits<_Iterator>::difference_type
                    __distance_fw(_Iterator __first, _Iterator __last,
                		  std::input_iterator_tag)
                    { return __first != __last ? 1 : 0; }
                
                  template<class _Iterator>
                    inline typename std::iterator_traits<_Iterator>::difference_type
                    __distance_fw(_Iterator __first, _Iterator __last,
                		  std::forward_iterator_tag)
                    { return std::distance(__first, __last); }
                
                  template<class _Iterator>
                    inline typename std::iterator_traits<_Iterator>::difference_type
                    __distance_fw(_Iterator __first, _Iterator __last)
                    { return __distance_fw(__first, __last,
                			   std::__iterator_category(__first)); }
                
                  struct _Identity
                  {
                    template<typename _Tp>
                      _Tp&&
     2314701 ->       operator()(_Tp&& __x) const
                      { return std::forward<_Tp>(__x); }
                  };
                
                  struct _Select1st
                  {
                    template<typename _Tp>
                      auto
                      operator()(_Tp&& __x) const
                      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
                      { return std::get<0>(std::forward<_Tp>(__x)); }
                  };
                
                  template<typename _NodeAlloc>
                    struct _Hashtable_alloc;
                
                  // Functor recycling a pool of nodes and using allocation once the pool is
                  // empty.
                  template<typename _NodeAlloc>
                    struct _ReuseOrAllocNode
                    {
                    private:
                      using __node_alloc_type = _NodeAlloc;
                      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
                      using __node_alloc_traits =
                	typename __hashtable_alloc::__node_alloc_traits;
                      using __node_type = typename __hashtable_alloc::__node_type;
                
                    public:
                      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
                	: _M_nodes(__nodes), _M_h(__h) { }
                      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;
                
                      ~_ReuseOrAllocNode()
                      { _M_h._M_deallocate_nodes(_M_nodes); }
                
                      template<typename _Arg>
                	__node_type*
                	operator()(_Arg&& __arg) const
                	{
                	  if (_M_nodes)
                	    {
                	      __node_type* __node = _M_nodes;
                	      _M_nodes = _M_nodes->_M_next();
                	      __node->_M_nxt = nullptr;
                	      auto& __a = _M_h._M_node_allocator();
                	      __node_alloc_traits::destroy(__a, __node->_M_valptr());
                	      __try
                		{
                		  __node_alloc_traits::construct(__a, __node->_M_valptr(),
                						 std::forward<_Arg>(__arg));
                		}
                	      __catch(...)
                		{
                		  _M_h._M_deallocate_node_ptr(__node);
                		  __throw_exception_again;
                		}
                	      return __node;
                	    }
                	  return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
                	}
                
                    private:
                      mutable __node_type* _M_nodes;
                      __hashtable_alloc& _M_h;
                    };
                
                  // Functor similar to the previous one but without any pool of nodes to
                  // recycle.
                  template<typename _NodeAlloc>
                    struct _AllocNode
                    {
                    private:
                      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
                      using __node_type = typename __hashtable_alloc::__node_type;
                
                    public:
      614700 ->       _AllocNode(__hashtable_alloc& __h)
                	: _M_h(__h) { }
                
                      template<typename _Arg>
                	__node_type*
      614700 -> 	operator()(_Arg&& __arg) const
                	{ return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }
                
                    private:
                      __hashtable_alloc& _M_h;
                    };
                
                  // Auxiliary types used for all instantiations of _Hashtable nodes
                  // and iterators.
                
                  /**
                   *  struct _Hashtable_traits
                   *
                   *  Important traits for hash tables.
                   *
                   *  @tparam _Cache_hash_code  Boolean value. True if the value of
                   *  the hash function is stored along with the value. This is a
                   *  time-space tradeoff.  Storing it may improve lookup speed by
                   *  reducing the number of times we need to call the _Equal
                   *  function.
                   *
                   *  @tparam _Constant_iterators  Boolean value. True if iterator and
                   *  const_iterator are both constant iterator types. This is true
                   *  for unordered_set and unordered_multiset, false for
                   *  unordered_map and unordered_multimap.
                   *
                   *  @tparam _Unique_keys  Boolean value. True if the return value
                   *  of _Hashtable::count(k) is always at most one, false if it may
                   *  be an arbitrary number. This is true for unordered_set and
                   *  unordered_map, false for unordered_multiset and
                   *  unordered_multimap.
                   */
                  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
                    struct _Hashtable_traits
                    {
                      using __hash_cached = __bool_constant<_Cache_hash_code>;
                      using __constant_iterators = __bool_constant<_Constant_iterators>;
                      using __unique_keys = __bool_constant<_Unique_keys>;
                    };
                
                  /**
                   *  struct _Hash_node_base
                   *
                   *  Nodes, used to wrap elements stored in the hash table.  A policy
                   *  template parameter of class template _Hashtable controls whether
                   *  nodes also store a hash code. In some cases (e.g. strings) this
                   *  may be a performance win.
                   */
                  struct _Hash_node_base
                  {
                    _Hash_node_base* _M_nxt;
                
      615600 ->     _Hash_node_base() noexcept : _M_nxt() { }
                
                    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
                  };
                
                  /**
                   *  struct _Hash_node_value_base
                   *
                   *  Node type with the value to store.
                   */
                  template<typename _Value>
      614700 ->     struct _Hash_node_value_base : _Hash_node_base
                    {
                      typedef _Value value_type;
                
                      __gnu_cxx::__aligned_buffer<_Value> _M_storage;
                
                      _Value*
     2003572 ->       _M_valptr() noexcept
                      { return _M_storage._M_ptr(); }
                
                      const _Value*
     1540529 ->       _M_valptr() const noexcept
                      { return _M_storage._M_ptr(); }
                
                      _Value&
      774172 ->       _M_v() noexcept
                      { return *_M_valptr(); }
                
                      const _Value&
     1540529 ->       _M_v() const noexcept
                      { return *_M_valptr(); }
                    };
                
                  /**
                   *  Primary template struct _Hash_node.
                   */
                  template<typename _Value, bool _Cache_hash_code>
                    struct _Hash_node;
                
                  /**
                   *  Specialization for nodes with caches, struct _Hash_node.
                   *
                   *  Base class is __detail::_Hash_node_value_base.
                   */
                  template<typename _Value>
                    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
                    {
                      std::size_t  _M_hash_code;
                
                      _Hash_node*
                      _M_next() const noexcept
                      { return static_cast<_Hash_node*>(this->_M_nxt); }
                    };
                
                  /**
                   *  Specialization for nodes without caches, struct _Hash_node.
                   *
                   *  Base class is __detail::_Hash_node_value_base.
                   */
                  template<typename _Value>
      614700 ->     struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
                    {
                      _Hash_node*
     3384973 ->       _M_next() const noexcept
                      { return static_cast<_Hash_node*>(this->_M_nxt); }
                    };
                
                  /// Base class for node iterators.
                  template<typename _Value, bool _Cache_hash_code>
                    struct _Node_iterator_base
                    {
                      using __node_type = _Hash_node<_Value, _Cache_hash_code>;
                
                      __node_type*  _M_cur;
                
      616500 ->       _Node_iterator_base(__node_type* __p) noexcept
                      : _M_cur(__p) { }
                
                      void
     1229400 ->       _M_incr() noexcept
                      { _M_cur = _M_cur->_M_next(); }
                    };
                
                  template<typename _Value, bool _Cache_hash_code>
                    inline bool
                    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
                	       const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
                    noexcept
                    { return __x._M_cur == __y._M_cur; }
                
                  template<typename _Value, bool _Cache_hash_code>
                    inline bool
     1231200 ->     operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
                	       const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
                    noexcept
                    { return __x._M_cur != __y._M_cur; }
                
                  /// Node iterators, used to iterate through all the hashtable.
                  template<typename _Value, bool __constant_iterators, bool __cache>
                    struct _Node_iterator
                    : public _Node_iterator_base<_Value, __cache>
                    {
                    private:
                      using __base_type = _Node_iterator_base<_Value, __cache>;
                      using __node_type = typename __base_type::__node_type;
                
                    public:
                      typedef _Value					value_type;
                      typedef std::ptrdiff_t				difference_type;
                      typedef std::forward_iterator_tag			iterator_category;
                
                      using pointer = typename std::conditional<__constant_iterators,
                						const _Value*, _Value*>::type;
                
                      using reference = typename std::conditional<__constant_iterators,
                						  const _Value&, _Value&>::type;
                
                      _Node_iterator() noexcept
                      : __base_type(0) { }
                
                      explicit
      616500 ->       _Node_iterator(__node_type* __p) noexcept
                      : __base_type(__p) { }
                
                      reference
      614700 ->       operator*() const noexcept
                      { return this->_M_cur->_M_v(); }
                
                      pointer
                      operator->() const noexcept
                      { return this->_M_cur->_M_valptr(); }
                
                      _Node_iterator&
     1229400 ->       operator++() noexcept
                      {
                	this->_M_incr();
                	return *this;
                      }
                
                      _Node_iterator
                      operator++(int) noexcept
                      {
                	_Node_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  /// Node const_iterators, used to iterate through all the hashtable.
                  template<typename _Value, bool __constant_iterators, bool __cache>
                    struct _Node_const_iterator
                    : public _Node_iterator_base<_Value, __cache>
                    {
                    private:
                      using __base_type = _Node_iterator_base<_Value, __cache>;
                      using __node_type = typename __base_type::__node_type;
                
                    public:
                      typedef _Value					value_type;
                      typedef std::ptrdiff_t				difference_type;
                      typedef std::forward_iterator_tag			iterator_category;
                
                      typedef const _Value*				pointer;
                      typedef const _Value&				reference;
                
                      _Node_const_iterator() noexcept
                      : __base_type(0) { }
                
                      explicit
                      _Node_const_iterator(__node_type* __p) noexcept
                      : __base_type(__p) { }
                
                      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
                			   __cache>& __x) noexcept
                      : __base_type(__x._M_cur) { }
                
                      reference
                      operator*() const noexcept
                      { return this->_M_cur->_M_v(); }
                
                      pointer
                      operator->() const noexcept
                      { return this->_M_cur->_M_valptr(); }
                
                      _Node_const_iterator&
                      operator++() noexcept
                      {
                	this->_M_incr();
                	return *this;
                      }
                
                      _Node_const_iterator
                      operator++(int) noexcept
                      {
                	_Node_const_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  // Many of class template _Hashtable's template parameters are policy
                  // classes.  These are defaults for the policies.
                
                  /// Default range hashing function: use division to fold a large number
                  /// into the range [0, N).
                  struct _Mod_range_hashing
                  {
                    typedef std::size_t first_argument_type;
                    typedef std::size_t second_argument_type;
                    typedef std::size_t result_type;
                
                    result_type
     2161529 ->     operator()(first_argument_type __num,
                	       second_argument_type __den) const noexcept
                    { return __num % __den; }
                  };
                
                  /// Default ranged hash function H.  In principle it should be a
                  /// function object composed from objects of type H1 and H2 such that
                  /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
                  /// h1 and h2.  So instead we'll just use a tag to tell class template
                  /// hashtable to do that composition.
                  struct _Default_ranged_hash { };
                
                  /// Default value for rehash policy.  Bucket size is (usually) the
                  /// smallest prime that keeps the load factor small enough.
                  struct _Prime_rehash_policy
                  {
                    using __has_load_factor = std::true_type;
                
         900 ->     _Prime_rehash_policy(float __z = 1.0) noexcept
                    : _M_max_load_factor(__z), _M_next_resize(0) { }
                
                    float
                    max_load_factor() const noexcept
                    { return _M_max_load_factor; }
                
                    // Return a bucket size no smaller than n.
                    std::size_t
                    _M_next_bkt(std::size_t __n) const;
                
                    // Return a bucket count appropriate for n elements
                    std::size_t
                    _M_bkt_for_elements(std::size_t __n) const
                    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }
                
                    // __n_bkt is current bucket count, __n_elt is current element count,
                    // and __n_ins is number of elements to be inserted.  Do we need to
                    // increase bucket count?  If so, return make_pair(true, n), where n
                    // is the new bucket count.  If not, return make_pair(false, 0).
                    std::pair<bool, std::size_t>
                    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
                		   std::size_t __n_ins) const;
                
                    typedef std::size_t _State;
                
                    _State
      614700 ->     _M_state() const
                    { return _M_next_resize; }
                
                    void
                    _M_reset() noexcept
                    { _M_next_resize = 0; }
                
                    void
       ##### ->     _M_reset(_State __state)
                    { _M_next_resize = __state; }
                
                    static const std::size_t _S_growth_factor = 2;
                
                    float		_M_max_load_factor;
                    mutable std::size_t	_M_next_resize;
                  };
                
                  /// Range hashing function assuming that second arg is a power of 2.
                  struct _Mask_range_hashing
                  {
                    typedef std::size_t first_argument_type;
                    typedef std::size_t second_argument_type;
                    typedef std::size_t result_type;
                
                    result_type
                    operator()(first_argument_type __num,
                	       second_argument_type __den) const noexcept
                    { return __num & (__den - 1); }
                  };
                
                  /// Compute closest power of 2 not less than __n
                  inline std::size_t
                  __clp2(std::size_t __n) noexcept
                  {
                    // Equivalent to return __n ? std::ceil2(__n) : 0;
                    if (__n < 2)
                      return __n;
                    const unsigned __lz = sizeof(size_t) > sizeof(long)
                      ? __builtin_clzll(__n - 1ull)
                      : __builtin_clzl(__n - 1ul);
                    // Doing two shifts avoids undefined behaviour when __lz == 0.
                    return (size_t(1) << (numeric_limits<size_t>::digits - __lz - 1)) << 1;
                  }
                
                  /// Rehash policy providing power of 2 bucket numbers. Avoids modulo
                  /// operations.
                  struct _Power2_rehash_policy
                  {
                    using __has_load_factor = std::true_type;
                
                    _Power2_rehash_policy(float __z = 1.0) noexcept
                    : _M_max_load_factor(__z), _M_next_resize(0) { }
                
                    float
                    max_load_factor() const noexcept
                    { return _M_max_load_factor; }
                
                    // Return a bucket size no smaller than n (as long as n is not above the
                    // highest power of 2).
                    std::size_t
                    _M_next_bkt(std::size_t __n) noexcept
                    {
                      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
                      const auto __max_bkt = size_t(1) << (__max_width * __CHAR_BIT__ - 1);
                      std::size_t __res = __clp2(__n);
                
                      if (__res == __n)
                	__res <<= 1;
                
                      if (__res == 0)
                	__res = __max_bkt;
                
                      if (__res == __max_bkt)
                	// Set next resize to the max value so that we never try to rehash again
                	// as we already reach the biggest possible bucket number.
                	// Note that it might result in max_load_factor not being respected.
                	_M_next_resize = std::size_t(-1);
                      else
                	_M_next_resize
                	  = __builtin_ceil(__res * (long double)_M_max_load_factor);
                
                      return __res;
                    }
                
                    // Return a bucket count appropriate for n elements
                    std::size_t
                    _M_bkt_for_elements(std::size_t __n) const noexcept
                    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }
                
                    // __n_bkt is current bucket count, __n_elt is current element count,
                    // and __n_ins is number of elements to be inserted.  Do we need to
                    // increase bucket count?  If so, return make_pair(true, n), where n
                    // is the new bucket count.  If not, return make_pair(false, 0).
                    std::pair<bool, std::size_t>
                    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
                		   std::size_t __n_ins) noexcept
                    {
                      if (__n_elt + __n_ins >= _M_next_resize)
                	{
                	  long double __min_bkts = (__n_elt + __n_ins)
                					/ (long double)_M_max_load_factor;
                	  if (__min_bkts >= __n_bkt)
                	    return std::make_pair(true,
                	      _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,
                						__n_bkt * _S_growth_factor)));
                
                	  _M_next_resize
                	    = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);
                	  return std::make_pair(false, 0);
                	}
                      else
                	return std::make_pair(false, 0);
                    }
                
                    typedef std::size_t _State;
                
                    _State
                    _M_state() const noexcept
                    { return _M_next_resize; }
                
                    void
                    _M_reset() noexcept
                    { _M_next_resize = 0; }
                
                    void
                    _M_reset(_State __state) noexcept
                    { _M_next_resize = __state; }
                
                    static const std::size_t _S_growth_factor = 2;
                
                    float	_M_max_load_factor;
                    std::size_t	_M_next_resize;
                  };
                
                  // Base classes for std::_Hashtable.  We define these base classes
                  // because in some cases we want to do different things depending on
                  // the value of a policy class.  In some cases the policy class
                  // affects which member functions and nested typedefs are defined;
                  // we handle that by specializing base class templates.  Several of
                  // the base class templates need to access other members of class
                  // template _Hashtable, so we use a variant of the "Curiously
                  // Recurring Template Pattern" (CRTP) technique.
                
                  /**
                   *  Primary class template _Map_base.
                   *
                   *  If the hashtable has a value type of the form pair<T1, T2> and a
                   *  key extraction policy (_ExtractKey) that returns the first part
                   *  of the pair, the hashtable gets a mapped_type typedef.  If it
                   *  satisfies those criteria and also has unique keys, then it also
                   *  gets an operator[].
                   */
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits,
                	   bool _Unique_keys = _Traits::__unique_keys::value>
                    struct _Map_base { };
                
                  /// Partial specialization, __unique_keys set to false.
                  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                		     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
                    {
                      using mapped_type = typename std::tuple_element<1, _Pair>::type;
                    };
                
                  /// Partial specialization, __unique_keys set to true.
                  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                		     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                    {
                    private:
                      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
                							 _Select1st,
                							_Equal, _H1, _H2, _Hash,
                							  _Traits>;
                
                      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
                				     _Select1st, _Equal,
                				     _H1, _H2, _Hash, _RehashPolicy, _Traits>;
                
                      using __hash_code = typename __hashtable_base::__hash_code;
                      using __node_type = typename __hashtable_base::__node_type;
                
                    public:
                      using key_type = typename __hashtable_base::key_type;
                      using iterator = typename __hashtable_base::iterator;
                      using mapped_type = typename std::tuple_element<1, _Pair>::type;
                
                      mapped_type&
                      operator[](const key_type& __k);
                
                      mapped_type&
                      operator[](key_type&& __k);
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 761. unordered_map needs an at() member function.
                      mapped_type&
                      at(const key_type& __k);
                
                      const mapped_type&
                      at(const key_type& __k) const;
                    };
                
                  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    auto
                    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                    operator[](const key_type& __k)
                    -> mapped_type&
                    {
                      __hashtable* __h = static_cast<__hashtable*>(this);
                      __hash_code __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code);
                      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                
                      if (!__p)
                	{
                	  __p = __h->_M_allocate_node(std::piecewise_construct,
                				      std::tuple<const key_type&>(__k),
                				      std::tuple<>());
                	  return __h->_M_insert_unique_node(__n, __code, __p)->second;
                	}
                
                      return __p->_M_v().second;
                    }
                
                  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    auto
                    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                    operator[](key_type&& __k)
                    -> mapped_type&
                    {
                      __hashtable* __h = static_cast<__hashtable*>(this);
                      __hash_code __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code);
                      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                
                      if (!__p)
                	{
                	  __p = __h->_M_allocate_node(std::piecewise_construct,
                				      std::forward_as_tuple(std::move(__k)),
                				      std::tuple<>());
                	  return __h->_M_insert_unique_node(__n, __code, __p)->second;
                	}
                
                      return __p->_M_v().second;
                    }
                
                  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    auto
                    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                    at(const key_type& __k)
                    -> mapped_type&
                    {
                      __hashtable* __h = static_cast<__hashtable*>(this);
                      __hash_code __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code);
                      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                
                      if (!__p)
                	__throw_out_of_range(__N("_Map_base::at"));
                      return __p->_M_v().second;
                    }
                
                  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    auto
                    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                    at(const key_type& __k) const
                    -> const mapped_type&
                    {
                      const __hashtable* __h = static_cast<const __hashtable*>(this);
                      __hash_code __code = __h->_M_hash_code(__k);
                      std::size_t __n = __h->_M_bucket_index(__k, __code);
                      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                
                      if (!__p)
                	__throw_out_of_range(__N("_Map_base::at"));
                      return __p->_M_v().second;
                    }
                
                  /**
                   *  Primary class template _Insert_base.
                   *
                   *  Defines @c insert member functions appropriate to all _Hashtables.
                   */
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Insert_base
                    {
                    protected:
                      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                				     _Equal, _H1, _H2, _Hash,
                				     _RehashPolicy, _Traits>;
                
                      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
                					       _Equal, _H1, _H2, _Hash,
                					       _Traits>;
                
                      using value_type = typename __hashtable_base::value_type;
                      using iterator = typename __hashtable_base::iterator;
                      using const_iterator =  typename __hashtable_base::const_iterator;
                      using size_type = typename __hashtable_base::size_type;
                
                      using __unique_keys = typename __hashtable_base::__unique_keys;
                      using __ireturn_type = typename __hashtable_base::__ireturn_type;
                      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
                      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
                      using __node_gen_type = _AllocNode<__node_alloc_type>;
                
                      __hashtable&
      614700 ->       _M_conjure_hashtable()
                      { return *(static_cast<__hashtable*>(this)); }
                
                      template<typename _InputIterator, typename _NodeGetter>
                	void
                	_M_insert_range(_InputIterator __first, _InputIterator __last,
                			const _NodeGetter&, true_type);
                
                      template<typename _InputIterator, typename _NodeGetter>
                	void
                	_M_insert_range(_InputIterator __first, _InputIterator __last,
                			const _NodeGetter&, false_type);
                
                    public:
                      __ireturn_type
      614700 ->       insert(const value_type& __v)
                      {
                	__hashtable& __h = _M_conjure_hashtable();
                	__node_gen_type __node_gen(__h);
                	return __h._M_insert(__v, __node_gen, __unique_keys());
                      }
                
                      iterator
                      insert(const_iterator __hint, const value_type& __v)
                      {
                	__hashtable& __h = _M_conjure_hashtable();
                	__node_gen_type __node_gen(__h);	
                	return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
                      }
                
                      void
                      insert(initializer_list<value_type> __l)
                      { this->insert(__l.begin(), __l.end()); }
                
                      template<typename _InputIterator>
                	void
                	insert(_InputIterator __first, _InputIterator __last)
                	{
                	  __hashtable& __h = _M_conjure_hashtable();
                	  __node_gen_type __node_gen(__h);
                	  return _M_insert_range(__first, __last, __node_gen, __unique_keys());
                	}
                    };
                
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    template<typename _InputIterator, typename _NodeGetter>
                      void
                      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                		    _RehashPolicy, _Traits>::
                      _M_insert_range(_InputIterator __first, _InputIterator __last,
                		      const _NodeGetter& __node_gen, true_type)
                      {
                	size_type __n_elt = __detail::__distance_fw(__first, __last);
                	if (__n_elt == 0)
                	  return;
                
                	__hashtable& __h = _M_conjure_hashtable();
                	for (; __first != __last; ++__first)
                	  {
                	    if (__h._M_insert(*__first, __node_gen, __unique_keys(),
                			      __n_elt).second)
                	      __n_elt = 1;
                	    else if (__n_elt != 1)
                	      --__n_elt;
                	  }
                      }
                
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    template<typename _InputIterator, typename _NodeGetter>
                      void
                      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                		    _RehashPolicy, _Traits>::
                      _M_insert_range(_InputIterator __first, _InputIterator __last,
                		      const _NodeGetter& __node_gen, false_type)
                      {
                	using __rehash_type = typename __hashtable::__rehash_type;
                	using __rehash_state = typename __hashtable::__rehash_state;
                	using pair_type = std::pair<bool, std::size_t>;
                
                	size_type __n_elt = __detail::__distance_fw(__first, __last);
                	if (__n_elt == 0)
                	  return;
                
                	__hashtable& __h = _M_conjure_hashtable();
                	__rehash_type& __rehash = __h._M_rehash_policy;
                	const __rehash_state& __saved_state = __rehash._M_state();
                	pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
                							__h._M_element_count,
                							__n_elt);
                
                	if (__do_rehash.first)
                	  __h._M_rehash(__do_rehash.second, __saved_state);
                
                	for (; __first != __last; ++__first)
                	  __h._M_insert(*__first, __node_gen, __unique_keys());
                      }
                
                  /**
                   *  Primary class template _Insert.
                   *
                   *  Defines @c insert member functions that depend on _Hashtable policies,
                   *  via partial specializations.
                   */
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits,
                	   bool _Constant_iterators = _Traits::__constant_iterators::value>
                    struct _Insert;
                
                  /// Specialization.
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                		   _RehashPolicy, _Traits, true>
                    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                			   _H1, _H2, _Hash, _RehashPolicy, _Traits>
                    {
                      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
                					_Equal, _H1, _H2, _Hash,
                					_RehashPolicy, _Traits>;
                
                      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
                					       _Equal, _H1, _H2, _Hash,
                					       _Traits>;
                
                      using value_type = typename __base_type::value_type;
                      using iterator = typename __base_type::iterator;
                      using const_iterator =  typename __base_type::const_iterator;
                
                      using __unique_keys = typename __base_type::__unique_keys;
                      using __ireturn_type = typename __hashtable_base::__ireturn_type;
                      using __hashtable = typename __base_type::__hashtable;
                      using __node_gen_type = typename __base_type::__node_gen_type;
                
                      using __base_type::insert;
                
                      __ireturn_type
                      insert(value_type&& __v)
                      {
                	__hashtable& __h = this->_M_conjure_hashtable();
                	__node_gen_type __node_gen(__h);
                	return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
                      }
                
                      iterator
                      insert(const_iterator __hint, value_type&& __v)
                      {
                	__hashtable& __h = this->_M_conjure_hashtable();
                	__node_gen_type __node_gen(__h);
                	return __h._M_insert(__hint, std::move(__v), __node_gen,
                			     __unique_keys());
                      }
                    };
                
                  /// Specialization.
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                		   _RehashPolicy, _Traits, false>
                    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                			   _H1, _H2, _Hash, _RehashPolicy, _Traits>
                    {
                      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
                				       _Equal, _H1, _H2, _Hash,
                				       _RehashPolicy, _Traits>;
                      using value_type = typename __base_type::value_type;
                      using iterator = typename __base_type::iterator;
                      using const_iterator =  typename __base_type::const_iterator;
                
                      using __unique_keys = typename __base_type::__unique_keys;
                      using __hashtable = typename __base_type::__hashtable;
                      using __ireturn_type = typename __base_type::__ireturn_type;
                
                      using __base_type::insert;
                
                      template<typename _Pair>
                	using __is_cons = std::is_constructible<value_type, _Pair&&>;
                
                      template<typename _Pair>
                	using _IFcons = std::enable_if<__is_cons<_Pair>::value>;
                
                      template<typename _Pair>
                	using _IFconsp = typename _IFcons<_Pair>::type;
                
                      template<typename _Pair, typename = _IFconsp<_Pair>>
                	__ireturn_type
                	insert(_Pair&& __v)
                	{
                	  __hashtable& __h = this->_M_conjure_hashtable();
                	  return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
                	}
                
                      template<typename _Pair, typename = _IFconsp<_Pair>>
                	iterator
                	insert(const_iterator __hint, _Pair&& __v)
                	{
                	  __hashtable& __h = this->_M_conjure_hashtable();
                	  return __h._M_emplace(__hint, __unique_keys(),
                				std::forward<_Pair>(__v));
                	}
                   };
                
                  template<typename _Policy>
                    using __has_load_factor = typename _Policy::__has_load_factor;
                
                  /**
                   *  Primary class template  _Rehash_base.
                   *
                   *  Give hashtable the max_load_factor functions and reserve iff the
                   *  rehash policy supports it.
                  */
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits,
                	   typename =
                	     __detected_or_t<std::false_type, __has_load_factor, _RehashPolicy>>
                    struct _Rehash_base;
                
                  /// Specialization when rehash policy doesn't provide load factor management.
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		      _H1, _H2, _Hash, _RehashPolicy, _Traits,
                		      std::false_type>
                    {
                    };
                
                  /// Specialization when rehash policy provide load factor management.
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                			_H1, _H2, _Hash, _RehashPolicy, _Traits,
                			std::true_type>
                    {
                      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                				     _Equal, _H1, _H2, _Hash,
                				     _RehashPolicy, _Traits>;
                
                      float
                      max_load_factor() const noexcept
                      {
                	const __hashtable* __this = static_cast<const __hashtable*>(this);
                	return __this->__rehash_policy().max_load_factor();
                      }
                
                      void
                      max_load_factor(float __z)
                      {
                	__hashtable* __this = static_cast<__hashtable*>(this);
                	__this->__rehash_policy(_RehashPolicy(__z));
                      }
                
                      void
                      reserve(std::size_t __n)
                      {
                	__hashtable* __this = static_cast<__hashtable*>(this);
                	__this->rehash(__builtin_ceil(__n / max_load_factor()));
                      }
                    };
                
                  /**
                   *  Primary class template _Hashtable_ebo_helper.
                   *
                   *  Helper class using EBO when it is not forbidden (the type is not
                   *  final) and when it is worth it (the type is empty.)
                   */
                  template<int _Nm, typename _Tp,
                	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
                    struct _Hashtable_ebo_helper;
                
                  /// Specialization using EBO.
                  template<int _Nm, typename _Tp>
         900 ->     struct _Hashtable_ebo_helper<_Nm, _Tp, true>
                    : private _Tp
                    {
         900 ->       _Hashtable_ebo_helper() = default;
                
                      template<typename _OtherTp>
                	_Hashtable_ebo_helper(_OtherTp&& __tp)
                	  : _Tp(std::forward<_OtherTp>(__tp))
                	{ }
                
                      static const _Tp&
     6163631 ->       _S_cget(const _Hashtable_ebo_helper& __eboh)
                      { return static_cast<const _Tp&>(__eboh); }
                
                      static _Tp&
     3092400 ->       _S_get(_Hashtable_ebo_helper& __eboh)
                      { return static_cast<_Tp&>(__eboh); }
                    };
                
                  /// Specialization not using EBO.
                  template<int _Nm, typename _Tp>
                    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
                    {
                      _Hashtable_ebo_helper() = default;
                
                      template<typename _OtherTp>
                	_Hashtable_ebo_helper(_OtherTp&& __tp)
                	  : _M_tp(std::forward<_OtherTp>(__tp))
                	{ }
                
                      static const _Tp&
                      _S_cget(const _Hashtable_ebo_helper& __eboh)
                      { return __eboh._M_tp; }
                
                      static _Tp&
                      _S_get(_Hashtable_ebo_helper& __eboh)
                      { return __eboh._M_tp; }
                
                    private:
                      _Tp _M_tp;
                    };
                
                  /**
                   *  Primary class template _Local_iterator_base.
                   *
                   *  Base class for local iterators, used to iterate within a bucket
                   *  but not between buckets.
                   */
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash,
                	   bool __cache_hash_code>
                    struct _Local_iterator_base;
                
                  /**
                   *  Primary class template _Hash_code_base.
                   *
                   *  Encapsulates two policy issues that aren't quite orthogonal.
                   *   (1) the difference between using a ranged hash function and using
                   *       the combination of a hash function and a range-hashing function.
                   *       In the former case we don't have such things as hash codes, so
                   *       we have a dummy type as placeholder.
                   *   (2) Whether or not we cache hash codes.  Caching hash codes is
                   *       meaningless if we have a ranged hash function.
                   *
                   *  We also put the key extraction objects here, for convenience.
                   *  Each specialization derives from one or more of the template
                   *  parameters to benefit from Ebo. This is important as this type
                   *  is inherited in some cases by the _Local_iterator_base type used
                   *  to implement local_iterator and const_local_iterator. As with
                   *  any iterator type we prefer to make it as small as possible.
                   *
                   *  Primary template is unused except as a hook for specializations.
                   */
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash,
                	   bool __cache_hash_code>
                    struct _Hash_code_base;
                
                  /// Specialization: ranged hash function, no caching hash codes.  H1
                  /// and H2 are provided but ignored.  We define a dummy hash code type.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
                    : private _Hashtable_ebo_helper<0, _ExtractKey>,
                      private _Hashtable_ebo_helper<1, _Hash>
                    {
                    private:
                      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
                      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;
                
                    protected:
                      typedef void* 					__hash_code;
                      typedef _Hash_node<_Value, false>			__node_type;
                
                      // We need the default constructor for the local iterators and _Hashtable
                      // default constructor.
                      _Hash_code_base() = default;
                
                      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
                		      const _Hash& __h)
                      : __ebo_extract_key(__ex), __ebo_hash(__h) { }
                
                      __hash_code
                      _M_hash_code(const _Key& __key) const
                      { return 0; }
                
                      std::size_t
                      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
                      { return _M_ranged_hash()(__k, __n); }
                
                      std::size_t
                      _M_bucket_index(const __node_type* __p, std::size_t __n) const
                	noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
                						   (std::size_t)0)) )
                      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }
                
                      void
                      _M_store_code(__node_type*, __hash_code) const
                      { }
                
                      void
                      _M_copy_code(__node_type*, const __node_type*) const
                      { }
                
                      void
                      _M_swap(_Hash_code_base& __x)
                      {
                	std::swap(_M_extract(), __x._M_extract());
                	std::swap(_M_ranged_hash(), __x._M_ranged_hash());
                      }
                
                      const _ExtractKey&
                      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }
                
                      _ExtractKey&
                      _M_extract() { return __ebo_extract_key::_S_get(*this); }
                
                      const _Hash&
                      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }
                
                      _Hash&
                      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
                    };
                
                  // No specialization for ranged hash function while caching hash codes.
                  // That combination is meaningless, and trying to do it is an error.
                
                  /// Specialization: ranged hash function, cache hash codes.  This
                  /// combination is meaningless, so we provide only a declaration
                  /// and no definition.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;
                
                  /// Specialization: hash function and range-hashing function, no
                  /// caching of hash codes.
                  /// Provides typedef and accessor required by C++ 11.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
                			   _Default_ranged_hash, false>
                    : private _Hashtable_ebo_helper<0, _ExtractKey>,
                      private _Hashtable_ebo_helper<1, _H1>,
                      private _Hashtable_ebo_helper<2, _H2>
                    {
                    private:
                      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
                      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;
                
                      // Gives the local iterator implementation access to _M_bucket_index().
                      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
                					 _Default_ranged_hash, false>;
                
                    public:
                      typedef _H1 					hasher;
                
                      hasher
                      hash_function() const
                      { return _M_h1(); }
                
                    protected:
                      typedef std::size_t 				__hash_code;
                      typedef _Hash_node<_Value, false>			__node_type;
                
                      // We need the default constructor for the local iterators and _Hashtable
                      // default constructor.
                      _Hash_code_base() = default;
                
                      _Hash_code_base(const _ExtractKey& __ex,
                		      const _H1& __h1, const _H2& __h2,
                		      const _Default_ranged_hash&)
                      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                
                      __hash_code
      614700 ->       _M_hash_code(const _Key& __k) const
                      {
                	static_assert(__is_invocable<const _H1&, const _Key&>{},
                	    "hash function must be invocable with an argument of key type");
                	return _M_h1()(__k);
                      }
                
                      std::size_t
      621000 ->       _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
                      { return _M_h2()(__c, __n); }
                
                      std::size_t
     1540529 ->       _M_bucket_index(const __node_type* __p, std::size_t __n) const
                	noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
                		  && noexcept(declval<const _H2&>()((__hash_code)0,
                						    (std::size_t)0)) )
                      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }
                
                      void
      614700 ->       _M_store_code(__node_type*, __hash_code) const
                      { }
                
                      void
                      _M_copy_code(__node_type*, const __node_type*) const
                      { }
                
                      void
                      _M_swap(_Hash_code_base& __x)
                      {
                	std::swap(_M_extract(), __x._M_extract());
                	std::swap(_M_h1(), __x._M_h1());
                	std::swap(_M_h2(), __x._M_h2());
                      }
                
                      const _ExtractKey&
     1693701 ->       _M_extract() const { return __ebo_extract_key::_S_cget(*this); }
                
                      _ExtractKey&
      621000 ->       _M_extract() { return __ebo_extract_key::_S_get(*this); }
                
                      const _H1&
     2155229 ->       _M_h1() const { return __ebo_h1::_S_cget(*this); }
                
                      _H1&
                      _M_h1() { return __ebo_h1::_S_get(*this); }
                
                      const _H2&
     2161529 ->       _M_h2() const { return __ebo_h2::_S_cget(*this); }
                
                      _H2&
                      _M_h2() { return __ebo_h2::_S_get(*this); }
                    };
                
                  /// Specialization: hash function and range-hashing function,
                  /// caching hash codes.  H is provided but ignored.  Provides
                  /// typedef and accessor required by C++ 11.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2>
                    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
                			   _Default_ranged_hash, true>
                    : private _Hashtable_ebo_helper<0, _ExtractKey>,
                      private _Hashtable_ebo_helper<1, _H1>,
                      private _Hashtable_ebo_helper<2, _H2>
                    {
                    private:
                      // Gives the local iterator implementation access to _M_h2().
                      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
                					 _Default_ranged_hash, true>;
                
                      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
                      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;
                
                    public:
                      typedef _H1 					hasher;
                
                      hasher
                      hash_function() const
                      { return _M_h1(); }
                
                    protected:
                      typedef std::size_t 				__hash_code;
                      typedef _Hash_node<_Value, true>			__node_type;
                
                      // We need the default constructor for _Hashtable default constructor.
                      _Hash_code_base() = default;
                      _Hash_code_base(const _ExtractKey& __ex,
                		      const _H1& __h1, const _H2& __h2,
                		      const _Default_ranged_hash&)
                      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                
                      __hash_code
                      _M_hash_code(const _Key& __k) const
                      {
                	static_assert(__is_invocable<const _H1&, const _Key&>{},
                	    "hash function must be invocable with an argument of key type");
                	return _M_h1()(__k);
                      }
                
                      std::size_t
                      _M_bucket_index(const _Key&, __hash_code __c,
                		      std::size_t __n) const
                      { return _M_h2()(__c, __n); }
                
                      std::size_t
                      _M_bucket_index(const __node_type* __p, std::size_t __n) const
                	noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
                						 (std::size_t)0)) )
                      { return _M_h2()(__p->_M_hash_code, __n); }
                
                      void
                      _M_store_code(__node_type* __n, __hash_code __c) const
                      { __n->_M_hash_code = __c; }
                
                      void
                      _M_copy_code(__node_type* __to, const __node_type* __from) const
                      { __to->_M_hash_code = __from->_M_hash_code; }
                
                      void
                      _M_swap(_Hash_code_base& __x)
                      {
                	std::swap(_M_extract(), __x._M_extract());
                	std::swap(_M_h1(), __x._M_h1());
                	std::swap(_M_h2(), __x._M_h2());
                      }
                
                      const _ExtractKey&
                      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }
                
                      _ExtractKey&
                      _M_extract() { return __ebo_extract_key::_S_get(*this); }
                
                      const _H1&
                      _M_h1() const { return __ebo_h1::_S_cget(*this); }
                
                      _H1&
                      _M_h1() { return __ebo_h1::_S_get(*this); }
                
                      const _H2&
                      _M_h2() const { return __ebo_h2::_S_cget(*this); }
                
                      _H2&
                      _M_h2() { return __ebo_h2::_S_get(*this); }
                    };
                
                  /**
                   *  Primary class template _Equal_helper.
                   *
                   */
                  template <typename _Key, typename _Value, typename _ExtractKey,
                	    typename _Equal, typename _HashCodeType,
                	    bool __cache_hash_code>
                  struct _Equal_helper;
                
                  /// Specialization.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _Equal, typename _HashCodeType>
                  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
                  {
                    static bool
                    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
                	      const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
                    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }
                  };
                
                  /// Specialization.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _Equal, typename _HashCodeType>
                  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
                  {
                    static bool
      153172 ->     _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
                	      const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
                    { return __eq(__k, __extract(__n->_M_v())); }
                  };
                
                
                  /// Partial specialization used when nodes contain a cached hash code.
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash>
                    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
                				_H1, _H2, _Hash, true>
                    : private _Hashtable_ebo_helper<0, _H2>
                    {
                    protected:
                      using __base_type = _Hashtable_ebo_helper<0, _H2>;
                      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
                					       _H1, _H2, _Hash, true>;
                
                      _Local_iterator_base() = default;
                      _Local_iterator_base(const __hash_code_base& __base,
                			   _Hash_node<_Value, true>* __p,
                			   std::size_t __bkt, std::size_t __bkt_count)
                      : __base_type(__base._M_h2()),
                	_M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }
                
                      void
                      _M_incr()
                      {
                	_M_cur = _M_cur->_M_next();
                	if (_M_cur)
                	  {
                	    std::size_t __bkt
                	      = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
                					   _M_bucket_count);
                	    if (__bkt != _M_bucket)
                	      _M_cur = nullptr;
                	  }
                      }
                
                      _Hash_node<_Value, true>*  _M_cur;
                      std::size_t _M_bucket;
                      std::size_t _M_bucket_count;
                
                    public:
                      const void*
                      _M_curr() const { return _M_cur; }  // for equality ops
                
                      std::size_t
                      _M_get_bucket() const { return _M_bucket; }  // for debug mode
                    };
                
                  // Uninitialized storage for a _Hash_code_base.
                  // This type is DefaultConstructible and Assignable even if the
                  // _Hash_code_base type isn't, so that _Local_iterator_base<..., false>
                  // can be DefaultConstructible and Assignable.
                  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
                    struct _Hash_code_storage
                    {
                      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
                
                      _Tp*
                      _M_h() { return _M_storage._M_ptr(); }
                
                      const _Tp*
                      _M_h() const { return _M_storage._M_ptr(); }
                    };
                
                  // Empty partial specialization for empty _Hash_code_base types.
                  template<typename _Tp>
                    struct _Hash_code_storage<_Tp, true>
                    {
                      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );
                
                      // As _Tp is an empty type there will be no bytes written/read through
                      // the cast pointer, so no strict-aliasing violation.
                      _Tp*
                      _M_h() { return reinterpret_cast<_Tp*>(this); }
                
                      const _Tp*
                      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
                    };
                
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash>
                    using __hash_code_for_local_iter
                      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
                					   _H1, _H2, _Hash, false>>;
                
                  // Partial specialization used when hash codes are not cached
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash>
                    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
                				_H1, _H2, _Hash, false>
                    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
                    {
                    protected:
                      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
                					       _H1, _H2, _Hash, false>;
                
                      _Local_iterator_base() : _M_bucket_count(-1) { }
                
                      _Local_iterator_base(const __hash_code_base& __base,
                			   _Hash_node<_Value, false>* __p,
                			   std::size_t __bkt, std::size_t __bkt_count)
                      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
                      { _M_init(__base); }
                
                      ~_Local_iterator_base()
                      {
                	if (_M_bucket_count != -1)
                	  _M_destroy();
                      }
                
                      _Local_iterator_base(const _Local_iterator_base& __iter)
                      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
                        _M_bucket_count(__iter._M_bucket_count)
                      {
                	if (_M_bucket_count != -1)
                	  _M_init(*__iter._M_h());
                      }
                
                      _Local_iterator_base&
                      operator=(const _Local_iterator_base& __iter)
                      {
                	if (_M_bucket_count != -1)
                	  _M_destroy();
                	_M_cur = __iter._M_cur;
                	_M_bucket = __iter._M_bucket;
                	_M_bucket_count = __iter._M_bucket_count;
                	if (_M_bucket_count != -1)
                	  _M_init(*__iter._M_h());
                	return *this;
                      }
                
                      void
                      _M_incr()
                      {
                	_M_cur = _M_cur->_M_next();
                	if (_M_cur)
                	  {
                	    std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
                							      _M_bucket_count);
                	    if (__bkt != _M_bucket)
                	      _M_cur = nullptr;
                	  }
                      }
                
                      _Hash_node<_Value, false>*  _M_cur;
                      std::size_t _M_bucket;
                      std::size_t _M_bucket_count;
                
                      void
                      _M_init(const __hash_code_base& __base)
                      { ::new(this->_M_h()) __hash_code_base(__base); }
                
                      void
                      _M_destroy() { this->_M_h()->~__hash_code_base(); }
                
                    public:
                      const void*
                      _M_curr() const { return _M_cur; }  // for equality ops and debug mode
                
                      std::size_t
                      _M_get_bucket() const { return _M_bucket; }  // for debug mode
                    };
                
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash, bool __cache>
                    inline bool
                    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
                					  _H1, _H2, _Hash, __cache>& __x,
                	       const _Local_iterator_base<_Key, _Value, _ExtractKey,
                					  _H1, _H2, _Hash, __cache>& __y)
                    { return __x._M_curr() == __y._M_curr(); }
                
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash, bool __cache>
                    inline bool
                    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
                					  _H1, _H2, _Hash, __cache>& __x,
                	       const _Local_iterator_base<_Key, _Value, _ExtractKey,
                					  _H1, _H2, _Hash, __cache>& __y)
                    { return __x._M_curr() != __y._M_curr(); }
                
                  /// local iterators
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash,
                	   bool __constant_iterators, bool __cache>
                    struct _Local_iterator
                    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
                				  _H1, _H2, _Hash, __cache>
                    {
                    private:
                      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
                					       _H1, _H2, _Hash, __cache>;
                      using __hash_code_base = typename __base_type::__hash_code_base;
                    public:
                      typedef _Value					value_type;
                      typedef typename std::conditional<__constant_iterators,
                					const _Value*, _Value*>::type
                						       pointer;
                      typedef typename std::conditional<__constant_iterators,
                					const _Value&, _Value&>::type
                						       reference;
                      typedef std::ptrdiff_t				difference_type;
                      typedef std::forward_iterator_tag			iterator_category;
                
                      _Local_iterator() = default;
                
                      _Local_iterator(const __hash_code_base& __base,
                		      _Hash_node<_Value, __cache>* __p,
                		      std::size_t __bkt, std::size_t __bkt_count)
                	: __base_type(__base, __p, __bkt, __bkt_count)
                      { }
                
                      reference
                      operator*() const
                      { return this->_M_cur->_M_v(); }
                
                      pointer
                      operator->() const
                      { return this->_M_cur->_M_valptr(); }
                
                      _Local_iterator&
                      operator++()
                      {
                	this->_M_incr();
                	return *this;
                      }
                
                      _Local_iterator
                      operator++(int)
                      {
                	_Local_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  /// local const_iterators
                  template<typename _Key, typename _Value, typename _ExtractKey,
                	   typename _H1, typename _H2, typename _Hash,
                	   bool __constant_iterators, bool __cache>
                    struct _Local_const_iterator
                    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
                				  _H1, _H2, _Hash, __cache>
                    {
                    private:
                      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
                					       _H1, _H2, _Hash, __cache>;
                      using __hash_code_base = typename __base_type::__hash_code_base;
                
                    public:
                      typedef _Value					value_type;
                      typedef const _Value*				pointer;
                      typedef const _Value&				reference;
                      typedef std::ptrdiff_t				difference_type;
                      typedef std::forward_iterator_tag			iterator_category;
                
                      _Local_const_iterator() = default;
                
                      _Local_const_iterator(const __hash_code_base& __base,
                			    _Hash_node<_Value, __cache>* __p,
                			    std::size_t __bkt, std::size_t __bkt_count)
                	: __base_type(__base, __p, __bkt, __bkt_count)
                      { }
                
                      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
                						  _H1, _H2, _Hash,
                						  __constant_iterators,
                						  __cache>& __x)
                	: __base_type(__x)
                      { }
                
                      reference
                      operator*() const
                      { return this->_M_cur->_M_v(); }
                
                      pointer
                      operator->() const
                      { return this->_M_cur->_M_valptr(); }
                
                      _Local_const_iterator&
                      operator++()
                      {
                	this->_M_incr();
                	return *this;
                      }
                
                      _Local_const_iterator
                      operator++(int)
                      {
                	_Local_const_iterator __tmp(*this);
                	this->_M_incr();
                	return __tmp;
                      }
                    };
                
                  /**
                   *  Primary class template _Hashtable_base.
                   *
                   *  Helper class adding management of _Equal functor to
                   *  _Hash_code_base type.
                   *
                   *  Base class templates are:
                   *    - __detail::_Hash_code_base
                   *    - __detail::_Hashtable_ebo_helper
                   */
                  template<typename _Key, typename _Value,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _Traits>
                  struct _Hashtable_base
                  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
                			   _Traits::__hash_cached::value>,
                    private _Hashtable_ebo_helper<0, _Equal>
                  {
                  public:
                    typedef _Key					key_type;
                    typedef _Value					value_type;
                    typedef _Equal					key_equal;
                    typedef std::size_t					size_type;
                    typedef std::ptrdiff_t				difference_type;
                
                    using __traits_type = _Traits;
                    using __hash_cached = typename __traits_type::__hash_cached;
                    using __constant_iterators = typename __traits_type::__constant_iterators;
                    using __unique_keys = typename __traits_type::__unique_keys;
                
                    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
                					     _H1, _H2, _Hash,
                					     __hash_cached::value>;
                
                    using __hash_code = typename __hash_code_base::__hash_code;
                    using __node_type = typename __hash_code_base::__node_type;
                
                    using iterator = __detail::_Node_iterator<value_type,
                					      __constant_iterators::value,
                					      __hash_cached::value>;
                
                    using const_iterator = __detail::_Node_const_iterator<value_type,
                						   __constant_iterators::value,
                						   __hash_cached::value>;
                
                    using local_iterator = __detail::_Local_iterator<key_type, value_type,
                						  _ExtractKey, _H1, _H2, _Hash,
                						  __constant_iterators::value,
                						     __hash_cached::value>;
                
                    using const_local_iterator = __detail::_Local_const_iterator<key_type,
                								 value_type,
                					_ExtractKey, _H1, _H2, _Hash,
                					__constant_iterators::value,
                					__hash_cached::value>;
                
                    using __ireturn_type = typename std::conditional<__unique_keys::value,
                						     std::pair<iterator, bool>,
                						     iterator>::type;
                  private:
                    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
                    using _EqualHelper =  _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
                					__hash_code, __hash_cached::value>;
                
                  protected:
                    _Hashtable_base() = default;
                    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
                		    const _Hash& __hash, const _Equal& __eq)
                    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
                    { }
                
                    bool
      153172 ->     _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
                    {
                      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
                	  "key equality predicate must be invocable with two arguments of "
                	  "key type");
                      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
                				     __k, __c, __n);
                    }
                
                    void
                    _M_swap(_Hashtable_base& __x)
                    {
                      __hash_code_base::_M_swap(__x);
                      std::swap(_M_eq(), __x._M_eq());
                    }
                
                    const _Equal&
      153172 ->     _M_eq() const { return _EqualEBO::_S_cget(*this); }
                
                    _Equal&
                    _M_eq() { return _EqualEBO::_S_get(*this); }
                  };
                
                  /**
                   *  struct _Equality_base.
                   *
                   *  Common types and functions for class _Equality.
                   */
                  struct _Equality_base
                  {
                  protected:
                    template<typename _Uiterator>
                      static bool
                      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
                  };
                
                  // See std::is_permutation in N3068.
                  template<typename _Uiterator>
                    bool
                    _Equality_base::
                    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
                		      _Uiterator __first2)
                    {
                      for (; __first1 != __last1; ++__first1, ++__first2)
                	if (!(*__first1 == *__first2))
                	  break;
                
                      if (__first1 == __last1)
                	return true;
                
                      _Uiterator __last2 = __first2;
                      std::advance(__last2, std::distance(__first1, __last1));
                
                      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
                	{
                	  _Uiterator __tmp =  __first1;
                	  while (__tmp != __it1 && !bool(*__tmp == *__it1))
                	    ++__tmp;
                
                	  // We've seen this one before.
                	  if (__tmp != __it1)
                	    continue;
                
                	  std::ptrdiff_t __n2 = 0;
                	  for (__tmp = __first2; __tmp != __last2; ++__tmp)
                	    if (*__tmp == *__it1)
                	      ++__n2;
                
                	  if (!__n2)
                	    return false;
                
                	  std::ptrdiff_t __n1 = 0;
                	  for (__tmp = __it1; __tmp != __last1; ++__tmp)
                	    if (*__tmp == *__it1)
                	      ++__n1;
                
                	  if (__n1 != __n2)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  Primary class template  _Equality.
                   *
                   *  This is for implementing equality comparison for unordered
                   *  containers, per N3068, by John Lakos and Pablo Halpern.
                   *  Algorithmically, we follow closely the reference implementations
                   *  therein.
                   */
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits,
                	   bool _Unique_keys = _Traits::__unique_keys::value>
                    struct _Equality;
                
                  /// Specialization.
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                    {
                      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                				     _H1, _H2, _Hash, _RehashPolicy, _Traits>;
                
                      bool
                      _M_equal(const __hashtable&) const;
                    };
                
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    bool
                    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                    _M_equal(const __hashtable& __other) const
                    {
                      const __hashtable* __this = static_cast<const __hashtable*>(this);
                
                      if (__this->size() != __other.size())
                	return false;
                
                      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
                	{
                	  const auto __ity = __other.find(_ExtractKey()(*__itx));
                	  if (__ity == __other.end() || !bool(*__ity == *__itx))
                	    return false;
                	}
                      return true;
                    }
                
                  /// Specialization.
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
                    : public _Equality_base
                    {
                      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                				     _H1, _H2, _Hash, _RehashPolicy, _Traits>;
                
                      bool
                      _M_equal(const __hashtable&) const;
                    };
                
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    bool
                    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	      _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
                    _M_equal(const __hashtable& __other) const
                    {
                      const __hashtable* __this = static_cast<const __hashtable*>(this);
                
                      if (__this->size() != __other.size())
                	return false;
                
                      for (auto __itx = __this->begin(); __itx != __this->end();)
                	{
                	  const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
                	  const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));
                
                	  if (std::distance(__xrange.first, __xrange.second)
                	      != std::distance(__yrange.first, __yrange.second))
                	    return false;
                
                	  if (!_S_is_permutation(__xrange.first, __xrange.second,
                				 __yrange.first))
                	    return false;
                
                	  __itx = __xrange.second;
                	}
                      return true;
                    }
                
                  /**
                   * This type deals with all allocation and keeps an allocator instance through
                   * inheritance to benefit from EBO when possible.
                   */
                  template<typename _NodeAlloc>
         900 ->     struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
                    {
                    private:
                      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
                    public:
                      using __node_type = typename _NodeAlloc::value_type;
                      using __node_alloc_type = _NodeAlloc;
                      // Use __gnu_cxx to benefit from _S_always_equal and al.
                      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;
                
                      using __value_alloc_traits = typename __node_alloc_traits::template
                	rebind_traits<typename __node_type::value_type>;
                
                      using __node_base = __detail::_Hash_node_base;
                      using __bucket_type = __node_base*;      
                      using __bucket_alloc_type =
                	__alloc_rebind<__node_alloc_type, __bucket_type>;
                      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;
                
         900 ->       _Hashtable_alloc() = default;
                      _Hashtable_alloc(const _Hashtable_alloc&) = default;
                      _Hashtable_alloc(_Hashtable_alloc&&) = default;
                
                      template<typename _Alloc>
                	_Hashtable_alloc(_Alloc&& __a)
                	  : __ebo_node_alloc(std::forward<_Alloc>(__a))
                	{ }
                
                      __node_alloc_type&
     2471400 ->       _M_node_allocator()
                      { return __ebo_node_alloc::_S_get(*this); }
                
                      const __node_alloc_type&
                      _M_node_allocator() const
                      { return __ebo_node_alloc::_S_cget(*this); }
                
                      template<typename... _Args>
                	__node_type*
                	_M_allocate_node(_Args&&... __args);
                
                      void
                      _M_deallocate_node(__node_type* __n);
                
                      void
                      _M_deallocate_node_ptr(__node_type* __n);
                
                      // Deallocate the linked list of nodes pointed to by __n
                      void
                      _M_deallocate_nodes(__node_type* __n);
                
                      __bucket_type*
                      _M_allocate_buckets(std::size_t __n);
                
                      void
                      _M_deallocate_buckets(__bucket_type*, std::size_t __n);
                    };
                
                  // Definitions of class template _Hashtable_alloc's out-of-line member
                  // functions.
                  template<typename _NodeAlloc>
                    template<typename... _Args>
                      typename _Hashtable_alloc<_NodeAlloc>::__node_type*
      614700 ->       _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
                      {
                	auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
                	__node_type* __n = std::__to_address(__nptr);
                	__try
                	  {
                	    ::new ((void*)__n) __node_type;
                	    __node_alloc_traits::construct(_M_node_allocator(),
                					   __n->_M_valptr(),
                					   std::forward<_Args>(__args)...);
                	    return __n;
                	  }
                	__catch(...)
                	  {
                	    __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _NodeAlloc>
                    void
      614700 ->     _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
                    {
                      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
                      _M_deallocate_node_ptr(__n);
                    }
                
                  template<typename _NodeAlloc>
                    void
      614700 ->     _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_type* __n)
                    {
                      typedef typename __node_alloc_traits::pointer _Ptr;
                      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
                      __n->~__node_type();
                      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
                    }
                
                  template<typename _NodeAlloc>
                    void
         900 ->     _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
                    {
                      while (__n)
                	{
                	  __node_type* __tmp = __n;
                	  __n = __n->_M_next();
                	  _M_deallocate_node(__tmp);
                	}
                    }
                
                  template<typename _NodeAlloc>
                    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
        6300 ->     _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)
                    {
                      __bucket_alloc_type __alloc(_M_node_allocator());
                
                      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
                      __bucket_type* __p = std::__to_address(__ptr);
                      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
                      return __p;
                    }
                
                  template<typename _NodeAlloc>
                    void
        6300 ->     _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
                							std::size_t __n)
                    {
                      typedef typename __bucket_alloc_traits::pointer _Ptr;
                      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
                      __bucket_alloc_type __alloc(_M_node_allocator());
                      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);
                    }
                
                 ///@} hashtable-detail
                } // namespace __detail
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // _HASHTABLE_POLICY_H


Top 10 Lines:

     Line      Count

     1104    6163631
      282    3384973
     1108    3092400
     2046    2471400
       84    2314701
      431    2161529
     1335    2161529
     1329    2155229
      236    2003572
     1323    1693701

Execution Summary:

       47   Executable lines in this file
       47   Lines executed
   100.00   Percent of the file executed

 48247640   Total number of line executions
1026545.53   Average executions per line


*** File /usr/include/c++/9/bits/hashtable.h:
                // hashtable.h header -*- C++ -*-
                
                // Copyright (C) 2007-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/hashtable.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{unordered_map, unordered_set}
                 */
                
                #ifndef _HASHTABLE_H
                #define _HASHTABLE_H 1
                
                #pragma GCC system_header
                
                #include <bits/hashtable_policy.h>
                #if __cplusplus > 201402L
                # include <bits/node_handle.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Tp, typename _Hash>
                    using __cache_default
                      =  __not_<__and_<// Do not cache for fast hasher.
                		       __is_fast_hash<_Hash>,
                		       // Mandatory to have erase not throwing.
                		       __is_nothrow_invocable<const _Hash&, const _Tp&>>>;
                
                  /**
                   *  Primary class template _Hashtable.
                   *
                   *  @ingroup hashtable-detail
                   *
                   *  @tparam _Value  CopyConstructible type.
                   *
                   *  @tparam _Key    CopyConstructible type.
                   *
                   *  @tparam _Alloc  An allocator type
                   *  ([lib.allocator.requirements]) whose _Alloc::value_type is
                   *  _Value.  As a conforming extension, we allow for
                   *  _Alloc::value_type != _Value.
                   *
                   *  @tparam _ExtractKey  Function object that takes an object of type
                   *  _Value and returns a value of type _Key.
                   *
                   *  @tparam _Equal  Function object that takes two objects of type k
                   *  and returns a bool-like value that is true if the two objects
                   *  are considered equal.
                   *
                   *  @tparam _H1  The hash function. A unary function object with
                   *  argument type _Key and result type size_t. Return values should
                   *  be distributed over the entire range [0, numeric_limits<size_t>:::max()].
                   *
                   *  @tparam _H2  The range-hashing function (in the terminology of
                   *  Tavori and Dreizin).  A binary function object whose argument
                   *  types and result type are all size_t.  Given arguments r and N,
                   *  the return value is in the range [0, N).
                   *
                   *  @tparam _Hash  The ranged hash function (Tavori and Dreizin). A
                   *  binary function whose argument types are _Key and size_t and
                   *  whose result type is size_t.  Given arguments k and N, the
                   *  return value is in the range [0, N).  Default: hash(k, N) =
                   *  h2(h1(k), N).  If _Hash is anything other than the default, _H1
                   *  and _H2 are ignored.
                   *
                   *  @tparam _RehashPolicy  Policy class with three members, all of
                   *  which govern the bucket count. _M_next_bkt(n) returns a bucket
                   *  count no smaller than n.  _M_bkt_for_elements(n) returns a
                   *  bucket count appropriate for an element count of n.
                   *  _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the
                   *  current bucket count is n_bkt and the current element count is
                   *  n_elt, we need to increase the bucket count.  If so, returns
                   *  make_pair(true, n), where n is the new bucket count.  If not,
                   *  returns make_pair(false, <anything>)
                   *
                   *  @tparam _Traits  Compile-time class with three boolean
                   *  std::integral_constant members:  __cache_hash_code, __constant_iterators,
                   *   __unique_keys.
                   *
                   *  Each _Hashtable data structure has:
                   *
                   *  - _Bucket[]       _M_buckets
                   *  - _Hash_node_base _M_before_begin
                   *  - size_type       _M_bucket_count
                   *  - size_type       _M_element_count
                   *
                   *  with _Bucket being _Hash_node* and _Hash_node containing:
                   *
                   *  - _Hash_node*   _M_next
                   *  - Tp            _M_value
                   *  - size_t        _M_hash_code if cache_hash_code is true
                   *
                   *  In terms of Standard containers the hashtable is like the aggregation of:
                   *
                   *  - std::forward_list<_Node> containing the elements
                   *  - std::vector<std::forward_list<_Node>::iterator> representing the buckets
                   *
                   *  The non-empty buckets contain the node before the first node in the
                   *  bucket. This design makes it possible to implement something like a
                   *  std::forward_list::insert_after on container insertion and
                   *  std::forward_list::erase_after on container erase
                   *  calls. _M_before_begin is equivalent to
                   *  std::forward_list::before_begin. Empty buckets contain
                   *  nullptr.  Note that one of the non-empty buckets contains
                   *  &_M_before_begin which is not a dereferenceable node so the
                   *  node pointer in a bucket shall never be dereferenced, only its
                   *  next node can be.
                   *
                   *  Walking through a bucket's nodes requires a check on the hash code to
                   *  see if each node is still in the bucket. Such a design assumes a
                   *  quite efficient hash functor and is one of the reasons it is
                   *  highly advisable to set __cache_hash_code to true.
                   *
                   *  The container iterators are simply built from nodes. This way
                   *  incrementing the iterator is perfectly efficient independent of
                   *  how many empty buckets there are in the container.
                   *
                   *  On insert we compute the element's hash code and use it to find the
                   *  bucket index. If the element must be inserted in an empty bucket
                   *  we add it at the beginning of the singly linked list and make the
                   *  bucket point to _M_before_begin. The bucket that used to point to
                   *  _M_before_begin, if any, is updated to point to its new before
                   *  begin node.
                   *
                   *  On erase, the simple iterator design requires using the hash
                   *  functor to get the index of the bucket to update. For this
                   *  reason, when __cache_hash_code is set to false the hash functor must
                   *  not throw and this is enforced by a static assertion.
                   *
                   *  Functionality is implemented by decomposition into base classes,
                   *  where the derived _Hashtable class is used in _Map_base,
                   *  _Insert, _Rehash_base, and _Equality base classes to access the
                   *  "this" pointer. _Hashtable_base is used in the base classes as a
                   *  non-recursive, fully-completed-type so that detailed nested type
                   *  information, such as iterator type and node type, can be
                   *  used. This is similar to the "Curiously Recurring Template
                   *  Pattern" (CRTP) technique, but uses a reconstructed, not
                   *  explicitly passed, template pattern.
                   *
                   *  Base class templates are: 
                   *    - __detail::_Hashtable_base
                   *    - __detail::_Map_base
                   *    - __detail::_Insert
                   *    - __detail::_Rehash_base
                   *    - __detail::_Equality
                   */
                  template<typename _Key, typename _Value, typename _Alloc,
                	   typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash,
                	   typename _RehashPolicy, typename _Traits>
                    class _Hashtable
                    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
                				       _H1, _H2, _Hash, _Traits>,
                      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                				 _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                			       _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                				    _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                				 _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                      private __detail::_Hashtable_alloc<
                	__alloc_rebind<_Alloc,
                		       __detail::_Hash_node<_Value,
                					    _Traits::__hash_cached::value>>>
                    {
                      static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
                	  "unordered container must have a non-const, non-volatile value_type");
                #ifdef __STRICT_ANSI__
                      static_assert(is_same<typename _Alloc::value_type, _Value>{},
                	  "unordered container must have the same value_type as its allocator");
                #endif
                
                      using __traits_type = _Traits;
                      using __hash_cached = typename __traits_type::__hash_cached;
                      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
                      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
                
                      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;
                
                      using __value_alloc_traits =
                	typename __hashtable_alloc::__value_alloc_traits;
                      using __node_alloc_traits =
                	typename __hashtable_alloc::__node_alloc_traits;
                      using __node_base = typename __hashtable_alloc::__node_base;
                      using __bucket_type = typename __hashtable_alloc::__bucket_type;
                
                    public:
                      typedef _Key						key_type;
                      typedef _Value						value_type;
                      typedef _Alloc						allocator_type;
                      typedef _Equal						key_equal;
                
                      // mapped_type, if present, comes from _Map_base.
                      // hasher, if present, comes from _Hash_code_base/_Hashtable_base.
                      typedef typename __value_alloc_traits::pointer		pointer;
                      typedef typename __value_alloc_traits::const_pointer	const_pointer;
                      typedef value_type&					reference;
                      typedef const value_type&					const_reference;
                
                    private:
                      using __rehash_type = _RehashPolicy;
                      using __rehash_state = typename __rehash_type::_State;
                
                      using __constant_iterators = typename __traits_type::__constant_iterators;
                      using __unique_keys = typename __traits_type::__unique_keys;
                
                      using __key_extract = typename std::conditional<
                					     __constant_iterators::value,
                				       	     __detail::_Identity,
                					     __detail::_Select1st>::type;
                
                      using __hashtable_base = __detail::
                			       _Hashtable_base<_Key, _Value, _ExtractKey,
                					      _Equal, _H1, _H2, _Hash, _Traits>;
                
                      using __hash_code_base =  typename __hashtable_base::__hash_code_base;
                      using __hash_code =  typename __hashtable_base::__hash_code;
                      using __ireturn_type = typename __hashtable_base::__ireturn_type;
                
                      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
                					     _Equal, _H1, _H2, _Hash,
                					     _RehashPolicy, _Traits>;
                
                      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
                						   _ExtractKey, _Equal,
                						   _H1, _H2, _Hash,
                						   _RehashPolicy, _Traits>;
                
                      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
                					    _Equal, _H1, _H2, _Hash,
                					    _RehashPolicy, _Traits>;
                
                      using __reuse_or_alloc_node_type =
                	__detail::_ReuseOrAllocNode<__node_alloc_type>;
                
                      // Metaprogramming for picking apart hash caching.
                      template<typename _Cond>
                	using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;
                
                      template<typename _Cond>
                	using __if_hash_not_cached = __or_<__hash_cached, _Cond>;
                
                      // Compile-time diagnostics.
                
                      // _Hash_code_base has everything protected, so use this derived type to
                      // access it.
                      struct __hash_code_base_access : __hash_code_base
                      { using __hash_code_base::_M_bucket_index; };
                
                      // Getting a bucket index from a node shall not throw because it is used
                      // in methods (erase, swap...) that shall not throw.
                      static_assert(noexcept(declval<const __hash_code_base_access&>()
                			     ._M_bucket_index((const __node_type*)nullptr,
                					      (std::size_t)0)),
                		    "Cache the hash code or qualify your functors involved"
                		    " in hash code and bucket index computation with noexcept");
                
                      // Following two static assertions are necessary to guarantee
                      // that local_iterator will be default constructible.
                
                      // When hash codes are cached local iterator inherits from H2 functor
                      // which must then be default constructible.
                      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
                		    "Functor used to map hash code to bucket index"
                		    " must be default constructible");
                
                      template<typename _Keya, typename _Valuea, typename _Alloca,
                	       typename _ExtractKeya, typename _Equala,
                	       typename _H1a, typename _H2a, typename _Hasha,
                	       typename _RehashPolicya, typename _Traitsa,
                	       bool _Unique_keysa>
                	friend struct __detail::_Map_base;
                
                      template<typename _Keya, typename _Valuea, typename _Alloca,
                	       typename _ExtractKeya, typename _Equala,
                	       typename _H1a, typename _H2a, typename _Hasha,
                	       typename _RehashPolicya, typename _Traitsa>
                	friend struct __detail::_Insert_base;
                
                      template<typename _Keya, typename _Valuea, typename _Alloca,
                	       typename _ExtractKeya, typename _Equala,
                	       typename _H1a, typename _H2a, typename _Hasha,
                	       typename _RehashPolicya, typename _Traitsa,
                	       bool _Constant_iteratorsa>
                	friend struct __detail::_Insert;
                
                    public:
                      using size_type = typename __hashtable_base::size_type;
                      using difference_type = typename __hashtable_base::difference_type;
                
                      using iterator = typename __hashtable_base::iterator;
                      using const_iterator = typename __hashtable_base::const_iterator;
                
                      using local_iterator = typename __hashtable_base::local_iterator;
                      using const_local_iterator = typename __hashtable_base::
                				   const_local_iterator;
                
                #if __cplusplus > 201402L
                      using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;
                      using insert_return_type = _Node_insert_return<iterator, node_type>;
                #endif
                
                    private:
                      __bucket_type*		_M_buckets		= &_M_single_bucket;
                      size_type			_M_bucket_count		= 1;
                      __node_base		_M_before_begin;
                      size_type			_M_element_count	= 0;
                      _RehashPolicy		_M_rehash_policy;
                
                      // A single bucket used when only need for 1 bucket. Especially
                      // interesting in move semantic to leave hashtable with only 1 buckets
                      // which is not allocated so that we can have those operations noexcept
                      // qualified.
                      // Note that we can't leave hashtable with 0 bucket without adding
                      // numerous checks in the code to avoid 0 modulus.
                      __bucket_type		_M_single_bucket	= nullptr;
                
                      bool
        7200 ->       _M_uses_single_bucket(__bucket_type* __bkts) const
                      { return __builtin_expect(__bkts == &_M_single_bucket, false); }
                
                      bool
                      _M_uses_single_bucket() const
                      { return _M_uses_single_bucket(_M_buckets); }
                
                      __hashtable_alloc&
                      _M_base_alloc() { return *this; }
                
                      __bucket_type*
        6300 ->       _M_allocate_buckets(size_type __n)
                      {
                	if (__builtin_expect(__n == 1, false))
                	  {
                	    _M_single_bucket = nullptr;
                	    return &_M_single_bucket;
                	  }
                
                	return __hashtable_alloc::_M_allocate_buckets(__n);
                      }
                
                      void
        7200 ->       _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)
                      {
                	if (_M_uses_single_bucket(__bkts))
                	  return;
                
                	__hashtable_alloc::_M_deallocate_buckets(__bkts, __n);
                      }
                
                      void
        7200 ->       _M_deallocate_buckets()
                      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
                
                      // Gets bucket begin, deals with the fact that non-empty buckets contain
                      // their before begin node.
                      __node_type*
                      _M_bucket_begin(size_type __bkt) const;
                
                      __node_type*
        8100 ->       _M_begin() const
                      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }
                
                      // Assign *this using another _Hashtable instance. Either elements
                      // are copy or move depends on the _NodeGenerator.
                      template<typename _Ht, typename _NodeGenerator>
                	void
                	_M_assign_elements(_Ht&&, const _NodeGenerator&);
                
                      template<typename _NodeGenerator>
                	void
                	_M_assign(const _Hashtable&, const _NodeGenerator&);
                
                      void
                      _M_move_assign(_Hashtable&&, std::true_type);
                
                      void
                      _M_move_assign(_Hashtable&&, std::false_type);
                
                      void
                      _M_reset() noexcept;
                
                      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,
                		 const _Equal& __eq, const _ExtractKey& __exk,
                		 const allocator_type& __a)
                	: __hashtable_base(__exk, __h1, __h2, __h, __eq),
                	  __hashtable_alloc(__node_alloc_type(__a))
                      { }
                
                      template<bool _No_realloc = true>
                	static constexpr bool
                	_S_nothrow_move()
                	{
                #if __cplusplus <= 201402L
                	  return __and_<__bool_constant<_No_realloc>,
                			is_nothrow_copy_constructible<_H1>,
                			is_nothrow_copy_constructible<_Equal>>::value;
                #else
                	  if constexpr (_No_realloc)
                	    if constexpr (is_nothrow_copy_constructible<_H1>())
                	      return is_nothrow_copy_constructible<_Equal>();
                	  return false;
                #endif
                	}
                
                      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
                		 true_type /* alloc always equal */)
                	noexcept(_S_nothrow_move());
                
                      _Hashtable(_Hashtable&&, __node_alloc_type&&,
                		 false_type /* alloc always equal */);
                
                
                    public:
                      // Constructor, destructor, assignment, swap
         900 ->       _Hashtable() = default;
                      _Hashtable(size_type __bucket_hint,
                		 const _H1&, const _H2&, const _Hash&,
                		 const _Equal&, const _ExtractKey&,
                		 const allocator_type&);
                
                      template<typename _InputIterator>
                	_Hashtable(_InputIterator __first, _InputIterator __last,
                		   size_type __bucket_hint,
                		   const _H1&, const _H2&, const _Hash&,
                		   const _Equal&, const _ExtractKey&,
                		   const allocator_type&);
                
                      _Hashtable(const _Hashtable&);
                
                      _Hashtable(_Hashtable&& __ht)
                	noexcept(_S_nothrow_move())
                      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
                		   true_type{})
                      { }
                
                      _Hashtable(const _Hashtable&, const allocator_type&);
                
                      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
                	noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
                      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
                		   typename __node_alloc_traits::is_always_equal{})
                      { }
                
                      // Use delegating constructors.
                      explicit
                      _Hashtable(const allocator_type& __a)
                	: __hashtable_alloc(__node_alloc_type(__a))
                      { }
                
                      explicit
                      _Hashtable(size_type __n,
                		 const _H1& __hf = _H1(),
                		 const key_equal& __eql = key_equal(),
                		 const allocator_type& __a = allocator_type())
                      : _Hashtable(__n, __hf, _H2(), _Hash(), __eql,
                		   __key_extract(), __a)
                      { }
                
                      template<typename _InputIterator>
                	_Hashtable(_InputIterator __f, _InputIterator __l,
                		   size_type __n = 0,
                		   const _H1& __hf = _H1(),
                		   const key_equal& __eql = key_equal(),
                		   const allocator_type& __a = allocator_type())
                	: _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql,
                		     __key_extract(), __a)
                	{ }
                
                      _Hashtable(initializer_list<value_type> __l,
                		 size_type __n = 0,
                		 const _H1& __hf = _H1(),
                		 const key_equal& __eql = key_equal(),
                		 const allocator_type& __a = allocator_type())
                      : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql,
                		   __key_extract(), __a)
                      { }
                
                      _Hashtable&
                      operator=(const _Hashtable& __ht);
                
                      _Hashtable&
                      operator=(_Hashtable&& __ht)
                      noexcept(__node_alloc_traits::_S_nothrow_move()
                	       && is_nothrow_move_assignable<_H1>::value
                	       && is_nothrow_move_assignable<_Equal>::value)
                      {
                        constexpr bool __move_storage =
                	  __node_alloc_traits::_S_propagate_on_move_assign()
                	  || __node_alloc_traits::_S_always_equal();
                	_M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
                	return *this;
                      }
                
                      _Hashtable&
                      operator=(initializer_list<value_type> __l)
                      {
                	__reuse_or_alloc_node_type __roan(_M_begin(), *this);
                	_M_before_begin._M_nxt = nullptr;
                	clear();
                	this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());
                	return *this;
                      }
                
                      ~_Hashtable() noexcept;
                
                      void
                      swap(_Hashtable&)
                      noexcept(__and_<__is_nothrow_swappable<_H1>,
                	                  __is_nothrow_swappable<_Equal>>::value);
                
                      // Basic container operations
                      iterator
         900 ->       begin() noexcept
                      { return iterator(_M_begin()); }
                
                      const_iterator
                      begin() const noexcept
                      { return const_iterator(_M_begin()); }
                
                      iterator
         900 ->       end() noexcept
                      { return iterator(nullptr); }
                
                      const_iterator
                      end() const noexcept
                      { return const_iterator(nullptr); }
                
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(_M_begin()); }
                
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(nullptr); }
                
                      size_type
                      size() const noexcept
                      { return _M_element_count; }
                
                      _GLIBCXX_NODISCARD bool
                      empty() const noexcept
                      { return size() == 0; }
                
                      allocator_type
                      get_allocator() const noexcept
                      { return allocator_type(this->_M_node_allocator()); }
                
                      size_type
                      max_size() const noexcept
                      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }
                
                      // Observers
                      key_equal
                      key_eq() const
                      { return this->_M_eq(); }
                
                      // hash_function, if present, comes from _Hash_code_base.
                
                      // Bucket operations
                      size_type
                      bucket_count() const noexcept
                      { return _M_bucket_count; }
                
                      size_type
                      max_bucket_count() const noexcept
                      { return max_size(); }
                
                      size_type
                      bucket_size(size_type __n) const
                      { return std::distance(begin(__n), end(__n)); }
                
                      size_type
                      bucket(const key_type& __k) const
                      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }
                
                      local_iterator
                      begin(size_type __n)
                      {
                	return local_iterator(*this, _M_bucket_begin(__n),
                			      __n, _M_bucket_count);
                      }
                
                      local_iterator
                      end(size_type __n)
                      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }
                
                      const_local_iterator
                      begin(size_type __n) const
                      {
                	return const_local_iterator(*this, _M_bucket_begin(__n),
                				    __n, _M_bucket_count);
                      }
                
                      const_local_iterator
                      end(size_type __n) const
                      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }
                
                      // DR 691.
                      const_local_iterator
                      cbegin(size_type __n) const
                      {
                	return const_local_iterator(*this, _M_bucket_begin(__n),
                				    __n, _M_bucket_count);
                      }
                
                      const_local_iterator
                      cend(size_type __n) const
                      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }
                
                      float
                      load_factor() const noexcept
                      {
                	return static_cast<float>(size()) / static_cast<float>(bucket_count());
                      }
                
                      // max_load_factor, if present, comes from _Rehash_base.
                
                      // Generalization of max_load_factor.  Extension, not found in
                      // TR1.  Only useful if _RehashPolicy is something other than
                      // the default.
                      const _RehashPolicy&
                      __rehash_policy() const
                      { return _M_rehash_policy; }
                
                      void
                      __rehash_policy(const _RehashPolicy& __pol)
                      { _M_rehash_policy = __pol; }
                
                      // Lookup.
                      iterator
                      find(const key_type& __k);
                
                      const_iterator
                      find(const key_type& __k) const;
                
                      size_type
                      count(const key_type& __k) const;
                
                      std::pair<iterator, iterator>
                      equal_range(const key_type& __k);
                
                      std::pair<const_iterator, const_iterator>
                      equal_range(const key_type& __k) const;
                
                    protected:
                      // Bucket index computation helpers.
                      size_type
      617129 ->       _M_bucket_index(__node_type* __n) const noexcept
                      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
                
                      size_type
      621000 ->       _M_bucket_index(const key_type& __k, __hash_code __c) const
                      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }
                
                      // Find and insert helper functions and types
                      // Find the node before the one matching the criteria.
                      __node_base*
                      _M_find_before_node(size_type, const key_type&, __hash_code) const;
                
                      __node_type*
      614700 ->       _M_find_node(size_type __bkt, const key_type& __key,
                		   __hash_code __c) const
                      {
                	__node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
                	if (__before_n)
                	  return static_cast<__node_type*>(__before_n->_M_nxt);
                	return nullptr;
                      }
                
                      // Insert a node at the beginning of a bucket.
                      void
                      _M_insert_bucket_begin(size_type, __node_type*);
                
                      // Remove the bucket first node
                      void
                      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
                			     size_type __next_bkt);
                
                      // Get the node before __n in the bucket __bkt
                      __node_base*
                      _M_get_previous_node(size_type __bkt, __node_base* __n);
                
                      // Insert node with hash code __code, in bucket bkt if no rehash (assumes
                      // no element with its key already present). Take ownership of the node,
                      // deallocate it on exception.
                      iterator
                      _M_insert_unique_node(size_type __bkt, __hash_code __code,
                			    __node_type* __n, size_type __n_elt = 1);
                
                      // Insert node with hash code __code. Take ownership of the node,
                      // deallocate it on exception.
                      iterator
                      _M_insert_multi_node(__node_type* __hint,
                			   __hash_code __code, __node_type* __n);
                
                      template<typename... _Args>
                	std::pair<iterator, bool>
                	_M_emplace(std::true_type, _Args&&... __args);
                
                      template<typename... _Args>
                	iterator
                	_M_emplace(std::false_type __uk, _Args&&... __args)
                	{ return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }
                
                      // Emplace with hint, useless when keys are unique.
                      template<typename... _Args>
                	iterator
                	_M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)
                	{ return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }
                
                      template<typename... _Args>
                	iterator
                	_M_emplace(const_iterator, std::false_type, _Args&&... __args);
                
                      template<typename _Arg, typename _NodeGenerator>
                	std::pair<iterator, bool>
                	_M_insert(_Arg&&, const _NodeGenerator&, true_type, size_type = 1);
                
                      template<typename _Arg, typename _NodeGenerator>
                	iterator
                	_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
                		  false_type __uk)
                	{
                	  return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
                			   __uk);
                	}
                
                      // Insert with hint, not used when keys are unique.
                      template<typename _Arg, typename _NodeGenerator>
                	iterator
                	_M_insert(const_iterator, _Arg&& __arg,
                		  const _NodeGenerator& __node_gen, true_type __uk)
                	{
                	  return
                	    _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
                	}
                
                      // Insert with hint when keys are not unique.
                      template<typename _Arg, typename _NodeGenerator>
                	iterator
                	_M_insert(const_iterator, _Arg&&,
                		  const _NodeGenerator&, false_type);
                
                      size_type
                      _M_erase(std::true_type, const key_type&);
                
                      size_type
                      _M_erase(std::false_type, const key_type&);
                
                      iterator
                      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);
                
                    public:
                      // Emplace
                      template<typename... _Args>
                	__ireturn_type
                	emplace(_Args&&... __args)
                	{ return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }
                
                      template<typename... _Args>
                	iterator
                	emplace_hint(const_iterator __hint, _Args&&... __args)
                	{
                	  return _M_emplace(__hint, __unique_keys(),
                			    std::forward<_Args>(__args)...);
                	}
                
                      // Insert member functions via inheritance.
                
                      // Erase
                      iterator
                      erase(const_iterator);
                
                      // LWG 2059.
                      iterator
                      erase(iterator __it)
                      { return erase(const_iterator(__it)); }
                
                      size_type
                      erase(const key_type& __k)
                      { return _M_erase(__unique_keys(), __k); }
                
                      iterator
                      erase(const_iterator, const_iterator);
                
                      void
                      clear() noexcept;
                
                      // Set number of buckets to be appropriate for container of n element.
                      void rehash(size_type __n);
                
                      // DR 1189.
                      // reserve, if present, comes from _Rehash_base.
                
                #if __cplusplus > 201402L
                      /// Re-insert an extracted node into a container with unique keys.
                      insert_return_type
                      _M_reinsert_node(node_type&& __nh)
                      {
                	insert_return_type __ret;
                	if (__nh.empty())
                	  __ret.position = end();
                	else
                	  {
                	    __glibcxx_assert(get_allocator() == __nh.get_allocator());
                
                	    const key_type& __k = __nh._M_key();
                	    __hash_code __code = this->_M_hash_code(__k);
                	    size_type __bkt = _M_bucket_index(__k, __code);
                	    if (__node_type* __n = _M_find_node(__bkt, __k, __code))
                	      {
                		__ret.node = std::move(__nh);
                		__ret.position = iterator(__n);
                		__ret.inserted = false;
                	      }
                	    else
                	      {
                		__ret.position
                		  = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);
                		__nh._M_ptr = nullptr;
                		__ret.inserted = true;
                	      }
                	  }
                	return __ret;
                      }
                
                      /// Re-insert an extracted node into a container with equivalent keys.
                      iterator
                      _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)
                      {
                	iterator __ret;
                	if (__nh.empty())
                	  __ret = end();
                	else
                	  {
                	    __glibcxx_assert(get_allocator() == __nh.get_allocator());
                
                	    auto __code = this->_M_hash_code(__nh._M_key());
                	    auto __node = std::exchange(__nh._M_ptr, nullptr);
                	    // FIXME: this deallocates the node on exception.
                	    __ret = _M_insert_multi_node(__hint._M_cur, __code, __node);
                	  }
                	return __ret;
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const_iterator __pos)
                      {
                	__node_type* __n = __pos._M_cur;
                	size_t __bkt = _M_bucket_index(__n);
                
                	// Look for previous node to unlink it from the erased one, this
                	// is why we need buckets to contain the before begin to make
                	// this search fast.
                	__node_base* __prev_n = _M_get_previous_node(__bkt, __n);
                
                	if (__prev_n == _M_buckets[__bkt])
                	  _M_remove_bucket_begin(__bkt, __n->_M_next(),
                	     __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
                	else if (__n->_M_nxt)
                	  {
                	    size_type __next_bkt = _M_bucket_index(__n->_M_next());
                	    if (__next_bkt != __bkt)
                	      _M_buckets[__next_bkt] = __prev_n;
                	  }
                
                	__prev_n->_M_nxt = __n->_M_nxt;
                	__n->_M_nxt = nullptr;
                	--_M_element_count;
                	return { __n, this->_M_node_allocator() };
                      }
                
                      /// Extract a node.
                      node_type
                      extract(const _Key& __k)
                      {
                	node_type __nh;
                	auto __pos = find(__k);
                	if (__pos != end())
                	  __nh = extract(const_iterator(__pos));
                	return __nh;
                      }
                
                      /// Merge from a compatible container into one with unique keys.
                      template<typename _Compatible_Hashtable>
                	void
                	_M_merge_unique(_Compatible_Hashtable& __src) noexcept
                	{
                	  static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
                	      node_type>, "Node types are compatible");
                	  __glibcxx_assert(get_allocator() == __src.get_allocator());
                
                	  auto __n_elt = __src.size();
                	  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
                	    {
                	      auto __pos = __i++;
                	      const key_type& __k = this->_M_extract()(__pos._M_cur->_M_v());
                	      __hash_code __code = this->_M_hash_code(__k);
                	      size_type __bkt = _M_bucket_index(__k, __code);
                	      if (_M_find_node(__bkt, __k, __code) == nullptr)
                		{
                		  auto __nh = __src.extract(__pos);
                		  _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);
                		  __nh._M_ptr = nullptr;
                		  __n_elt = 1;
                		}
                	      else if (__n_elt != 1)
                		--__n_elt;
                	    }
                	}
                
                      /// Merge from a compatible container into one with equivalent keys.
                      template<typename _Compatible_Hashtable>
                	void
                	_M_merge_multi(_Compatible_Hashtable& __src) noexcept
                	{
                	  static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
                	      node_type>, "Node types are compatible");
                	  __glibcxx_assert(get_allocator() == __src.get_allocator());
                
                	  this->reserve(size() + __src.size());
                	  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
                	    _M_reinsert_node_multi(cend(), __src.extract(__i++));
                	}
                #endif // C++17
                
                    private:
                      // Helper rehash method used when keys are unique.
                      void _M_rehash_aux(size_type __n, std::true_type);
                
                      // Helper rehash method used when keys can be non-unique.
                      void _M_rehash_aux(size_type __n, std::false_type);
                
                      // Unconditionally change size of bucket array to n, restore
                      // hash policy state to __state on exception.
                      void _M_rehash(size_type __n, const __rehash_state& __state);
                    };
                
                
                  // Definitions of class template _Hashtable's out-of-line member functions.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_bucket_begin(size_type __bkt) const
                    -> __node_type*
                    {
                      __node_base* __n = _M_buckets[__bkt];
                      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _Hashtable(size_type __bucket_hint,
                	       const _H1& __h1, const _H2& __h2, const _Hash& __h,
                	       const _Equal& __eq, const _ExtractKey& __exk,
                	       const allocator_type& __a)
                      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
                    {
                      auto __bkt = _M_rehash_policy._M_next_bkt(__bucket_hint);
                      if (__bkt > _M_bucket_count)
                	{
                	  _M_buckets = _M_allocate_buckets(__bkt);
                	  _M_bucket_count = __bkt;
                	}
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename _InputIterator>
                      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _Hashtable(_InputIterator __f, _InputIterator __l,
                		 size_type __bucket_hint,
                		 const _H1& __h1, const _H2& __h2, const _Hash& __h,
                		 const _Equal& __eq, const _ExtractKey& __exk,
                		 const allocator_type& __a)
                	: _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
                      {
                	auto __nb_elems = __detail::__distance_fw(__f, __l);
                	auto __bkt_count =
                	  _M_rehash_policy._M_next_bkt(
                	    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
                		     __bucket_hint));
                
                	if (__bkt_count > _M_bucket_count)
                	  {
                	    _M_buckets = _M_allocate_buckets(__bkt_count);
                	    _M_bucket_count = __bkt_count;
                	  }
                
                	for (; __f != __l; ++__f)
                	  this->insert(*__f);
                      }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    operator=(const _Hashtable& __ht)
                    -> _Hashtable&
                    {
                      if (&__ht == this)
                	return *this;
                
                      if (__node_alloc_traits::_S_propagate_on_copy_assign())
                	{
                	  auto& __this_alloc = this->_M_node_allocator();
                	  auto& __that_alloc = __ht._M_node_allocator();
                	  if (!__node_alloc_traits::_S_always_equal()
                	      && __this_alloc != __that_alloc)
                	    {
                	      // Replacement allocator cannot free existing storage.
                	      this->_M_deallocate_nodes(_M_begin());
                	      _M_before_begin._M_nxt = nullptr;
                	      _M_deallocate_buckets();
                	      _M_buckets = nullptr;
                	      std::__alloc_on_copy(__this_alloc, __that_alloc);
                	      __hashtable_base::operator=(__ht);
                	      _M_bucket_count = __ht._M_bucket_count;
                	      _M_element_count = __ht._M_element_count;
                	      _M_rehash_policy = __ht._M_rehash_policy;
                	      __try
                		{
                		  _M_assign(__ht,
                			    [this](const __node_type* __n)
                			    { return this->_M_allocate_node(__n->_M_v()); });
                		}
                	      __catch(...)
                		{
                		  // _M_assign took care of deallocating all memory. Now we
                		  // must make sure this instance remains in a usable state.
                		  _M_reset();
                		  __throw_exception_again;
                		}
                	      return *this;
                	    }
                	  std::__alloc_on_copy(__this_alloc, __that_alloc);
                	}
                
                      // Reuse allocated buckets and nodes.
                      _M_assign_elements(__ht,
                	[](const __reuse_or_alloc_node_type& __roan, const __node_type* __n)
                	{ return __roan(__n->_M_v()); });
                      return *this;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename _Ht, typename _NodeGenerator>
                      void
                      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _M_assign_elements(_Ht&& __ht, const _NodeGenerator& __node_gen)
                      {
                	__bucket_type* __former_buckets = nullptr;
                	std::size_t __former_bucket_count = _M_bucket_count;
                	const __rehash_state& __former_state = _M_rehash_policy._M_state();
                
                	if (_M_bucket_count != __ht._M_bucket_count)
                	  {
                	    __former_buckets = _M_buckets;
                	    _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
                	    _M_bucket_count = __ht._M_bucket_count;
                	  }
                	else
                	  __builtin_memset(_M_buckets, 0,
                			   _M_bucket_count * sizeof(__bucket_type));
                
                	__try
                	  {
                	    __hashtable_base::operator=(std::forward<_Ht>(__ht));
                	    _M_element_count = __ht._M_element_count;
                	    _M_rehash_policy = __ht._M_rehash_policy;
                	    __reuse_or_alloc_node_type __roan(_M_begin(), *this);
                	    _M_before_begin._M_nxt = nullptr;
                	    _M_assign(__ht,
                		      [&__node_gen, &__roan](__node_type* __n)
                		      { return __node_gen(__roan, __n); });
                	    if (__former_buckets)
                	      _M_deallocate_buckets(__former_buckets, __former_bucket_count);
                	  }
                	__catch(...)
                	  {
                	    if (__former_buckets)
                	      {
                		// Restore previous buckets.
                		_M_deallocate_buckets();
                		_M_rehash_policy._M_reset(__former_state);
                		_M_buckets = __former_buckets;
                		_M_bucket_count = __former_bucket_count;
                	      }
                	    __builtin_memset(_M_buckets, 0,
                			     _M_bucket_count * sizeof(__bucket_type));
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename _NodeGenerator>
                      void
                      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)
                      {
                	__bucket_type* __buckets = nullptr;
                	if (!_M_buckets)
                	  _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);
                
                	__try
                	  {
                	    if (!__ht._M_before_begin._M_nxt)
                	      return;
                
                	    // First deal with the special first node pointed to by
                	    // _M_before_begin.
                	    __node_type* __ht_n = __ht._M_begin();
                	    __node_type* __this_n = __node_gen(__ht_n);
                	    this->_M_copy_code(__this_n, __ht_n);
                	    _M_before_begin._M_nxt = __this_n;
                	    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;
                
                	    // Then deal with other nodes.
                	    __node_base* __prev_n = __this_n;
                	    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
                	      {
                		__this_n = __node_gen(__ht_n);
                		__prev_n->_M_nxt = __this_n;
                		this->_M_copy_code(__this_n, __ht_n);
                		size_type __bkt = _M_bucket_index(__this_n);
                		if (!_M_buckets[__bkt])
                		  _M_buckets[__bkt] = __prev_n;
                		__prev_n = __this_n;
                	      }
                	  }
                	__catch(...)
                	  {
                	    clear();
                	    if (__buckets)
                	      _M_deallocate_buckets();
                	    __throw_exception_again;
                	  }
                      }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_reset() noexcept
                    {
                      _M_rehash_policy._M_reset();
                      _M_bucket_count = 1;
                      _M_single_bucket = nullptr;
                      _M_buckets = &_M_single_bucket;
                      _M_before_begin._M_nxt = nullptr;
                      _M_element_count = 0;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_move_assign(_Hashtable&& __ht, std::true_type)
                    {
                      this->_M_deallocate_nodes(_M_begin());
                      _M_deallocate_buckets();
                      __hashtable_base::operator=(std::move(__ht));
                      _M_rehash_policy = __ht._M_rehash_policy;
                      if (!__ht._M_uses_single_bucket())
                	_M_buckets = __ht._M_buckets;
                      else
                	{
                	  _M_buckets = &_M_single_bucket;
                	  _M_single_bucket = __ht._M_single_bucket;
                	}
                      _M_bucket_count = __ht._M_bucket_count;
                      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
                      _M_element_count = __ht._M_element_count;
                      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());
                
                      // Fix buckets containing the _M_before_begin pointers that can't be
                      // moved.
                      if (_M_begin())
                	_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
                      __ht._M_reset();
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_move_assign(_Hashtable&& __ht, std::false_type)
                    {
                      if (__ht._M_node_allocator() == this->_M_node_allocator())
                	_M_move_assign(std::move(__ht), std::true_type());
                      else
                	{
                	  // Can't move memory, move elements then.
                	  _M_assign_elements(std::move(__ht),
                		[](const __reuse_or_alloc_node_type& __roan, __node_type* __n)
                		{ return __roan(std::move_if_noexcept(__n->_M_v())); });
                	  __ht.clear();
                	}
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _Hashtable(const _Hashtable& __ht)
                    : __hashtable_base(__ht),
                      __map_base(__ht),
                      __rehash_base(__ht),
                      __hashtable_alloc(
                	__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
                      _M_buckets(nullptr),
                      _M_bucket_count(__ht._M_bucket_count),
                      _M_element_count(__ht._M_element_count),
                      _M_rehash_policy(__ht._M_rehash_policy)
                    {
                      _M_assign(__ht,
                		[this](const __node_type* __n)
                		{ return this->_M_allocate_node(__n->_M_v()); });
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
                	       true_type /* alloc always equal */)
                    noexcept(_S_nothrow_move())
                    : __hashtable_base(__ht),
                      __map_base(__ht),
                      __rehash_base(__ht),
                      __hashtable_alloc(std::move(__a)),
                      _M_buckets(__ht._M_buckets),
                      _M_bucket_count(__ht._M_bucket_count),
                      _M_before_begin(__ht._M_before_begin._M_nxt),
                      _M_element_count(__ht._M_element_count),
                      _M_rehash_policy(__ht._M_rehash_policy)
                    {
                      // Update buckets if __ht is using its single bucket.
                      if (__ht._M_uses_single_bucket())
                	{
                	  _M_buckets = &_M_single_bucket;
                	  _M_single_bucket = __ht._M_single_bucket;
                	}
                
                      // Update, if necessary, bucket pointing to before begin that hasn't
                      // moved.
                      if (_M_begin())
                	_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
                
                      __ht._M_reset();
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
                    : __hashtable_base(__ht),
                      __map_base(__ht),
                      __rehash_base(__ht),
                      __hashtable_alloc(__node_alloc_type(__a)),
                      _M_buckets(),
                      _M_bucket_count(__ht._M_bucket_count),
                      _M_element_count(__ht._M_element_count),
                      _M_rehash_policy(__ht._M_rehash_policy)
                    {
                      _M_assign(__ht,
                		[this](const __node_type* __n)
                		{ return this->_M_allocate_node(__n->_M_v()); });
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
                	       false_type /* alloc always equal */)
                    : __hashtable_base(__ht),
                      __map_base(__ht),
                      __rehash_base(__ht),
                      __hashtable_alloc(std::move(__a)),
                      _M_buckets(nullptr),
                      _M_bucket_count(__ht._M_bucket_count),
                      _M_element_count(__ht._M_element_count),
                      _M_rehash_policy(__ht._M_rehash_policy)
                    {
                      if (__ht._M_node_allocator() == this->_M_node_allocator())
                	{
                	  if (__ht._M_uses_single_bucket())
                	    {
                	      _M_buckets = &_M_single_bucket;
                	      _M_single_bucket = __ht._M_single_bucket;
                	    }
                	  else
                	    _M_buckets = __ht._M_buckets;
                
                	  _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
                	  // Update, if necessary, bucket pointing to before begin that hasn't
                	  // moved.
                	  if (_M_begin())
                	    _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
                	  __ht._M_reset();
                	}
                      else
                	{
                	  _M_assign(__ht,
                		    [this](__node_type* __n)
                		    {
                		      return this->_M_allocate_node(
                					std::move_if_noexcept(__n->_M_v()));
                		    });
                	  __ht.clear();
                	}
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
         900 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    ~_Hashtable() noexcept
                    {
                      clear();
                      _M_deallocate_buckets();
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    swap(_Hashtable& __x)
                    noexcept(__and_<__is_nothrow_swappable<_H1>,
                	                __is_nothrow_swappable<_Equal>>::value)
                    {
                      // The only base class with member variables is hash_code_base.
                      // We define _Hash_code_base::_M_swap because different
                      // specializations have different members.
                      this->_M_swap(__x);
                
                      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
                      std::swap(_M_rehash_policy, __x._M_rehash_policy);
                
                      // Deal properly with potentially moved instances.
                      if (this->_M_uses_single_bucket())
                	{
                	  if (!__x._M_uses_single_bucket())
                	    {
                	      _M_buckets = __x._M_buckets;
                	      __x._M_buckets = &__x._M_single_bucket;
                	    }
                	}
                      else if (__x._M_uses_single_bucket())
                	{
                	  __x._M_buckets = _M_buckets;
                	  _M_buckets = &_M_single_bucket;
                	}	
                      else
                	std::swap(_M_buckets, __x._M_buckets);
                
                      std::swap(_M_bucket_count, __x._M_bucket_count);
                      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
                      std::swap(_M_element_count, __x._M_element_count);
                      std::swap(_M_single_bucket, __x._M_single_bucket);
                
                      // Fix buckets containing the _M_before_begin pointers that can't be
                      // swapped.
                      if (_M_begin())
                	_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
                
                      if (__x._M_begin())
                	__x._M_buckets[__x._M_bucket_index(__x._M_begin())]
                	  = &__x._M_before_begin;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    find(const key_type& __k)
                    -> iterator
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __n = _M_bucket_index(__k, __code);
                      __node_type* __p = _M_find_node(__n, __k, __code);
                      return __p ? iterator(__p) : end();
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    find(const key_type& __k) const
                    -> const_iterator
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __n = _M_bucket_index(__k, __code);
                      __node_type* __p = _M_find_node(__n, __k, __code);
                      return __p ? const_iterator(__p) : end();
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    count(const key_type& __k) const
                    -> size_type
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __n = _M_bucket_index(__k, __code);
                      __node_type* __p = _M_bucket_begin(__n);
                      if (!__p)
                	return 0;
                
                      std::size_t __result = 0;
                      for (;; __p = __p->_M_next())
                	{
                	  if (this->_M_equals(__k, __code, __p))
                	    ++__result;
                	  else if (__result)
                	    // All equivalent values are next to each other, if we
                	    // found a non-equivalent value after an equivalent one it
                	    // means that we won't find any new equivalent value.
                	    break;
                	  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
                	    break;
                	}
                      return __result;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    equal_range(const key_type& __k)
                    -> pair<iterator, iterator>
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __n = _M_bucket_index(__k, __code);
                      __node_type* __p = _M_find_node(__n, __k, __code);
                
                      if (__p)
                	{
                	  __node_type* __p1 = __p->_M_next();
                	  while (__p1 && _M_bucket_index(__p1) == __n
                		 && this->_M_equals(__k, __code, __p1))
                	    __p1 = __p1->_M_next();
                
                	  return std::make_pair(iterator(__p), iterator(__p1));
                	}
                      else
                	return std::make_pair(end(), end());
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    equal_range(const key_type& __k) const
                    -> pair<const_iterator, const_iterator>
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __n = _M_bucket_index(__k, __code);
                      __node_type* __p = _M_find_node(__n, __k, __code);
                
                      if (__p)
                	{
                	  __node_type* __p1 = __p->_M_next();
                	  while (__p1 && _M_bucket_index(__p1) == __n
                		 && this->_M_equals(__k, __code, __p1))
                	    __p1 = __p1->_M_next();
                
                	  return std::make_pair(const_iterator(__p), const_iterator(__p1));
                	}
                      else
                	return std::make_pair(end(), end());
                    }
                
                  // Find the node whose key compares equal to k in the bucket n.
                  // Return nullptr if no node is found.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
      614700 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_find_before_node(size_type __n, const key_type& __k,
                			__hash_code __code) const
                    -> __node_base*
                    {
                      __node_base* __prev_p = _M_buckets[__n];
                      if (!__prev_p)
                	return nullptr;
                
                      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
                	   __p = __p->_M_next())
                	{
                	  if (this->_M_equals(__k, __code, __p))
                	    return __prev_p;
                
                	  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
                	    break;
                	  __prev_p = __p;
                	}
                      return nullptr;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
      614700 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
                    {
                      if (_M_buckets[__bkt])
                	{
                	  // Bucket is not empty, we just need to insert the new node
                	  // after the bucket before begin.
                	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
                	  _M_buckets[__bkt]->_M_nxt = __node;
                	}
                      else
                	{
                	  // The bucket is empty, the new node is inserted at the
                	  // beginning of the singly-linked list and the bucket will
                	  // contain _M_before_begin pointer.
                	  __node->_M_nxt = _M_before_begin._M_nxt;
                	  _M_before_begin._M_nxt = __node;
                	  if (__node->_M_nxt)
                	    // We must update former begin bucket that is pointing to
                	    // _M_before_begin.
                	    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
                	  _M_buckets[__bkt] = &_M_before_begin;
                	}
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
                			   size_type __next_bkt)
                    {
                      if (!__next || __next_bkt != __bkt)
                	{
                	  // Bucket is now empty
                	  // First update next bucket if any
                	  if (__next)
                	    _M_buckets[__next_bkt] = _M_buckets[__bkt];
                
                	  // Second update before begin node if necessary
                	  if (&_M_before_begin == _M_buckets[__bkt])
                	    _M_before_begin._M_nxt = __next;
                	  _M_buckets[__bkt] = nullptr;
                	}
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_get_previous_node(size_type __bkt, __node_base* __n)
                    -> __node_base*
                    {
                      __node_base* __prev_n = _M_buckets[__bkt];
                      while (__prev_n->_M_nxt != __n)
                	__prev_n = __prev_n->_M_nxt;
                      return __prev_n;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename... _Args>
                      auto
                      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _M_emplace(std::true_type, _Args&&... __args)
                      -> pair<iterator, bool>
                      {
                	// First build the node to get access to the hash code
                	__node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);
                	const key_type& __k = this->_M_extract()(__node->_M_v());
                	__hash_code __code;
                	__try
                	  {
                	    __code = this->_M_hash_code(__k);
                	  }
                	__catch(...)
                	  {
                	    this->_M_deallocate_node(__node);
                	    __throw_exception_again;
                	  }
                
                	size_type __bkt = _M_bucket_index(__k, __code);
                	if (__node_type* __p = _M_find_node(__bkt, __k, __code))
                	  {
                	    // There is already an equivalent node, no insertion
                	    this->_M_deallocate_node(__node);
                	    return std::make_pair(iterator(__p), false);
                	  }
                
                	// Insert the node
                	return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
                			      true);
                      }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename... _Args>
                      auto
                      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)
                      -> iterator
                      {
                	// First build the node to get its hash code.
                	__node_type* __node =
                	  this->_M_allocate_node(std::forward<_Args>(__args)...);
                
                	__hash_code __code;
                	__try
                	  {
                	    __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));
                	  }
                	__catch(...)
                	  {
                	    this->_M_deallocate_node(__node);
                	    __throw_exception_again;
                	  }
                
                	return _M_insert_multi_node(__hint._M_cur, __code, __node);
                      }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
      614700 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_insert_unique_node(size_type __bkt, __hash_code __code,
                			  __node_type* __node, size_type __n_elt)
                    -> iterator
                    {
                      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
                      std::pair<bool, std::size_t> __do_rehash
                	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
                					  __n_elt);
                
                      __try
                	{
                	  if (__do_rehash.first)
                	    {
                	      _M_rehash(__do_rehash.second, __saved_state);
                	      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);
                	    }
                
                	  this->_M_store_code(__node, __code);
                
                	  // Always insert at the beginning of the bucket.
                	  _M_insert_bucket_begin(__bkt, __node);
                	  ++_M_element_count;
                	  return iterator(__node);
                	}
                      __catch(...)
                	{
                	  this->_M_deallocate_node(__node);
                	  __throw_exception_again;
                	}
                    }
                
                  // Insert node, in bucket bkt if no rehash (assumes no element with its key
                  // already present). Take ownership of the node, deallocate it on exception.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_insert_multi_node(__node_type* __hint, __hash_code __code,
                			 __node_type* __node)
                    -> iterator
                    {
                      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
                      std::pair<bool, std::size_t> __do_rehash
                	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);
                
                      __try
                	{
                	  if (__do_rehash.first)
                	    _M_rehash(__do_rehash.second, __saved_state);
                
                	  this->_M_store_code(__node, __code);
                	  const key_type& __k = this->_M_extract()(__node->_M_v());
                	  size_type __bkt = _M_bucket_index(__k, __code);
                
                	  // Find the node before an equivalent one or use hint if it exists and
                	  // if it is equivalent.
                	  __node_base* __prev
                	    = __builtin_expect(__hint != nullptr, false)
                	      && this->_M_equals(__k, __code, __hint)
                		? __hint
                		: _M_find_before_node(__bkt, __k, __code);
                	  if (__prev)
                	    {
                	      // Insert after the node before the equivalent one.
                	      __node->_M_nxt = __prev->_M_nxt;
                	      __prev->_M_nxt = __node;
                	      if (__builtin_expect(__prev == __hint, false))
                	      	// hint might be the last bucket node, in this case we need to
                	      	// update next bucket.
                	      	if (__node->_M_nxt
                	      	    && !this->_M_equals(__k, __code, __node->_M_next()))
                	      	  {
                	      	    size_type __next_bkt = _M_bucket_index(__node->_M_next());
                	      	    if (__next_bkt != __bkt)
                	      	      _M_buckets[__next_bkt] = __node;
                	      	  }
                	    }
                	  else
                	    // The inserted node has no equivalent in the
                	    // hashtable. We must insert the new node at the
                	    // beginning of the bucket to preserve equivalent
                	    // elements' relative positions.
                	    _M_insert_bucket_begin(__bkt, __node);
                	  ++_M_element_count;
                	  return iterator(__node);
                	}
                      __catch(...)
                	{
                	  this->_M_deallocate_node(__node);
                	  __throw_exception_again;
                	}
                    }
                
                  // Insert v if no element with its key is already present.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename _Arg, typename _NodeGenerator>
                      auto
      614700 ->       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, true_type,
                		size_type __n_elt)
                      -> pair<iterator, bool>
                      {
                	const key_type& __k = this->_M_extract()(__v);
                	__hash_code __code = this->_M_hash_code(__k);
                	size_type __bkt = _M_bucket_index(__k, __code);
                
                	__node_type* __n = _M_find_node(__bkt, __k, __code);
                	if (__n)
                	  return std::make_pair(iterator(__n), false);
                
                	__n = __node_gen(std::forward<_Arg>(__v));
                	return { _M_insert_unique_node(__bkt, __code, __n, __n_elt), true };
                      }
                
                  // Insert v unconditionally.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    template<typename _Arg, typename _NodeGenerator>
                      auto
                      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                      _M_insert(const_iterator __hint, _Arg&& __v,
                		const _NodeGenerator& __node_gen, false_type)
                      -> iterator
                      {
                	// First compute the hash code so that we don't do anything if it
                	// throws.
                	__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));
                
                	// Second allocate new node so that we don't rehash if it throws.
                	__node_type* __node = __node_gen(std::forward<_Arg>(__v));
                
                	return _M_insert_multi_node(__hint._M_cur, __code, __node);
                      }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    erase(const_iterator __it)
                    -> iterator
                    {
                      __node_type* __n = __it._M_cur;
                      std::size_t __bkt = _M_bucket_index(__n);
                
                      // Look for previous node to unlink it from the erased one, this
                      // is why we need buckets to contain the before begin to make
                      // this search fast.
                      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
                      return _M_erase(__bkt, __prev_n, __n);
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
                    -> iterator
                    {
                      if (__prev_n == _M_buckets[__bkt])
                	_M_remove_bucket_begin(__bkt, __n->_M_next(),
                	   __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
                      else if (__n->_M_nxt)
                	{
                	  size_type __next_bkt = _M_bucket_index(__n->_M_next());
                	  if (__next_bkt != __bkt)
                	    _M_buckets[__next_bkt] = __prev_n;
                	}
                
                      __prev_n->_M_nxt = __n->_M_nxt;
                      iterator __result(__n->_M_next());
                      this->_M_deallocate_node(__n);
                      --_M_element_count;
                
                      return __result;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_erase(std::true_type, const key_type& __k)
                    -> size_type
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __bkt = _M_bucket_index(__k, __code);
                
                      // Look for the node before the first matching node.
                      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
                      if (!__prev_n)
                	return 0;
                
                      // We found a matching node, erase it.
                      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
                      _M_erase(__bkt, __prev_n, __n);
                      return 1;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_erase(std::false_type, const key_type& __k)
                    -> size_type
                    {
                      __hash_code __code = this->_M_hash_code(__k);
                      std::size_t __bkt = _M_bucket_index(__k, __code);
                
                      // Look for the node before the first matching node.
                      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
                      if (!__prev_n)
                	return 0;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 526. Is it undefined if a function in the standard changes
                      // in parameters?
                      // We use one loop to find all matching nodes and another to deallocate
                      // them so that the key stays valid during the first loop. It might be
                      // invalidated indirectly when destroying nodes.
                      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
                      __node_type* __n_last = __n;
                      std::size_t __n_last_bkt = __bkt;
                      do
                	{
                	  __n_last = __n_last->_M_next();
                	  if (!__n_last)
                	    break;
                	  __n_last_bkt = _M_bucket_index(__n_last);
                	}
                      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));
                
                      // Deallocate nodes.
                      size_type __result = 0;
                      do
                	{
                	  __node_type* __p = __n->_M_next();
                	  this->_M_deallocate_node(__n);
                	  __n = __p;
                	  ++__result;
                	  --_M_element_count;
                	}
                      while (__n != __n_last);
                
                      if (__prev_n == _M_buckets[__bkt])
                	_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
                      else if (__n_last && __n_last_bkt != __bkt)
                	_M_buckets[__n_last_bkt] = __prev_n;
                      __prev_n->_M_nxt = __n_last;
                      return __result;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    auto
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    erase(const_iterator __first, const_iterator __last)
                    -> iterator
                    {
                      __node_type* __n = __first._M_cur;
                      __node_type* __last_n = __last._M_cur;
                      if (__n == __last_n)
                	return iterator(__n);
                
                      std::size_t __bkt = _M_bucket_index(__n);
                
                      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
                      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
                      std::size_t __n_bkt = __bkt;
                      for (;;)
                	{
                	  do
                	    {
                	      __node_type* __tmp = __n;
                	      __n = __n->_M_next();
                	      this->_M_deallocate_node(__tmp);
                	      --_M_element_count;
                	      if (!__n)
                		break;
                	      __n_bkt = _M_bucket_index(__n);
                	    }
                	  while (__n != __last_n && __n_bkt == __bkt);
                	  if (__is_bucket_begin)
                	    _M_remove_bucket_begin(__bkt, __n, __n_bkt);
                	  if (__n == __last_n)
                	    break;
                	  __is_bucket_begin = true;
                	  __bkt = __n_bkt;
                	}
                
                      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
                	_M_buckets[__n_bkt] = __prev_n;
                      __prev_n->_M_nxt = __n;
                      return iterator(__n);
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
         900 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    clear() noexcept
                    {
                      this->_M_deallocate_nodes(_M_begin());
                      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
                      _M_element_count = 0;
                      _M_before_begin._M_nxt = nullptr;
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    rehash(size_type __n)
                    {
                      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
                      std::size_t __buckets
                	= std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
                		   __n);
                      __buckets = _M_rehash_policy._M_next_bkt(__buckets);
                
                      if (__buckets != _M_bucket_count)
                	_M_rehash(__buckets, __saved_state);
                      else
                	// No rehash, restore previous state to keep a consistent state.
                	_M_rehash_policy._M_reset(__saved_state);
                    }
                
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
        6300 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_rehash(size_type __n, const __rehash_state& __state)
                    {
                      __try
                	{
                	  _M_rehash_aux(__n, __unique_keys());
                	}
                      __catch(...)
                	{
                	  // A failure here means that buckets allocation failed.  We only
                	  // have to restore hash policy previous state.
                	  _M_rehash_policy._M_reset(__state);
                	  __throw_exception_again;
                	}
                    }
                
                  // Rehash when there is no equivalent elements.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
        6300 ->     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_rehash_aux(size_type __n, std::true_type)
                    {
                      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
                      __node_type* __p = _M_begin();
                      _M_before_begin._M_nxt = nullptr;
                      std::size_t __bbegin_bkt = 0;
                      while (__p)
                	{
                	  __node_type* __next = __p->_M_next();
                	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
                	  if (!__new_buckets[__bkt])
                	    {
                	      __p->_M_nxt = _M_before_begin._M_nxt;
                	      _M_before_begin._M_nxt = __p;
                	      __new_buckets[__bkt] = &_M_before_begin;
                	      if (__p->_M_nxt)
                		__new_buckets[__bbegin_bkt] = __p;
                	      __bbegin_bkt = __bkt;
                	    }
                	  else
                	    {
                	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
                	      __new_buckets[__bkt]->_M_nxt = __p;
                	    }
                	  __p = __next;
                	}
                
                      _M_deallocate_buckets();
                      _M_bucket_count = __n;
                      _M_buckets = __new_buckets;
                    }
                
                  // Rehash when there can be equivalent elements, preserve their relative
                  // order.
                  template<typename _Key, typename _Value,
                	   typename _Alloc, typename _ExtractKey, typename _Equal,
                	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                	   typename _Traits>
                    void
                    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                    _M_rehash_aux(size_type __n, std::false_type)
                    {
                      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
                
                      __node_type* __p = _M_begin();
                      _M_before_begin._M_nxt = nullptr;
                      std::size_t __bbegin_bkt = 0;
                      std::size_t __prev_bkt = 0;
                      __node_type* __prev_p = nullptr;
                      bool __check_bucket = false;
                
                      while (__p)
                	{
                	  __node_type* __next = __p->_M_next();
                	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
                
                	  if (__prev_p && __prev_bkt == __bkt)
                	    {
                	      // Previous insert was already in this bucket, we insert after
                	      // the previously inserted one to preserve equivalent elements
                	      // relative order.
                	      __p->_M_nxt = __prev_p->_M_nxt;
                	      __prev_p->_M_nxt = __p;
                
                	      // Inserting after a node in a bucket require to check that we
                	      // haven't change the bucket last node, in this case next
                	      // bucket containing its before begin node must be updated. We
                	      // schedule a check as soon as we move out of the sequence of
                	      // equivalent nodes to limit the number of checks.
                	      __check_bucket = true;
                	    }
                	  else
                	    {
                	      if (__check_bucket)
                		{
                		  // Check if we shall update the next bucket because of
                		  // insertions into __prev_bkt bucket.
                		  if (__prev_p->_M_nxt)
                		    {
                		      std::size_t __next_bkt
                			= __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
                							    __n);
                		      if (__next_bkt != __prev_bkt)
                			__new_buckets[__next_bkt] = __prev_p;
                		    }
                		  __check_bucket = false;
                		}
                
                	      if (!__new_buckets[__bkt])
                		{
                		  __p->_M_nxt = _M_before_begin._M_nxt;
                		  _M_before_begin._M_nxt = __p;
                		  __new_buckets[__bkt] = &_M_before_begin;
                		  if (__p->_M_nxt)
                		    __new_buckets[__bbegin_bkt] = __p;
                		  __bbegin_bkt = __bkt;
                		}
                	      else
                		{
                		  __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
                		  __new_buckets[__bkt]->_M_nxt = __p;
                		}
                	    }
                	  __prev_p = __p;
                	  __prev_bkt = __bkt;
                	  __p = __next;
                	}
                
                      if (__check_bucket && __prev_p->_M_nxt)
                	{
                	  std::size_t __next_bkt
                	    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
                	  if (__next_bkt != __prev_bkt)
                	    __new_buckets[__next_bkt] = __prev_p;
                	}
                
                      _M_deallocate_buckets();
                      _M_bucket_count = __n;
                      _M_buckets = __new_buckets;
                    }
                
                #if __cplusplus > 201402L
                  template<typename, typename, typename> class _Hash_merge_helper { };
                #endif // C++17
                
                #if __cpp_deduction_guides >= 201606
                  // Used to constrain deduction guides
                  template<typename _Hash>
                    using _RequireNotAllocatorOrIntegral
                      = __enable_if_t<!__or_<is_integral<_Hash>, __is_allocator<_Hash>>::value>;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // _HASHTABLE_H


Top 10 Lines:

     Line      Count

      675     621000
      671     617129
      684     614700
     1567     614700
     1595     614700
     1733     614700
     1838     614700
      383       8100
      342       7200
      365       7200

Execution Summary:

       19   Executable lines in this file
       19   Lines executed
   100.00   Percent of the file executed

  4364729   Total number of line executions
229722.58   Average executions per line


*** File /usr/include/c++/9/bits/ptr_traits.h:
                // Pointer Traits -*- C++ -*-
                
                // Copyright (C) 2011-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/ptr_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _PTR_TRAITS_H
                #define _PTR_TRAITS_H 1
                
                #if __cplusplus >= 201103L
                
                #include <bits/move.h>
                
                #if __cplusplus > 201703L
                #define __cpp_lib_constexpr_memory 201811L
                namespace __gnu_debug { struct _Safe_iterator_base; }
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  class __undefined;
                
                  // Given Template<T, ...> return T, otherwise invalid.
                  template<typename _Tp>
                    struct __get_first_arg
                    { using type = __undefined; };
                
                  template<template<typename, typename...> class _Template, typename _Tp,
                           typename... _Types>
                    struct __get_first_arg<_Template<_Tp, _Types...>>
                    { using type = _Tp; };
                
                  template<typename _Tp>
                    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;
                
                  // Given Template<T, ...> and U return Template<U, ...>, otherwise invalid.
                  template<typename _Tp, typename _Up>
                    struct __replace_first_arg
                    { };
                
                  template<template<typename, typename...> class _Template, typename _Up,
                           typename _Tp, typename... _Types>
                    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
                    { using type = _Template<_Up, _Types...>; };
                
                  template<typename _Tp, typename _Up>
                    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;
                
                  template<typename _Tp>
                    using __make_not_void
                      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;
                
                  /**
                   * @brief  Uniform interface to all pointer-like types
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Ptr>
                    struct pointer_traits
                    {
                    private:
                      template<typename _Tp>
                	using __element_type = typename _Tp::element_type;
                
                      template<typename _Tp>
                	using __difference_type = typename _Tp::difference_type;
                
                      template<typename _Tp, typename _Up, typename = void>
                	struct __rebind : __replace_first_arg<_Tp, _Up> { };
                
                      template<typename _Tp, typename _Up>
                	struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
                	{ using type = typename _Tp::template rebind<_Up>; };
                
                    public:
                      /// The pointer type.
                      using pointer = _Ptr;
                
                      /// The type pointed to.
                      using element_type
                	= __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;
                
                      /// The type used to represent the difference between two pointers.
                      using difference_type
                	= __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;
                
                      /// A pointer to a different type.
                      template<typename _Up>
                        using rebind = typename __rebind<_Ptr, _Up>::type;
                
                      static _Ptr
                      pointer_to(__make_not_void<element_type>& __e)
                      { return _Ptr::pointer_to(__e); }
                
                      static_assert(!is_same<element_type, __undefined>::value,
                	  "pointer type defines element_type or is like SomePointer<T, Args>");
                    };
                
                  /**
                   * @brief  Partial specialization for built-in pointers.
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Tp>
                    struct pointer_traits<_Tp*>
                    {
                      /// The pointer type
                      typedef _Tp* pointer;
                      /// The type pointed to
                      typedef _Tp  element_type;
                      /// Type used to represent the difference between two pointers
                      typedef ptrdiff_t difference_type;
                
                      template<typename _Up>
                        using rebind = _Up*;
                
                      /**
                       *  @brief  Obtain a pointer to an object
                       *  @param  __r  A reference to an object of type @c element_type
                       *  @return @c addressof(__r)
                      */
                      static _GLIBCXX20_CONSTEXPR pointer
      621000 ->       pointer_to(__make_not_void<element_type>& __r) noexcept
                      { return std::addressof(__r); }
                    };
                
                  /// Convenience alias for rebinding pointers.
                  template<typename _Ptr, typename _Tp>
                    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
                
                  template<typename _Tp>
                    constexpr _Tp*
      621000 ->     __to_address(_Tp* __ptr) noexcept
                    {
                      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
                      return __ptr;
                    }
                
                #if __cplusplus <= 201703L
                  template<typename _Ptr>
                    constexpr typename std::pointer_traits<_Ptr>::element_type*
                    __to_address(const _Ptr& __ptr)
                    { return std::__to_address(__ptr.operator->()); }
                #else
                  template<typename _Ptr>
                    constexpr auto
                    __to_address(const _Ptr& __ptr) noexcept
                    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
                    { return std::pointer_traits<_Ptr>::to_address(__ptr); }
                
                  template<typename _Ptr, typename... _None>
                    constexpr auto
                    __to_address(const _Ptr& __ptr, _None...) noexcept
                    {
                      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
                	return std::__to_address(__ptr.base().operator->());
                      else
                	return std::__to_address(__ptr.operator->());
                    }
                
                #define __cpp_lib_to_address 201711L
                
                  /**
                   * @brief Obtain address referenced by a pointer to an object
                   * @param __ptr A pointer to an object
                   * @return @c __ptr
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Tp>
                    constexpr _Tp*
                    to_address(_Tp* __ptr) noexcept
                    { return std::__to_address(__ptr); }
                
                  /**
                   * @brief Obtain address referenced by a pointer to an object
                   * @param __ptr A pointer to an object
                   * @return @c pointer_traits<_Ptr>::to_address(__ptr) if that expression is
                             well-formed, otherwise @c to_address(__ptr.operator->())
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Ptr>
                    constexpr auto
                    to_address(const _Ptr& __ptr) noexcept
                    { return std::__to_address(__ptr); }
                #endif // C++2a
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      146     621000
      156     621000

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

  1242000   Total number of line executions
621000.00   Average executions per line


*** File /usr/include/c++/9/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                #define __cpp_lib_incomplete_container_elements 201505
                #if __cplusplus >= 201103L
                # define __cpp_lib_allocator_is_always_equal 201411
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                
                      typedef true_type is_always_equal;
                
                      template<typename _Up, typename... _Args>
                	void
                	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
                	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #endif
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator : public __allocator_base<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                
                      typedef true_type is_always_equal;
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3035. std::allocator's constructors should be constexpr
                      _GLIBCXX20_CONSTEXPR
        1809 ->       allocator() _GLIBCXX_NOTHROW { }
                
                      _GLIBCXX20_CONSTEXPR
        5412 ->       allocator(const allocator& __a) _GLIBCXX_NOTHROW
                      : __allocator_base<_Tp>(__a) { }
                
                #if __cplusplus >= 201103L
                      // Avoid implicit deprecation.
                      allocator& operator=(const allocator&) = default;
                #endif
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
       12600 -> 	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
                
       19821 ->       ~allocator() _GLIBCXX_NOTHROW { }
                
                      friend bool
                      operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return true; }
                
                      friend bool
       ##### ->       operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return false; }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return false; }
                
                  // Invalid allocator<cv T> partial specializations.
                  // allocator_traits::rebind_alloc can be used to form a valid allocator type.
                  template<typename _Tp>
                    class allocator<const _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<const volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) noexcept { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c) noexcept
                      {
                #if __cpp_exceptions
                	try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	catch(...)
                	  { return false; }
                #else
                	return false;
                #endif
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      152      19821
      150      12600
      140       5412
      137       1809

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

    39642   Total number of line executions
  7928.40   Average executions per line


*** File /usr/include/c++/9/initializer_list:
                // std::initializer_list support -*- C++ -*-
                
                // Copyright (C) 2008-2019 Free Software Foundation, Inc.
                //
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                //
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file initializer_list
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _INITIALIZER_LIST
                #define _INITIALIZER_LIST
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else // C++0x
                
                #pragma GCC visibility push(default)
                
                #include <bits/c++config.h>
                
                namespace std
                {
                  /// initializer_list
                  template<class _E>
                    class initializer_list
                    {
                    public:
                      typedef _E 		value_type;
                      typedef const _E& 	reference;
                      typedef const _E& 	const_reference;
                      typedef size_t 		size_type;
                      typedef const _E* 	iterator;
                      typedef const _E* 	const_iterator;
                
                    private:
                      iterator			_M_array;
                      size_type			_M_len;
                
                      // The compiler can call a private constructor.
                      constexpr initializer_list(const_iterator __a, size_type __l)
                      : _M_array(__a), _M_len(__l) { }
                
                    public:
                      constexpr initializer_list() noexcept
                      : _M_array(0), _M_len(0) { }
                
                      // Number of elements.
                      constexpr size_type
           1 ->       size() const noexcept { return _M_len; }
                
                      // First element.
                      constexpr const_iterator
           2 ->       begin() const noexcept { return _M_array; }
                
                      // One past the last element.
                      constexpr const_iterator
           1 ->       end() const noexcept { return begin() + size(); }
                    };
                
                  /**
                   *  @brief  Return an iterator pointing to the first element of
                   *          the initializer_list.
                   *  @param  __ils  Initializer list.
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    begin(initializer_list<_Tp> __ils) noexcept
                    { return __ils.begin(); }
                
                  /**
                   *  @brief  Return an iterator pointing to one past the last element
                   *          of the initializer_list.
                   *  @param  __ils  Initializer list.
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    end(initializer_list<_Tp> __ils) noexcept
                    { return __ils.end(); }
                }
                
                #pragma GCC visibility pop
                
                #endif // C++11
                
                #endif // _INITIALIZER_LIST


Top 10 Lines:

     Line      Count

       75          2
       71          1
       79          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     1.33   Average executions per line


*** File /usr/include/c++/9/bits/stl_algobase.h:
                // Core algorithmic facilities -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGOBASE_H
                #define _STL_ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <bits/functexcept.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <ext/numeric_traits.h>
                #include <bits/stl_pair.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For std::swap
                #include <bits/predefined_ops.h>
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus < 201103L
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  typedef typename iterator_traits<_ForwardIterator1>::value_type
                	    _ValueType1;
                	  _ValueType1 __tmp = *__a;
                	  *__a = *__b;
                	  *__b = __tmp;
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  swap(*__a, *__b);
                	}
                    };
                #endif
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @ingroup mutating_algorithms
                   *  @param  __a  An iterator.
                   *  @param  __b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline void
         125 ->     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                
                #if __cplusplus < 201103L
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                #else
                      swap(*__a, *__b);
                #endif
                    }
                
                  /**
                   *  @brief Swap the elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @return   An iterator equal to @p first2+(last1-first1).
                   *
                   *  Swaps each element in the range @p [first1,last1) with the
                   *  corresponding element in the range @p [first2,(last1-first1)).
                   *  The ranges must not overlap.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _ForwardIterator2
                    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		_ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	std::iter_swap(__first1, __first2);
                      return __first2;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
         946 ->     min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
         920 ->     max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the __normal_iterator wrapper. See copy, fill, ...
                  template<typename _Iterator>
                    inline _Iterator
        3724 ->     __niter_base(_Iterator __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it; }
                
                  // Reverse the __niter_base transformation to get a
                  // __normal_iterator back again (this assumes that __normal_iterator
                  // is only used to wrap random access iterators, like pointers).
                  template<typename _From, typename _To>
                    inline _From
         901 ->     __niter_wrap(_From __from, _To __res)
                    { return __from + (__res - std::__niter_base(__from)); }
                
                  // No need to wrap, iterator already has the right type.
                  template<typename _Iterator>
                    inline _Iterator
        1804 ->     __niter_wrap(const _Iterator&, _Iterator __res)
                    { return __res; }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool _IsMove, bool _IsSimple, typename _Category>
                    struct __copy_move
                    {
                      template<typename _II, typename _OI>
                	static _OI
         900 -> 	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move<true, false, _Category>
                    {
                      template<typename _II, typename _OI>
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = std::move(*__first);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move<false, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move<true, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = std::move(*__first);
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	static _Tp*
        1800 -> 	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
                	  return __result + _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
        2700 ->     __copy_move_a(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
                      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                      const bool __simple = (__is_trivially_copyable(_ValueTypeI)
                			     && __is_pointer<_II>::__value
                			     && __is_pointer<_OI>::__value
                			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
                
                      return std::__copy_move<_IsMove, __simple,
                			      _Category>::__copy_m(__first, __last, __result);
                    }
                
                  // Helpers for streambuf iterators (either istream or ostream).
                  // NB: avoid including <iosfwd>, relatively large.
                  template<typename _CharT>
                    struct char_traits;
                
                  template<typename _CharT, typename _Traits>
                    class istreambuf_iterator;
                
                  template<typename _CharT, typename _Traits>
                    class ostreambuf_iterator;
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(_CharT*, _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(const _CharT*, const _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                				    _CharT*>::__type
                    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    inline _OI
        2700 ->     __copy_move_a2(_II __first, _II __last, _OI __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_a<_IsMove>(std::__niter_base(__first),
                					    std::__niter_base(__last),
                					    std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
        2700 ->     copy(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a2<__is_move_iterator<_II>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the move_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    inline _OI
                    move(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a2<true>(std::__miter_base(__first),
                				       std::__miter_base(__last), __result);
                    }
                
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                #endif
                
                  template<bool, bool, typename>
                    struct __copy_move_backward
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move_backward<true, false, _Category>
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move_backward<false, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move_backward<true, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type __n;
                	  for (__n = __last - __first; __n > 0; --__n)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	static _Tp*
           1 -> 	__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
           1 ->     __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
                      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                      const bool __simple = (__is_trivially_copyable(_ValueType1)
                			     && __is_pointer<_BI1>::__value
                			     && __is_pointer<_BI2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__copy_move_backward<_IsMove, __simple,
                				       _Category>::__copy_move_b(__first,
                								 __last,
                								 __result);
                    }
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    inline _BI2
           1 ->     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_backward_a<_IsMove>
                		  (std::__niter_base(__first), std::__niter_base(__last),
                		   std::__niter_base(__result)));
                    }
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
                    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as move, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use move instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    inline _BI2
           1 ->     move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
                						std::__miter_base(__last),
                						__result);
                    }
                
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                #endif
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
       ##### ->     __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                 	     const _Tp& __value)
                    {
                      for (; __first != __last; ++__first)
                	*__first = __value;
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
                    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                	     const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __first != __last; ++__first)
                	*__first = __tmp;
                    }
                
                  // Specialization: for char types we can use memset.
                  template<typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
                    {
                      const _Tp __tmp = __c;
                      if (const size_t __len = __last - __first)
                	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
                    }
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
       ##### ->     fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
                		    __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
           1 ->     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __value;
                      return __first;
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
           3 ->     __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __tmp;
                      return __first;
                    }
                
                  template<typename _Size, typename _Tp>
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
                    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
                    {
                      std::__fill_a(__first, __first + __n, __c);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An output iterator.
                   *  @param  __n      The count of copies to perform.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @ wmemset.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 865. More algorithms that throw away information
                  */
                  template<typename _OI, typename _Size, typename _Tp>
                    inline _OI
           4 ->     fill_n(_OI __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                      __glibcxx_requires_can_increment(__first, __n);
                
                      return std::__niter_wrap(__first,
                		std::__fill_n_a(std::__niter_base(__first), __n, __value));
                    }
                
                  template<bool _BoolType>
                    struct __equal
                    {
                      template<typename _II1, typename _II2>
                	static bool
                	equal(_II1 __first1, _II1 __last1, _II2 __first2)
                	{
                	  for (; __first1 != __last1; ++__first1, (void) ++__first2)
                	    if (!(*__first1 == *__first2))
                	      return false;
                	  return true;
                	}
                    };
                
                  template<>
                    struct __equal<true>
                    {
                      template<typename _Tp>
                	static bool
                	equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                	{
                	  if (const size_t __len = (__last1 - __first1))
                	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
                	  return true;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple = ((__is_integer<_ValueType1>::__value
                			      || __is_pointer<_ValueType1>::__value)
                			     && __is_pointer<_II1>::__value
                			     && __is_pointer<_II2>::__value
                			     && __are_same<_ValueType1, _ValueType2>::__value);
                
                      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                    }
                
                  template<typename, typename>
                    struct __lc_rai
                    {
                      template<typename _II1, typename _II2>
                	static _II1
                	__newlast1(_II1, _II1 __last1, _II2, _II2)
                	{ return __last1; }
                
                      template<typename _II>
                	static bool
                	__cnd2(_II __first, _II __last)
                	{ return __first != __last; }
                    };
                
                  template<>
                    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                    {
                      template<typename _RAI1, typename _RAI2>
                	static _RAI1
                	__newlast1(_RAI1 __first1, _RAI1 __last1,
                		   _RAI2 __first2, _RAI2 __last2)
                	{
                	  const typename iterator_traits<_RAI1>::difference_type
                	    __diff1 = __last1 - __first1;
                	  const typename iterator_traits<_RAI2>::difference_type
                	    __diff2 = __last2 - __first2;
                	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                	}
                
                      template<typename _RAI>
                	static bool
                	__cnd2(_RAI, _RAI)
                	{ return true; }
                    };
                
                  template<typename _II1, typename _II2, typename _Compare>
                    bool
                    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2,
                				   _Compare __comp)
                    {
                      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
                
                      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	   ++__first1, (void)++__first2)
                	{
                	  if (__comp(__first1, __first2))
                	    return true;
                	  if (__comp(__first2, __first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  template<bool _BoolType>
                    struct __lexicographical_compare
                    {
                      template<typename _II1, typename _II2>
                	static bool __lc(_II1, _II1, _II2, _II2);
                    };
                
                  template<bool _BoolType>
                    template<typename _II1, typename _II2>
                      bool
                      __lexicographical_compare<_BoolType>::
                      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                      {
                	return std::__lexicographical_compare_impl(__first1, __last1,
                						   __first2, __last2,
                					__gnu_cxx::__ops::__iter_less_iter());
                      }
                
                  template<>
                    struct __lexicographical_compare<true>
                    {
                      template<typename _Tp, typename _Up>
                	static bool
                	__lc(const _Tp* __first1, const _Tp* __last1,
                	     const _Up* __first2, const _Up* __last2)
                	{
                	  const size_t __len1 = __last1 - __first1;
                	  const size_t __len2 = __last2 - __first2;
                	  if (const size_t __len = std::min(__len1, __len2))
                	    if (int __result = __builtin_memcmp(__first1, __first2, __len))
                	      return __result < 0;
                	  return __len1 < __len2;
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    inline bool
                    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                				  _II2 __first2, _II2 __last2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple =
                	(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
                	 && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
                	 && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
                	 && __is_pointer<_II1>::__value
                	 && __is_pointer<_II2>::__value);
                
                      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                							    __first2, __last2);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _ForwardIterator
                    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the first position in which @a val could be inserted
                   *         without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @a val, or end() if every element is less than
                   *                  @a val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val());
                    }
                
                  /// This is a helper function for the sort routines and for random.tcc.
                  //  Precondition: __n > 0.
                  inline _GLIBCXX_CONSTEXPR int
                  __lg(int __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __lg(unsigned __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long
                  __lg(long __n)
           1 ->   { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __lg(unsigned long __n)
                  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __lg(long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __lg(unsigned long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_can_increment_range(__first1, __last1, __first2);
                
                      return std::__equal_aux(std::__niter_base(__first1),
                			      std::__niter_base(__last1),
                			      std::__niter_base(__first2));
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return true;
                    }
                
                #if __cplusplus >= 201103L
                  // 4-iterator version of std::equal<It1, It2> for use in C++11.
                  template<typename _II1, typename _II2>
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!(*__first1 == *__first2))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                
                  // 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.
                  template<typename _II1, typename _II2, typename _BinaryPredicate>
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
                				       __binary_pred);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                #endif // C++11
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_robust_nonmodifying_seq_ops 201304
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2,
                				      __binary_pred);
                    }
                #endif // C++14
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  <em>Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _II1, typename _II2>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                #endif
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
                						std::__niter_base(__last1),
                						std::__niter_base(__first2),
                						std::__niter_base(__last2));
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexicographical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _II1, typename _II2, typename _Compare>
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_impl
                	(__first1, __last1, __first2, __last2,
                	 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                	__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                #if __cplusplus > 201103L
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __first2 != __last2
                	     && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_ALGO
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                // NB: This file is included within many other C++ includes, as a way
                // of getting the base algorithms. So, make sure that parallel bits
                // come in too if requested.
                #ifdef _GLIBCXX_PARALLEL
                # include <parallel/algobase.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      280       3724
      393       2700
      438       2700
      465       2700
      295       1804
      375       1800
      198        946
      222        920
      289        901
      309        900

Execution Summary:

       21   Executable lines in this file
       21   Lines executed
   100.00   Percent of the file executed

    19233   Total number of line executions
   915.86   Average executions per line


*** File /usr/include/c++/9/bits/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/alloc_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOC_TRAITS_H
                #define _ALLOC_TRAITS_H 1
                
                #if __cplusplus >= 201103L
                
                #include <bits/memoryfwd.h>
                #include <bits/ptr_traits.h>
                #include <ext/numeric_traits.h>
                
                #define __cpp_lib_allocator_traits_is_always_equal 201411
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  struct __allocator_traits_base
                  {
                    template<typename _Tp, typename _Up, typename = void>
                      struct __rebind : __replace_first_arg<_Tp, _Up> { };
                
                    template<typename _Tp, typename _Up>
                      struct __rebind<_Tp, _Up,
                		      __void_t<typename _Tp::template rebind<_Up>::other>>
                      { using type = typename _Tp::template rebind<_Up>::other; };
                
                  protected:
                    template<typename _Tp>
                      using __pointer = typename _Tp::pointer;
                    template<typename _Tp>
                      using __c_pointer = typename _Tp::const_pointer;
                    template<typename _Tp>
                      using __v_pointer = typename _Tp::void_pointer;
                    template<typename _Tp>
                      using __cv_pointer = typename _Tp::const_void_pointer;
                    template<typename _Tp>
                      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
                    template<typename _Tp>
                      using __pocma = typename _Tp::propagate_on_container_move_assignment;
                    template<typename _Tp>
                      using __pocs = typename _Tp::propagate_on_container_swap;
                    template<typename _Tp>
                      using __equal = typename _Tp::is_always_equal;
                  };
                
                  template<typename _Alloc, typename _Up>
                    using __alloc_rebind
                      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
                
                  /**
                   * @brief  Uniform interface to all allocator types.
                   * @ingroup allocators
                  */
                  template<typename _Alloc>
                    struct allocator_traits : __allocator_traits_base
                    {
                      /// The allocator type
                      typedef _Alloc allocator_type;
                      /// The allocated type
                      typedef typename _Alloc::value_type value_type;
                
                      /**
                       * @brief   The allocator's pointer type.
                       *
                       * @c Alloc::pointer if that type exists, otherwise @c value_type*
                      */
                      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;
                
                    private:
                      // Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>
                      template<template<typename> class _Func, typename _Tp, typename = void>
                	struct _Ptr
                	{
                	  using type = typename pointer_traits<pointer>::template rebind<_Tp>;
                	};
                
                      template<template<typename> class _Func, typename _Tp>
                	struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
                	{
                	  using type = _Func<_Alloc>;
                	};
                
                      // Select _A2::difference_type or pointer_traits<_Ptr>::difference_type
                      template<typename _A2, typename _PtrT, typename = void>
                	struct _Diff
                	{ using type = typename pointer_traits<_PtrT>::difference_type; };
                
                      template<typename _A2, typename _PtrT>
                	struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
                	{ using type = typename _A2::difference_type; };
                
                      // Select _A2::size_type or make_unsigned<_DiffT>::type
                      template<typename _A2, typename _DiffT, typename = void>
                	struct _Size : make_unsigned<_DiffT> { };
                
                      template<typename _A2, typename _DiffT>
                	struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
                	{ using type = typename _A2::size_type; };
                
                    public:
                      /**
                       * @brief   The allocator's const pointer type.
                       *
                       * @c Alloc::const_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
                      */
                      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
                
                      /**
                       * @brief   The allocator's void pointer type.
                       *
                       * @c Alloc::void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<void> </tt>
                      */
                      using void_pointer = typename _Ptr<__v_pointer, void>::type;
                
                      /**
                       * @brief   The allocator's const void pointer type.
                       *
                       * @c Alloc::const_void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
                      */
                      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
                
                      /**
                       * @brief   The allocator's difference type
                       *
                       * @c Alloc::difference_type if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::difference_type </tt>
                      */
                      using difference_type = typename _Diff<_Alloc, pointer>::type;
                
                      /**
                       * @brief   The allocator's size type
                       *
                       * @c Alloc::size_type if that type exists, otherwise
                       * <tt> make_unsigned<difference_type>::type </tt>
                      */
                      using size_type = typename _Size<_Alloc, difference_type>::type;
                
                      /**
                       * @brief   How the allocator is propagated on copy assignment
                       *
                       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_copy_assignment
                	= __detected_or_t<false_type, __pocca, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on move assignment
                       *
                       * @c Alloc::propagate_on_container_move_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_move_assignment
                	= __detected_or_t<false_type, __pocma, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on swap
                       *
                       * @c Alloc::propagate_on_container_swap if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_swap
                	= __detected_or_t<false_type, __pocs, _Alloc>;
                
                      /**
                       * @brief   Whether all instances of the allocator type compare equal.
                       *
                       * @c Alloc::is_always_equal if that type exists,
                       * otherwise @c is_empty<Alloc>::type
                      */
                      using is_always_equal
                	= __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
                
                      template<typename _Tp>
                	using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
                      template<typename _Tp>
                	using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
                
                    private:
                      template<typename _Alloc2>
                	static auto
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
                	-> decltype(__a.allocate(__n, __hint))
                	{ return __a.allocate(__n, __hint); }
                
                      template<typename _Alloc2>
                	static pointer
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
                	{ return __a.allocate(__n); }
                
                      template<typename _Tp, typename... _Args>
                	struct __construct_helper
                	{
                	  template<typename _Alloc2,
                	    typename = decltype(std::declval<_Alloc2*>()->construct(
                		  std::declval<_Tp*>(), std::declval<_Args>()...))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Tp, typename... _Args>
                	using __has_construct
                	  = typename __construct_helper<_Tp, _Args...>::type;
                
                      template<typename _Tp, typename... _Args>
                	static _Require<__has_construct<_Tp, _Args...>>
                	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      template<typename _Tp, typename... _Args>
                	static
                	_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
                			       is_constructible<_Tp, _Args...>>>
                	_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
                	{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }
                
                      template<typename _Alloc2, typename _Tp>
                	static auto
                	_S_destroy(_Alloc2& __a, _Tp* __p, int)
                	noexcept(noexcept(__a.destroy(__p)))
                	-> decltype(__a.destroy(__p))
                	{ __a.destroy(__p); }
                
                      template<typename _Alloc2, typename _Tp>
                	static void
                	_S_destroy(_Alloc2&, _Tp* __p, ...)
                	noexcept(std::is_nothrow_destructible<_Tp>::value)
                	{ __p->~_Tp(); }
                
                      template<typename _Alloc2>
                	static auto
                	_S_max_size(_Alloc2& __a, int)
                	-> decltype(__a.max_size())
                	{ return __a.max_size(); }
                
                      template<typename _Alloc2>
                	static size_type
                	_S_max_size(_Alloc2&, ...)
                	{
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 2466. allocator_traits::max_size() default behavior is incorrect
                	  return __gnu_cxx::__numeric_traits<size_type>::__max
                	    / sizeof(value_type);
                	}
                
                      template<typename _Alloc2>
                	static auto
                	_S_select(_Alloc2& __a, int)
                	-> decltype(__a.select_on_container_copy_construction())
                	{ return __a.select_on_container_copy_construction(); }
                
                      template<typename _Alloc2>
                	static _Alloc2
                	_S_select(_Alloc2& __a, ...)
                	{ return __a; }
                
                    public:
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static pointer
                      allocate(_Alloc& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
                       *  well-formed, otherwise returns @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static pointer
                      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
                      { return _S_allocate(__a, __n, __hint, 0); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static void
                      deallocate(_Alloc& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type `_Tp`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                       *  if that expression is well-formed, otherwise uses placement-new
                       *  to construct an object of type @a _Tp at location @a __p from the
                       *  arguments @a __args...
                      */
                      template<typename _Tp, typename... _Args>
                	static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(_S_construct(__a, __p,
                				       std::forward<_Args>(__args)...)))
                	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
                	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Tp
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p) if that expression is well-formed,
                       *  otherwise calls @c __p->~_Tp()
                      */
                      template<typename _Tp>
                	static void destroy(_Alloc& __a, _Tp* __p)
                	noexcept(noexcept(_S_destroy(__a, __p, 0)))
                	{ _S_destroy(__a, __p, 0); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
                       *
                       *  Returns @c __a.max_size() if that expression is well-formed,
                       *  otherwise returns @c numeric_limits<size_type>::max()
                      */
                      static size_type max_size(const _Alloc& __a) noexcept
                      { return _S_max_size(__a, 0); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
                       *
                       *  Returns @c __rhs.select_on_container_copy_construction() if that
                       *  expression is well-formed, otherwise returns @a __rhs
                      */
                      static _Alloc
                      select_on_container_copy_construction(const _Alloc& __rhs)
                      { return _S_select(__rhs, 0); }
                    };
                
                  /// Partial specialization for std::allocator.
                  template<typename _Tp>
                    struct allocator_traits<allocator<_Tp>>
                    {
                      /// The allocator type
                      using allocator_type = allocator<_Tp>;
                      /// The allocated type
                      using value_type = _Tp;
                
                      /// The allocator's pointer type.
                      using pointer = _Tp*;
                
                      /// The allocator's const pointer type.
                      using const_pointer = const _Tp*;
                
                      /// The allocator's void pointer type.
                      using void_pointer = void*;
                
                      /// The allocator's const void pointer type.
                      using const_void_pointer = const void*;
                
                      /// The allocator's difference type
                      using difference_type = std::ptrdiff_t;
                
                      /// The allocator's size type
                      using size_type = std::size_t;
                
                      /// How the allocator is propagated on copy assignment
                      using propagate_on_container_copy_assignment = false_type;
                
                      /// How the allocator is propagated on move assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      /// How the allocator is propagated on swap
                      using propagate_on_container_swap = false_type;
                
                      /// Whether all instances of the allocator type compare equal.
                      using is_always_equal = true_type;
                
                      template<typename _Up>
                	using rebind_alloc = allocator<_Up>;
                
                      template<typename _Up>
                	using rebind_traits = allocator_traits<allocator<_Up>>;
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static pointer
      621926 ->       allocate(allocator_type& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt>
                      */
                      _GLIBCXX_NODISCARD static pointer
                      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
                      { return __a.allocate(__n, __hint); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static void
      621926 ->       deallocate(allocator_type& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                      */
                      template<typename _Up, typename... _Args>
                	static void
     1446337 -> 	construct(allocator_type& __a, _Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p).
                      */
                      template<typename _Up>
                	static void
     1138987 -> 	destroy(allocator_type& __a, _Up* __p)
                	noexcept(noexcept(__a.destroy(__p)))
                	{ __a.destroy(__p); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size()
                      */
                      static size_type
         946 ->       max_size(const allocator_type& __a) noexcept
                      { return __a.max_size(); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs
                      */
                      static allocator_type
         900 ->       select_on_container_copy_construction(const allocator_type& __rhs)
                      { return __rhs; }
                    };
                
                
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
                    { __one = __two; }
                
                  template<typename _Alloc>
                    inline void
       ##### ->     __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
       ##### ->     inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
                      __do_alloc_on_copy(__one, __two, __pocca());
                    }
                
                  template<typename _Alloc>
                    inline _Alloc __alloc_on_copy(const _Alloc& __a)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      return __traits::select_on_container_copy_construction(__a);
                    }
                
                  template<typename _Alloc>
         900 ->     inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
                    { __one = std::move(__two); }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
         900 ->     inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_move_assignment __pocma;
                      __do_alloc_on_move(__one, __two, __pocma());
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
                    {
                      using std::swap;
                      swap(__one, __two);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
                    { }
                
                  template<typename _Alloc>
                    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_swap __pocs;
                      __do_alloc_on_swap(__one, __two, __pocs());
                    }
                
                  template<typename _Alloc, typename _Tp,
                	   typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
                	   typename = void>
                    struct __is_alloc_insertable_impl
                    : false_type
                    { };
                
                  template<typename _Alloc, typename _Tp, typename _ValueT>
                    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
                      __void_t<decltype(allocator_traits<_Alloc>::construct(
                		   std::declval<_Alloc&>(), std::declval<_ValueT*>(),
                		   std::declval<_Tp>()))>>
                    : true_type
                    { };
                
                  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_copy_insertable
                    : __is_alloc_insertable_impl<_Alloc,
                				 typename _Alloc::value_type const&>::type
                    { };
                
                  // std::allocator<_Tp> just requires CopyConstructible
                  template<typename _Tp>
                    struct __is_copy_insertable<allocator<_Tp>>
                    : is_copy_constructible<_Tp>
                    { };
                
                  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_move_insertable
                    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
                    { };
                
                  // std::allocator<_Tp> just requires MoveConstructible
                  template<typename _Tp>
                    struct __is_move_insertable<allocator<_Tp>>
                    : is_move_constructible<_Tp>
                    { };
                
                  // Trait to detect Allocator-like types.
                  template<typename _Alloc, typename = void>
                    struct __is_allocator : false_type { };
                
                  template<typename _Alloc>
                    struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type,
                	       decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
                    : true_type { };
                
                  template<typename _Alloc>
                    using _RequireAllocator
                      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
                
                  template<typename _Alloc>
                    using _RequireNotAllocator
                      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                #endif // C++11
                #endif // _ALLOC_TRAITS_H


Top 10 Lines:

     Line      Count

      481    1446337
      494    1138987
      442     621926
      468     621926
      504        946
      513        900
      544        900
      552        900

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

  3832822   Total number of line executions
383282.20   Average executions per line


*** File /usr/include/c++/9/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  using std::size_t;
                  using std::ptrdiff_t;
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard.
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef new_allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
                      _GLIBCXX20_CONSTEXPR
       14409 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      _GLIBCXX20_CONSTEXPR
        5412 ->       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
                	new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
       19821 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      _GLIBCXX_NODISCARD pointer
      621926 ->       allocate(size_type __n, const void* = static_cast<const void*>(0))
                      {
                	if (__n > this->max_size())
                	  std::__throw_bad_alloc();
                
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
                	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
                	  }
                #endif
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
      621926 ->       deallocate(pointer __p, size_type)
                      {
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    ::operator delete(__p, std::align_val_t(alignof(_Tp)));
                	    return;
                	  }
                #endif
                	::operator delete(__p);
                      }
                
                      size_type
      622872 ->       max_size() const _GLIBCXX_USE_NOEXCEPT
                      {
                #if __PTRDIFF_MAX__ < __SIZE_MAX__
                	return size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
                #else
                	return size_t(-1) / sizeof(_Tp);
                #endif
                      }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                	void
     1446337 -> 	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
     1138987 -> 	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void
                      construct(pointer __p, const _Tp& __val)
                      { ::new((void *)__p) _Tp(__val); }
                
                      void
                      destroy(pointer __p) { __p->~_Tp(); }
                #endif
                
                      template<typename _Up>
                	friend bool
                	operator==(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return true; }
                
                      template<typename _Up>
                	friend bool
                	operator!=(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return false; }
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      144    1446337
      150    1138987
      132     622872
      102     621926
      119     621926
       89      19821
       80      14409
       83       5412

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

  4491690   Total number of line executions
561461.25   Average executions per line


*** File /usr/include/c++/9/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <ext/alloc_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _T1, typename... _Args>
                    inline void
        1820 ->     _Construct(_T1* __p, _Args&&... __args)
                    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
                #else
                  template<typename _T1, typename _T2>
                    inline void
                    _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  template<typename _T1>
                    inline void
                    _Construct_novalue(_T1* __p)
                    { ::new(static_cast<void*>(__p)) _T1; }
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    inline void
        1820 ->     _Destroy(_Tp* __pointer)
                    { __pointer->~_Tp(); }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                        static void
           4 ->         __destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
        3606 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    inline void
        3610 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  template<bool>
                    struct _Destroy_n_aux
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  for (; __count > 0; (void)++__first, --__count)
                	    std::_Destroy(std::__addressof(*__first));
                	  return __first;
                	}
                    };
                
                  template<>
                    struct _Destroy_n_aux<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  std::advance(__first, __count);
                	  return __first;
                	}
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    _Destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy_n(__first, __count);
                    }
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * nondefault allocators we do not optimize away invocation of 
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                      for (; __first != __last; ++__first)
                	__traits::destroy(__alloc, std::__addressof(*__first));
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
        3610 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                #if __cplusplus > 201402L
                  template <typename _Tp>
                    inline void
                    destroy_at(_Tp* __location)
                    {
                      std::_Destroy(__location);
                    }
                
                  template <typename _ForwardIterator>
                    inline void
                    destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      std::_Destroy(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      return std::_Destroy_n(__first, __count);
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */
                


Top 10 Lines:

     Line      Count

      127       3610
      203       3610
      117       3606
       74       1820
       97       1820
      105          4

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

    14470   Total number of line executions
  2411.67   Average executions per line


*** File /usr/include/c++/9/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                #include <debug/assertions.h>
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                extern "C" void
                __sanitizer_annotate_contiguous_container(const void*, const void*,
                					  const void*, const void*);
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
                      struct _Vector_impl_data
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
        4511 -> 	_Vector_impl_data() _GLIBCXX_NOEXCEPT
                	: _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
                	: _M_start(__x._M_start), _M_finish(__x._M_finish),
                	  _M_end_of_storage(__x._M_end_of_storage)
                	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
                #endif
                
                	void
        5403 -> 	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
                	{
                	  _M_start = __x._M_start;
                	  _M_finish = __x._M_finish;
                	  _M_end_of_storage = __x._M_end_of_storage;
                	}
                
                	void
        1801 -> 	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
                	{
                	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
                	  // information used by TBAA.
                	  _Vector_impl_data __tmp;
                	  __tmp._M_copy_data(*this);
                	  _M_copy_data(__x);
                	  __x._M_copy_data(__tmp);
                	}
                      };
                
        2710 ->       struct _Vector_impl
                	: public _Tp_alloc_type, public _Vector_impl_data
                      {
           4 -> 	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
                	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
                	: _Tp_alloc_type()
                	{ }
                
        2706 -> 	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a)
                	{ }
                
                #if __cplusplus >= 201103L
                	// Not defaulted, to enforce noexcept(true) even when
                	// !is_nothrow_move_constructible<_Tp_alloc_type>.
                	_Vector_impl(_Vector_impl&& __x) noexcept
                	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
                	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
                	{ }
                #endif
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                	template<typename = _Tp_alloc_type>
                	  struct _Asan
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    static void _S_shrink(_Vector_impl&, size_type) { }
                	    static void _S_on_dealloc(_Vector_impl&) { }
                
                	    typedef _Vector_impl& _Reinit;
                
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl&, size_type) { }
                	      void _M_grew(size_type) { }
                	    };
                	  };
                
                	// Enable ASan annotations for memory obtained from std::allocator.
                	template<typename _Up>
                	  struct _Asan<allocator<_Up> >
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to
                	    // mark end of valid region as __curr instead of __prev.
                	    static void
                	    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)
                	    {
                	      __sanitizer_annotate_contiguous_container(__impl._M_start,
                		  __impl._M_end_of_storage, __prev, __curr);
                	    }
                
                	    static void
                	    _S_grow(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }
                
                	    static void
                	    _S_shrink(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }
                
                	    static void
                	    _S_on_dealloc(_Vector_impl& __impl)
                	    {
                	      if (__impl._M_start)
                		_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);
                	    }
                
                	    // Used on reallocation to tell ASan unused capacity is invalid.
                	    struct _Reinit
                	    {
                	      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)
                	      {
                		// Mark unused capacity as valid again before deallocating it.
                		_S_on_dealloc(_M_impl);
                	      }
                
                	      ~_Reinit()
                	      {
                		// Mark unused capacity as invalid after reallocation.
                		if (_M_impl._M_start)
                		  _S_adjust(_M_impl, _M_impl._M_end_of_storage,
                			    _M_impl._M_finish);
                	      }
                
                	      _Vector_impl& _M_impl;
                
                #if __cplusplus >= 201103L
                	      _Reinit(const _Reinit&) = delete;
                	      _Reinit& operator=(const _Reinit&) = delete;
                #endif
                	    };
                
                	    // Tell ASan when unused capacity is initialized to be valid.
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl& __impl, size_type __n)
                	      : _M_impl(__impl), _M_n(__n)
                	      { _S_grow(_M_impl, __n); }
                
                	      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }
                
                	      void _M_grew(size_type __n) { _M_n -= __n; }
                
                #if __cplusplus >= 201103L
                	      _Grow(const _Grow&) = delete;
                	      _Grow& operator=(const _Grow&) = delete;
                #endif
                	    private:
                	      _Vector_impl& _M_impl;
                	      size_type _M_n;
                	    };
                	  };
                
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT \
                  typename _Base::_Vector_impl::template _Asan<>::_Reinit const \
                	__attribute__((__unused__)) __reinit_guard(this->_M_impl)
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \
                  typename _Base::_Vector_impl::template _Asan<>::_Grow \
                	__attribute__((__unused__)) __grow_guard(this->_M_impl, (n))
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \
                  _Base::_Vector_impl::template _Asan<>::_S_shrink(this->_M_impl, n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \
                  _Base::_Vector_impl::template _Asan<>::_S_on_dealloc(this->_M_impl)
                #else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
                #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                      };
                
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
        8158 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      const _Tp_alloc_type&
        1840 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      allocator_type
         900 ->       get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
           4 ->       _Vector_base() = default;
                #else
                      _Vector_base() { }
                #endif
                
        1801 ->       _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _M_impl(__a) { }
                
                      // Kept for ABI compatibility.
                #if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                #endif
                
         905 ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Vector_base&&) = default;
                
                      // Kept for ABI compatibility.
                # if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(_Tp_alloc_type&& __a) noexcept
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                # endif
                
                      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
                      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
                      { }
                #endif
                
        2710 ->       ~_Vector_base() _GLIBCXX_NOEXCEPT
                      {
                	_M_deallocate(_M_impl._M_start,
                		      _M_impl._M_end_of_storage - _M_impl._M_start);
                      }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
        1826 ->       _M_allocate(size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
                      }
                
                      void
        2730 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	if (__p)
                	  _Tr::deallocate(_M_impl, __p, __n);
                      }
                
                    protected:
                      void
         905 ->       _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // Concept requirements.
                      typedef typename _Alloc::value_type		_Alloc_value_type;
                # if __cplusplus < 201103L
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                # endif
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                #endif
                
                #if __cplusplus >= 201103L
                      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
                	  "std::vector must have a non-const, non-volatile value_type");
                # ifdef __STRICT_ANSI__
                      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
                	  "std::vector must have the same value_type as its allocator");
                # endif
                #endif
                
                      typedef _Vector_base<_Tp, _Alloc>			_Base;
                      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
                
                    public:
                      typedef _Tp					value_type;
                      typedef typename _Base::pointer			pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                      typedef size_t					size_type;
                      typedef ptrdiff_t					difference_type;
                      typedef _Alloc					allocator_type;
                
                    private:
                #if __cplusplus >= 201103L
                      static constexpr bool
          40 ->       _S_nothrow_relocate(true_type)
                      {
                	return noexcept(std::__relocate_a(std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<_Tp_alloc_type&>()));
                      }
                
                      static constexpr bool
                      _S_nothrow_relocate(false_type)
                      { return false; }
                
                      static constexpr bool
          40 ->       _S_use_relocate()
                      {
                	// Instantiating std::__relocate_a might cause an error outside the
                	// immediate context (in __relocate_object_a's noexcept-specifier),
                	// so only do it if we know the type can be move-inserted into *this.
                	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
                      }
                
                      static pointer
          40 ->       _S_do_relocate(pointer __first, pointer __last, pointer __result,
                		     _Tp_alloc_type& __alloc, true_type) noexcept
                      {
                	return std::__relocate_a(__first, __last, __result, __alloc);
                      }
                
                      static pointer
                      _S_do_relocate(pointer, pointer, pointer __result,
                		     _Tp_alloc_type&, false_type) noexcept
                      { return __result; }
                
                      static pointer
          40 ->       _S_relocate(pointer __first, pointer __last, pointer __result,
                		  _Tp_alloc_type& __alloc) noexcept
                      {
                	using __do_it = __bool_constant<_S_use_relocate()>;
                	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
                      }
                #endif // C++11
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       */
                #if __cplusplus >= 201103L
           4 ->       vector() = default;
                #else
                      vector() { }
                #endif
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
         900 ->       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
           2 ->       vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
           3 ->       vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x  will not be copied
                       *  (i.e. capacity() == size() in the new %vector).
                       *
                       *  The newly-created %vector uses a copy of the allocator object used
                       *  by @a __x (unless the allocator traits dictate a different object).
                       */
         900 ->       vector(const vector& __x)
                      : _Base(__x.size(),
                	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *
                       *  The newly-created %vector contains the exact contents of the
                       *  moved instance.
                       *  The contents of the moved instance are a valid, but unspecified
                       *  %vector.
                       */
                      vector(vector&&) noexcept = default;
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                    private:
                      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
                      : _Base(__m, std::move(__rv))
                      { }
                
                      vector(vector&& __rv, const allocator_type& __m, false_type)
                      : _Base(__m)
                      {
                	if (__rv.get_allocator() == __m)
                	  this->_M_impl._M_swap_data(__rv._M_impl);
                	else if (!__rv.empty())
                	  {
                	    this->_M_create_storage(__rv.size());
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                    public:
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      noexcept( noexcept(
                	vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
                	       std::declval<typename _Alloc_traits::is_always_equal>())) )
                      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
                      { }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
           1 ->       vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
         900 -> 	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #else
                      template<typename _InputIterator>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
        2709 ->       ~vector() _GLIBCXX_NOEXCEPT
                      {
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
                      }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x will not be copied.
                       *
                       *  Whether the allocator is copied depends on the allocator traits.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  Afterwards @a __x is a valid, but unspecified %vector.
                       *
                       *  Whether the allocator is moved depends on the allocator traits.
                       */
                      vector&
         900 ->       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	constexpr bool __move_storage =
                	  _Alloc_traits::_S_propagate_on_move_assign()
                	  || _Alloc_traits::_S_always_equal();
                	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.
                       */
                      void
           2 ->       assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{ _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
         923 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
        3601 ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
         923 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
        3601 ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
      330213 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
          40 ->       max_size() const _GLIBCXX_NOEXCEPT
                      { return _S_max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
         902 ->       capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
     2538248 ->       operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
       22778 ->       operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                      _Tp*
                      data() _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      const _Tp*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
                      push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), __x);
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                #if __cplusplus > 201402L
                	reference
                #else
                	void
                #endif
                	emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                	iterator
                	emplace(const_iterator __position, _Args&&... __args)
                	{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return _M_insert_rval(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, initializer_list<value_type> __l)
                      {
                	auto __offset = __position - cbegin();
                	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),
                			std::random_access_iterator_tag());
                	return begin() + __offset;
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(begin() + __offset, __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                	insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(begin() + __offset,
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                	void
                	insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __position)
                      { return _M_erase(begin() + (__position - cbegin())); }
                #else
                      erase(iterator __position)
                      { return _M_erase(__position); }
                #endif
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
                      erase(const_iterator __first, const_iterator __last)
                      {
                	const auto __beg = begin();
                	const auto __cbeg = cbegin();
                	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
                      }
                #else
                      erase(iterator __first, iterator __last)
                      { return _M_erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       *
                       *  Whether the allocators are swapped depends on the allocator traits.
                       */
                      void
                      swap(vector& __x) _GLIBCXX_NOEXCEPT
                      {
                #if __cplusplus >= 201103L
                	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
                			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
                #endif
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                				  __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
       ##### ->       clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                	pointer
       ##### -> 	_M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                	{
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                #if __cplusplus < 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                	{
                	  this->_M_impl._M_start = _M_allocate(_S_check_init_len(
                		static_cast<size_type>(__n), _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #endif
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_initialize(_InputIterator __first, _InputIterator __last,
                			    std::input_iterator_tag)
                	{
                	  __try {
                	    for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	      emplace_back(*__first);
                #else
                	      push_back(*__first);
                #endif
                	  } __catch(...) {
                	    clear();
                	    __throw_exception_again;
                	  }
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                	void
         901 -> 	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                			    std::forward_iterator_tag)
                	{
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start
                	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
           3 ->       _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                					_M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
           2 ->       _M_default_initialize(size_type __n)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
                					   _M_get_Tp_allocator());
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                	{ _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                	{ _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                	{
                	  _M_range_insert(__pos, __first, __last,
                			  std::__iterator_category(__first));
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                #if __cplusplus < 201103L
                      // Called by insert(p,x)
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                
                      void
                      _M_realloc_insert(iterator __position, const value_type& __x);
                #else
                      // A value_type object constructed with _Alloc_traits::construct()
                      // and destroyed with _Alloc_traits::destroy().
                      struct _Temporary_value
                      {
                	template<typename... _Args>
                	  explicit
                	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
                	  {
                	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
                				     std::forward<_Args>(__args)...);
                	  }
                
                	~_Temporary_value()
                	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
                
                	value_type&
                	_M_val() { return *_M_ptr(); }
                
                      private:
                	_Tp*
                	_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }
                
                	vector* _M_this;
                	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
                      };
                
                      // Called by insert(p,x) and other functions when insertion needs to
                      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
                      template<typename _Arg>
                	void
                	_M_insert_aux(iterator __position, _Arg&& __arg);
                
                      template<typename... _Args>
                	void
                	_M_realloc_insert(iterator __position, _Args&&... __args);
                
                      // Either move-construct at the end, or forward to _M_insert_aux.
                      iterator
                      _M_insert_rval(const_iterator __position, value_type&& __v);
                
                      // Try to emplace at the end, otherwise forward to _M_insert_aux.
                      template<typename... _Args>
                	iterator
                	_M_emplace_aux(const_iterator __position, _Args&&... __args);
                
                      // Emplacing an rvalue of the correct type can use _M_insert_rval.
                      iterator
                      _M_emplace_aux(const_iterator __position, value_type&& __v)
                      { return _M_insert_rval(__position, std::move(__v)); }
                #endif
                
                      // Called by _M_fill_insert, _M_insert_aux etc.
                      size_type
          20 ->       _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + (std::max)(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Called by constructors to check initial size.
                      static size_type
         906 ->       _S_check_init_len(size_type __n, const allocator_type& __a)
                      {
                	if (__n > _S_max_size(_Tp_alloc_type(__a)))
                	  __throw_length_error(
                	      __N("cannot create std::vector larger than max_size()"));
                	return __n;
                      }
                
                      static size_type
         946 ->       _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
                      {
                	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
                	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
                	// (even if std::allocator_traits::max_size says we can).
                	const size_t __diffmax
                	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
                	const size_t __allocmax = _Alloc_traits::max_size(__a);
                	return (std::min)(__diffmax, __allocmax);
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
           1 ->       _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
                      {
                	if (size_type __n = this->_M_impl._M_finish - __pos)
                	  {
                	    std::_Destroy(__pos, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    this->_M_impl._M_finish = __pos;
                	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
                	  }
                      }
                
                      iterator
                      _M_erase(iterator __position);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
         900 ->       _M_move_assign(vector&& __x, true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__x._M_impl);
                	__tmp._M_impl._M_swap_data(__x._M_impl);
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                #if __cplusplus >= 201103L
                      template<typename _Ptr>
                	typename std::pointer_traits<_Ptr>::element_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? nullptr : std::__to_address(__ptr); }
                #else
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                      template<typename _Ptr>
                	value_type*
                	_M_data_ptr(_Ptr __ptr)
                	{ return empty() ? (value_type*)0 : __ptr.operator->(); }
                
                      template<typename _Ptr>
                	const value_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? (const value_type*)0 : __ptr.operator->(); }
                #endif
                    };
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _InputIterator, typename _ValT
                	     = typename iterator_traits<_InputIterator>::value_type,
                	   typename _Allocator = allocator<_ValT>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
                      -> vector<_ValT, _Allocator>;
                #endif
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // vector into a variant, but only if move assignment cannot throw.
                    template<typename _Tp, typename _Alloc>
                      struct _Never_valueless_alt<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      : std::is_nothrow_move_assignable<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

     1040    2538248
      915     330213
     1058      22778
      273       8158
      106       5403
       94       4511
      817       3601
      835       3601
      347       2730
      125       2710

Execution Summary:

       49   Executable lines in this file
       49   Lines executed
   100.00   Percent of the file executed

  2950303   Total number of line executions
 60210.27   Average executions per line


*** File /usr/include/c++/9/bits/move.h:
                // Move, forward and identity for C++11 + swap -*- C++ -*-
                
                // Copyright (C) 2007-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #include <bits/concept_check.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR _Tp*
     2197501 ->     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    { return __builtin_addressof(__r); }
                
                #if __cplusplus >= 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
    10125935 ->     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                		    " substituting _Tp is an lvalue reference type");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    constexpr typename std::remove_reference<_Tp>::type&&
      530888 ->     move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                #if __cplusplus > 201402L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2296. std::addressof should be constexpr
                # define __cpp_lib_addressof_constexpr 201603
                #endif
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    inline _GLIBCXX17_CONSTEXPR _Tp*
      621000 ->     addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2598. addressof works on temporaries
                  template<typename _Tp>
                    const _Tp* addressof(const _Tp&&) = delete;
                
                  // C++11 version of std::exchange for internal use.
                  template <typename _Tp, typename _Up = _Tp>
                    inline _Tp
                    __exchange(_Tp& __obj, _Up&& __new_val)
                    {
                      _Tp __old_val = std::move(__obj);
                      __obj = std::forward<_Up>(__new_val);
                      return __old_val;
                    }
                
                  /// @} group utilities
                
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
                			      is_move_constructible<_Tp>,
                			      is_move_assignable<_Tp>>::value>::type
         125 ->     swap(_Tp& __a, _Tp& __b)
                    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                	            is_nothrow_move_assignable<_Tp>>::value)
                #else
                    void
                    swap(_Tp& __a, _Tp& __b)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__is_swappable<_Tp>::value>::type
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                    noexcept(__is_nothrow_swappable<_Tp>::value)
                #else
                    void
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                #endif
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

       74   10125935
       47    2197501
      138     621000
       99     530888
      182        125

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

 13475449   Total number of line executions
2695089.80   Average executions per line


*** File /usr/include/c++/9/bits/predefined_ops.h:
                // Default predicates for internal use -*- C++ -*-
                
                // Copyright (C) 2013-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file predefined_ops.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _GLIBCXX_PREDEFINED_OPS_H
                #define _GLIBCXX_PREDEFINED_OPS_H	1
                
                namespace __gnu_cxx
                {
                namespace __ops
                {
                  struct _Iter_less_iter
                  {
                    template<typename _Iterator1, typename _Iterator2>
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(_Iterator1 __it1, _Iterator2 __it2) const
                      { return *__it1 < *__it2; }
                  };
                
                  _GLIBCXX14_CONSTEXPR
                  inline _Iter_less_iter
                  __iter_less_iter()
                  { return _Iter_less_iter(); }
                
                  struct _Iter_less_val
                  {
                #if __cplusplus >= 201103L
                    constexpr _Iter_less_val() = default;
                #else
                    _Iter_less_val() { }
                #endif
                
                    explicit
                    _Iter_less_val(_Iter_less_iter) { }
                
                    template<typename _Iterator, typename _Value>
                      bool
                      operator()(_Iterator __it, _Value& __val) const
                      { return *__it < __val; }
                  };
                
                  inline _Iter_less_val
                  __iter_less_val()
                  { return _Iter_less_val(); }
                
                  inline _Iter_less_val
                  __iter_comp_val(_Iter_less_iter)
                  { return _Iter_less_val(); }
                
                  struct _Val_less_iter
                  {
                #if __cplusplus >= 201103L
                    constexpr _Val_less_iter() = default;
                #else
                    _Val_less_iter() { }
                #endif
                
                    explicit
                    _Val_less_iter(_Iter_less_iter) { }
                
                    template<typename _Value, typename _Iterator>
                      bool
                      operator()(_Value& __val, _Iterator __it) const
                      { return __val < *__it; }
                  };
                
                  inline _Val_less_iter
                  __val_less_iter()
                  { return _Val_less_iter(); }
                
                  inline _Val_less_iter
                  __val_comp_iter(_Iter_less_iter)
                  { return _Val_less_iter(); }
                
                  struct _Iter_equal_to_iter
                  {
                    template<typename _Iterator1, typename _Iterator2>
                      bool
                      operator()(_Iterator1 __it1, _Iterator2 __it2) const
                      { return *__it1 == *__it2; }
                  };
                
                  inline _Iter_equal_to_iter
                  __iter_equal_to_iter()
                  { return _Iter_equal_to_iter(); }
                
                  struct _Iter_equal_to_val
                  {
                    template<typename _Iterator, typename _Value>
                      bool
                      operator()(_Iterator __it, _Value& __val) const
                      { return *__it == __val; }
                  };
                
                  inline _Iter_equal_to_val
                  __iter_equal_to_val()
                  { return _Iter_equal_to_val(); }
                
                  inline _Iter_equal_to_val
                  __iter_comp_val(_Iter_equal_to_iter)
                  { return _Iter_equal_to_val(); }
                
                  template<typename _Compare>
                    struct _Iter_comp_iter
                    {
                      _Compare _M_comp;
                
                      explicit _GLIBCXX14_CONSTEXPR
           1 ->       _Iter_comp_iter(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      template<typename _Iterator1, typename _Iterator2>
                        _GLIBCXX14_CONSTEXPR
                        bool
        7861 ->         operator()(_Iterator1 __it1, _Iterator2 __it2)
                        { return bool(_M_comp(*__it1, *__it2)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Iter_comp_iter<_Compare>
           1 ->     __iter_comp_iter(_Compare __comp)
                    { return _Iter_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    struct _Iter_comp_val
                    {
                      _Compare _M_comp;
                
                      explicit
                      _Iter_comp_val(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      explicit
                      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
                	: _M_comp(__comp._M_comp)
                      { }
                
                #if __cplusplus >= 201103L
                      explicit
       ##### ->       _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
                	: _M_comp(std::move(__comp._M_comp))
                      { }
                #endif
                
                      template<typename _Iterator, typename _Value>
                	bool
       ##### -> 	operator()(_Iterator __it, _Value& __val)
                	{ return bool(_M_comp(*__it, __val)); }
                    };
                
                  template<typename _Compare>
                   inline _Iter_comp_val<_Compare>
                    __iter_comp_val(_Compare __comp)
                    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    inline _Iter_comp_val<_Compare>
                    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
                    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    struct _Val_comp_iter
                    {
                      _Compare _M_comp;
                
                      explicit
                      _Val_comp_iter(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      explicit
                      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
                	: _M_comp(__comp._M_comp)
                      { }
                
                #if __cplusplus >= 201103L
                      explicit
         898 ->       _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
                	: _M_comp(std::move(__comp._M_comp))
                      { }
                #endif
                
                      template<typename _Value, typename _Iterator>
                	bool
        1728 -> 	operator()(_Value& __val, _Iterator __it)
                	{ return bool(_M_comp(__val, *__it)); }
                    };
                
                  template<typename _Compare>
                    inline _Val_comp_iter<_Compare>
                    __val_comp_iter(_Compare __comp)
                    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    inline _Val_comp_iter<_Compare>
         898 ->     __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
                    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Value>
                    struct _Iter_equals_val
                    {
                      _Value& _M_value;
                
                      explicit
                      _Iter_equals_val(_Value& __value)
                	: _M_value(__value)
                      { }
                
                      template<typename _Iterator>
                	bool
                	operator()(_Iterator __it)
                	{ return *__it == _M_value; }
                    };
                
                  template<typename _Value>
                    inline _Iter_equals_val<_Value>
                    __iter_equals_val(_Value& __val)
                    { return _Iter_equals_val<_Value>(__val); }
                
                  template<typename _Iterator1>
                    struct _Iter_equals_iter
                    {
                      _Iterator1 _M_it1;
                
                      explicit
                      _Iter_equals_iter(_Iterator1 __it1)
                	: _M_it1(__it1)
                      { }
                
                      template<typename _Iterator2>
                	bool
                	operator()(_Iterator2 __it2)
                	{ return *__it2 == *_M_it1; }
                    };
                
                  template<typename _Iterator>
                    inline _Iter_equals_iter<_Iterator>
                    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
                    { return _Iter_equals_iter<_Iterator>(__it); }
                
                  template<typename _Predicate>
                    struct _Iter_pred
                    {
                      _Predicate _M_pred;
                
                      explicit
                      _Iter_pred(_Predicate __pred)
                	: _M_pred(_GLIBCXX_MOVE(__pred))
                      { }
                
                      template<typename _Iterator>
                	bool
                	operator()(_Iterator __it)
                	{ return bool(_M_pred(*__it)); }
                    };
                
                  template<typename _Predicate>
                    inline _Iter_pred<_Predicate>
                    __pred_iter(_Predicate __pred)
                    { return _Iter_pred<_Predicate>(_GLIBCXX_MOVE(__pred)); }
                
                  template<typename _Compare, typename _Value>
                    struct _Iter_comp_to_val
                    {
                      _Compare _M_comp;
                      _Value& _M_value;
                
                      _Iter_comp_to_val(_Compare __comp, _Value& __value)
                	: _M_comp(_GLIBCXX_MOVE(__comp)), _M_value(__value)
                      { }
                
                      template<typename _Iterator>
                	bool
                	operator()(_Iterator __it)
                	{ return bool(_M_comp(*__it, _M_value)); }
                    };
                
                  template<typename _Compare, typename _Value>
                    _Iter_comp_to_val<_Compare, _Value>
                    __iter_comp_val(_Compare __comp, _Value &__val)
                    {
                      return _Iter_comp_to_val<_Compare, _Value>(_GLIBCXX_MOVE(__comp), __val);
                    }
                
                  template<typename _Compare, typename _Iterator1>
                    struct _Iter_comp_to_iter
                    {
                      _Compare _M_comp;
                      _Iterator1 _M_it1;
                
                      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
                	: _M_comp(_GLIBCXX_MOVE(__comp)), _M_it1(__it1)
                      { }
                
                      template<typename _Iterator2>
                	bool
                	operator()(_Iterator2 __it2)
                	{ return bool(_M_comp(*__it2, *_M_it1)); }
                    };
                
                  template<typename _Compare, typename _Iterator>
                    inline _Iter_comp_to_iter<_Compare, _Iterator>
                    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
                    {
                      return _Iter_comp_to_iter<_Compare, _Iterator>(
                	  _GLIBCXX_MOVE(__comp._M_comp), __it);
                    }
                
                  template<typename _Predicate>
                    struct _Iter_negate
                    {
                      _Predicate _M_pred;
                
                      explicit
                      _Iter_negate(_Predicate __pred)
                	: _M_pred(_GLIBCXX_MOVE(__pred))
                      { }
                
                      template<typename _Iterator>
                	bool
                	operator()(_Iterator __it)
                	{ return !bool(_M_pred(*__it)); }
                    };
                
                  template<typename _Predicate>
                    inline _Iter_negate<_Predicate>
                    __negate(_Iter_pred<_Predicate> __pred)
                    { return _Iter_negate<_Predicate>(_GLIBCXX_MOVE(__pred._M_pred)); }
                
                } // namespace __ops
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

      142       7861
      214       1728
      207        898
      225        898
      135          1
      149          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

    11387   Total number of line executions
  1423.38   Average executions per line


*** File /usr/include/c++/9/bits/stl_algo.h:
                // Algorithm implementation -*- C++ -*-
                
                // Copyright (C) 2001-2019 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algo.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGO_H
                #define _STL_ALGO_H 1
                
                #include <cstdlib>	     // for rand
                #include <bits/algorithmfwd.h>
                #include <bits/stl_heap.h>
                #include <bits/stl_tempbuf.h>  // for _Temporary_buffer
                #include <bits/predefined_ops.h>
                
                #if __cplusplus >= 201103L
                #include <bits/uniform_int_dist.h>
                #endif
                
                // See concept_check.h for the __glibcxx_*_requires macros.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
                  template<typename _Iterator, typename _Compare>
                    void
          94 ->     __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
                			   _Iterator __c, _Compare __comp)
                    {
                      if (__comp(__a, __b))
                	{
                	  if (__comp(__b, __c))
                	    std::iter_swap(__result, __b);
                	  else if (__comp(__a, __c))
                	    std::iter_swap(__result, __c);
                	  else
                	    std::iter_swap(__result, __a);
                	}
                      else if (__comp(__a, __c))
                	std::iter_swap(__result, __a);
                      else if (__comp(__b, __c))
                	std::iter_swap(__result, __c);
                      else
                	std::iter_swap(__result, __b);
                    }
                
                  /// This is an overload used by find algos for the Input Iterator case.
                  template<typename _InputIterator, typename _Predicate>
                    inline _InputIterator
                    __find_if(_InputIterator __first, _InputIterator __last,
                	      _Predicate __pred, input_iterator_tag)
                    {
                      while (__first != __last && !__pred(__first))
                	++__first;
                      return __first;
                    }
                
                  /// This is an overload used by find algos for the RAI case.
                  template<typename _RandomAccessIterator, typename _Predicate>
                    _RandomAccessIterator
                    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	      _Predicate __pred, random_access_iterator_tag)
                    {
                      typename iterator_traits<_RandomAccessIterator>::difference_type
                	__trip_count = (__last - __first) >> 2;
                
                      for (; __trip_count > 0; --__trip_count)
                	{
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	}
                
                      switch (__last - __first)
                	{
                	case 3:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	case 2:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	case 1:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	case 0:
                	default:
                	  return __last;
                	}
                    }
                
                  template<typename _Iterator, typename _Predicate>
                    inline _Iterator
                    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
                    {
                      return __find_if(__first, __last, __pred,
                		       std::__iterator_category(__first));
                    }
                
                  /// Provided for stable_partition to use.
                  template<typename _InputIterator, typename _Predicate>
                    inline _InputIterator
                    __find_if_not(_InputIterator __first, _InputIterator __last,
                		  _Predicate __pred)
                    {
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__negate(__pred),
                			    std::__iterator_category(__first));
                    }
                
                  /// Like find_if_not(), but uses and updates a count of the
                  /// remaining range length instead of comparing against an end
                  /// iterator.
                  template<typename _InputIterator, typename _Predicate, typename _Distance>
                    _InputIterator
                    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
                    {
                      for (; __len; --__len,  (void) ++__first)
                	if (!__pred(__first))
                	  break;
                      return __first;
                    }
                
                  // set_difference
                  // set_intersection
                  // set_symmetric_difference
                  // set_union
                  // for_each
                  // find
                  // find_if
                  // find_first_of
                  // adjacent_find
                  // count
                  // count_if
                  // search
                
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _ForwardIterator1
                    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	     _BinaryPredicate  __predicate)
                    {
                      // Test for empty ranges
                      if (__first1 == __last1 || __first2 == __last2)
                	return __first1;
                
                      // Test for a pattern of length 1.
                      _ForwardIterator2 __p1(__first2);
                      if (++__p1 == __last2)
                	return std::__find_if(__first1, __last1,
                		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
                
                      // General case.
                      _ForwardIterator2 __p;
                      _ForwardIterator1 __current = __first1;
                
                      for (;;)
                	{
                	  __first1 =
                	    std::__find_if(__first1, __last1,
                		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
                
                	  if (__first1 == __last1)
                	    return __last1;
                
                	  __p = __p1;
                	  __current = __first1;
                	  if (++__current == __last1)
                	    return __last1;
                
                	  while (__predicate(__current, __p))
                	    {
                	      if (++__p == __last2)
                		return __first1;
                	      if (++__current == __last1)
                		return __last1;
                	    }
                	  ++__first1;
                	}
                      return __first1;
                    }
                
                  // search_n
                
                  /**
                   *  This is an helper function for search_n overloaded for forward iterators.
                  */
                  template<typename _ForwardIterator, typename _Integer,
                	   typename _UnaryPredicate>
                    _ForwardIterator
                    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
                		   _Integer __count, _UnaryPredicate __unary_pred,
                		   std::forward_iterator_tag)
                    {
                      __first = std::__find_if(__first, __last, __unary_pred);
                      while (__first != __last)
                	{
                	  typename iterator_traits<_ForwardIterator>::difference_type
                	    __n = __count;
                	  _ForwardIterator __i = __first;
                	  ++__i;
                	  while (__i != __last && __n != 1 && __unary_pred(__i))
                	    {
                	      ++__i;
                	      --__n;
                	    }
                	  if (__n == 1)
                	    return __first;
                	  if (__i == __last)
                	    return __last;
                	  __first = std::__find_if(++__i, __last, __unary_pred);
                	}
                      return __last;
                    }
                
                  /**
                   *  This is an helper function for search_n overloaded for random access
                   *  iterators.
                  */
                  template<typename _RandomAccessIter, typename _Integer,
                	   typename _UnaryPredicate>
                    _RandomAccessIter
                    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
                		   _Integer __count, _UnaryPredicate __unary_pred,
                		   std::random_access_iterator_tag)
                    {
                      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
                	_DistanceType;
                
                      _DistanceType __tailSize = __last - __first;
                      _DistanceType __remainder = __count;
                
                      while (__remainder <= __tailSize) // the main loop...
                	{
                	  __first += __remainder;
                	  __tailSize -= __remainder;
                	  // __first here is always pointing to one past the last element of
                	  // next possible match.
                	  _RandomAccessIter __backTrack = __first; 
                	  while (__unary_pred(--__backTrack))
                	    {
                	      if (--__remainder == 0)
                		return (__first - __count); // Success
                	    }
                	  __remainder = __count + 1 - (__first - __backTrack);
                	}
                      return __last; // Failure
                    }
                
                  template<typename _ForwardIterator, typename _Integer,
                	   typename _UnaryPredicate>
                    _ForwardIterator
                    __search_n(_ForwardIterator __first, _ForwardIterator __last,
                	       _Integer __count,
                	       _UnaryPredicate __unary_pred)
                    {
                      if (__count <= 0)
                	return __first;
                
                      if (__count == 1)
                	return std::__find_if(__first, __last, __unary_pred);
                
                      return std::__search_n_aux(__first, __last, __count, __unary_pred,
                				 std::__iterator_category(__first));
                    }
                
                  // find_end for forward iterators.
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _ForwardIterator1
                    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	       forward_iterator_tag, forward_iterator_tag,
                	       _BinaryPredicate __comp)
                    {
                      if (__first2 == __last2)
                	return __last1;
                
                      _ForwardIterator1 __result = __last1;
                      while (1)
                	{
                	  _ForwardIterator1 __new_result
                	    = std::__search(__first1, __last1, __first2, __last2, __comp);
                	  if (__new_result == __last1)
                	    return __result;
                	  else
                	    {
                	      __result = __new_result;
                	      __first1 = __new_result;
                	      ++__first1;
                	    }
                	}
                    }
                
                  // find_end for bidirectional iterators (much faster).
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _BinaryPredicate>
                    _BidirectionalIterator1
                    __find_end(_BidirectionalIterator1 __first1,
                	       _BidirectionalIterator1 __last1,
                	       _BidirectionalIterator2 __first2,
                	       _BidirectionalIterator2 __last2,
                	       bidirectional_iterator_tag, bidirectional_iterator_tag,
                	       _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator1>)
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator2>)
                
                      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
                      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
                
                      _RevIterator1 __rlast1(__first1);
                      _RevIterator2 __rlast2(__first2);
                      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
                					      _RevIterator2(__last2), __rlast2,
                					      __comp);
                
                      if (__rresult == __rlast1)
                	return __last1;
                      else
                	{
                	  _BidirectionalIterator1 __result = __rresult.base();
                	  std::advance(__result, -std::distance(__first2, __last2));
                	  return __result;
                	}
                    }
                
                  /**
                   *  @brief  Find last matching subsequence in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of sequence to match.
                   *  @param  __last2   End of sequence to match.
                   *  @return   The last iterator @c i in the range
                   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
                   *  @p *(__first2+N) for each @c N in the range @p
                   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) and returns an iterator to the __first
                   *  element of the sub-sequence, or @p __last1 if the sub-sequence
                   *  is not found.  The sub-sequence will be the last such
                   *  subsequence contained in [__first1,__last1).
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.  This means that the returned
                   *  iterator @c i will be in the range @p
                   *  [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline _ForwardIterator1
                    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__find_end(__first1, __last1, __first2, __last2,
                			     std::__iterator_category(__first1),
                			     std::__iterator_category(__first2),
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Find last matching subsequence in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of sequence to match.
                   *  @param  __last2   End of sequence to match.
                   *  @param  __comp    The predicate to use.
                   *  @return The last iterator @c i in the range @p
                   *  [__first1,__last1-(__last2-__first2)) such that @c
                   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
                   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
                   *  exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) using comp as a predicate and returns an
                   *  iterator to the first element of the sub-sequence, or @p __last1
                   *  if the sub-sequence is not found.  The sub-sequence will be the
                   *  last such subsequence contained in [__first,__last1).
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.  This means that the returned
                   *  iterator @c i will be in the range @p
                   *  [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    inline _ForwardIterator1
                    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	     _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__find_end(__first1, __last1, __first2, __last2,
                			     std::__iterator_category(__first1),
                			     std::__iterator_category(__first2),
                			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Checks that a predicate is true for all the elements
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if @p __pred is true for each element in the range
                   *  @p [__first,__last), and false otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline bool
                    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return __last == std::find_if_not(__first, __last, __pred); }
                
                  /**
                   *  @brief  Checks that a predicate is false for all the elements
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if @p __pred is false for each element in the range
                   *  @p [__first,__last), and false otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline bool
                    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
                
                  /**
                   *  @brief  Checks that a predicate is true for at least one element
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if an element exists in the range @p
                   *  [__first,__last) such that @p __pred is true, and false
                   *  otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline bool
                    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return !std::none_of(__first, __last, __pred); }
                
                  /**
                   *  @brief  Find the first element in a sequence for which a
                   *          predicate is false.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline _InputIterator
                    find_if_not(_InputIterator __first, _InputIterator __last,
                		_Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      return std::__find_if_not(__first, __last,
                				__gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief  Checks whether the sequence is partitioned.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
                   *  i.e. if all elements that satisfy @p __pred appear before those that
                   *  do not.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline bool
                    is_partitioned(_InputIterator __first, _InputIterator __last,
                		   _Predicate __pred)
                    {
                      __first = std::find_if_not(__first, __last, __pred);
                      if (__first == __last)
                	return true;
                      ++__first;
                      return std::none_of(__first, __last, __pred);
                    }
                
                  /**
                   *  @brief  Find the partition point of a partitioned range.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __pred    A predicate.
                   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
                   *           and @p none_of(mid, __last, __pred) are both true.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _ForwardIterator
                    partition_point(_ForwardIterator __first, _ForwardIterator __last,
                		    _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_ForwardIterator>::value_type>)
                
                      // A specific debug-mode test will be necessary...
                      __glibcxx_requires_valid_range(__first, __last);
                
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                      _DistanceType __half;
                      _ForwardIterator __middle;
                
                      while (__len > 0)
                	{
                	  __half = __len >> 1;
                	  __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__pred(*__middle))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                #endif
                
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _OutputIterator
                    __remove_copy_if(_InputIterator __first, _InputIterator __last,
                		     _OutputIterator __result, _Predicate __pred)
                    {
                      for (; __first != __last; ++__first)
                	if (!__pred(__first))
                	  {
                	    *__result = *__first;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Copy a sequence, removing elements of a given value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __value   The value to be removed.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) not equal
                   *  to @p __value to the range beginning at @p __result.
                   *  remove_copy() is stable, so the relative order of elements that
                   *  are copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                    inline _OutputIterator
                    remove_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_copy_if(__first, __last, __result,
                	__gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Copy a sequence, removing elements for which a predicate is true.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns false to the range beginning at @p __result.
                   *
                   *  remove_copy_if() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    inline _OutputIterator
                    remove_copy_if(_InputIterator __first, _InputIterator __last,
                		   _OutputIterator __result, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_copy_if(__first, __last, __result,
                				   __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Copy the elements of a sequence for which a predicate is true.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns true to the range beginning at @p __result.
                   *
                   *  copy_if() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _OutputIterator
                    copy_if(_InputIterator __first, _InputIterator __last,
                	    _OutputIterator __result, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  {
                	    *__result = *__first;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _OutputIterator
                    __copy_n(_InputIterator __first, _Size __n,
                	     _OutputIterator __result, input_iterator_tag)
                    {
                      if (__n > 0)
                	{
                	  while (true)
                	    {
                	      *__result = *__first;
                	      ++__result;
                	      if (--__n > 0)
                		++__first;
                	      else
                		break;
                	    }
                	}
                      return __result;
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _OutputIterator>
                    inline _OutputIterator
                    __copy_n(_RandomAccessIterator __first, _Size __n,
                	     _OutputIterator __result, random_access_iterator_tag)
                    { return std::copy(__first, __first + __n, __result); }
                
                  /**
                   *  @brief Copies the range [first,first+n) into [result,result+n).
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  result+n.
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                  */
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    inline _OutputIterator
                    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                
                      if (__n <= 0)
                	return __result;
                
                      __glibcxx_requires_can_increment(__first, __n);
                      __glibcxx_requires_can_increment(__result, __n);
                
                      return std::__copy_n(__first, __n, __result,
                			   std::__iterator_category(__first));
                    }
                
                  /**
                   *  @brief Copy the elements of a sequence to separate output sequences
                   *         depending on the truth value of a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __out_true   An output iterator.
                   *  @param  __out_false  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   A pair designating the ends of the resulting sequences.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns true to the range beginning at @p out_true
                   *  and each element for which @p __pred returns false to @p __out_false.
                  */
                  template<typename _InputIterator, typename _OutputIterator1,
                	   typename _OutputIterator2, typename _Predicate>
                    pair<_OutputIterator1, _OutputIterator2>
                    partition_copy(_InputIterator __first, _InputIterator __last,
                		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
                		   _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  {
                	    *__out_true = *__first;
                	    ++__out_true;
                	  }
                	else
                	  {
                	    *__out_false = *__first;
                	    ++__out_false;
                	  }
                
                      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
                    }
                #endif
                
                  template<typename _ForwardIterator, typename _Predicate>
                    _ForwardIterator
                    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
                		_Predicate __pred)
                    {
                      __first = std::__find_if(__first, __last, __pred);
                      if (__first == __last)
                	return __first;
                      _ForwardIterator __result = __first;
                      ++__first;
                      for (; __first != __last; ++__first)
                	if (!__pred(__first))
                	  {
                	    *__result = _GLIBCXX_MOVE(*__first);
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Remove elements from a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __value  The value to be removed.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  All elements equal to @p __value are removed from the range
                   *  @p [__first,__last).
                   *
                   *  remove() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    remove(_ForwardIterator __first, _ForwardIterator __last,
                	   const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_if(__first, __last,
                		__gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Remove elements from a sequence using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __pred   A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  All elements for which @p __pred returns true are removed from the range
                   *  @p [__first,__last).
                   *
                   *  remove_if() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    inline _ForwardIterator
                    remove_if(_ForwardIterator __first, _ForwardIterator __last,
                	      _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_if(__first, __last,
                			      __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _ForwardIterator
                    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                		    _BinaryPredicate __binary_pred)
                    {
                      if (__first == __last)
                	return __last;
                      _ForwardIterator __next = __first;
                      while (++__next != __last)
                	{
                	  if (__binary_pred(__first, __next))
                	    return __first;
                	  __first = __next;
                	}
                      return __last;
                    }
                
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _ForwardIterator
                    __unique(_ForwardIterator __first, _ForwardIterator __last,
                	     _BinaryPredicate __binary_pred)
                    {
                      // Skip the beginning, if already unique.
                      __first = std::__adjacent_find(__first, __last, __binary_pred);
                      if (__first == __last)
                	return __last;
                
                      // Do the real copy work.
                      _ForwardIterator __dest = __first;
                      ++__first;
                      while (++__first != __last)
                	if (!__binary_pred(__dest, __first))
                	  *++__dest = _GLIBCXX_MOVE(*__first);
                      return ++__dest;
                    }
                
                  /**
                   *  @brief Remove consecutive duplicate values from a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Removes all but the first element from each group of consecutive
                   *  values that compare equal.
                   *  unique() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator>
                    inline _ForwardIterator
                    unique(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                		     typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__unique(__first, __last,
                			   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Remove consecutive values from a sequence using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Removes all but the first element from each group of consecutive
                   *  values for which @p __binary_pred returns true.
                   *  unique() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    inline _ForwardIterator
                    unique(_ForwardIterator __first, _ForwardIterator __last,
                	   _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                		typename iterator_traits<_ForwardIterator>::value_type,
                		typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__unique(__first, __last,
                			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for forward iterators and output iterator as result.
                  */
                  template<typename _ForwardIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _OutputIterator
                    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                		  forward_iterator_tag, output_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_ForwardIterator>::value_type,
                	  typename iterator_traits<_ForwardIterator>::value_type>)
                
                      _ForwardIterator __next = __first;
                      *__result = *__first;
                      while (++__next != __last)
                	if (!__binary_pred(__first, __next))
                	  {
                	    __first = __next;
                	    *++__result = *__first;
                	  }
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for input iterators and output iterator as result.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _OutputIterator
                    __unique_copy(_InputIterator __first, _InputIterator __last,
                		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                		  input_iterator_tag, output_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_InputIterator>::value_type,
                	  typename iterator_traits<_InputIterator>::value_type>)
                
                      typename iterator_traits<_InputIterator>::value_type __value = *__first;
                      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
                	__rebound_pred
                	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
                      *__result = __value;
                      while (++__first != __last)
                	if (!__rebound_pred(__first, __value))
                	  {
                	    __value = *__first;
                	    *++__result = __value;
                	  }
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for input iterators and forward iterator as result.
                  */
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _BinaryPredicate>
                    _ForwardIterator
                    __unique_copy(_InputIterator __first, _InputIterator __last,
                		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
                		  input_iterator_tag, forward_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_ForwardIterator>::value_type,
                	  typename iterator_traits<_InputIterator>::value_type>)
                      *__result = *__first;
                      while (++__first != __last)
                	if (!__binary_pred(__result, __first))
                	  *++__result = *__first;
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified reverse(_BidirectionalIterator,
                   *                              _BidirectionalIterator)
                   *  overloaded for bidirectional iterators.
                  */
                  template<typename _BidirectionalIterator>
                    void
                    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
                	      bidirectional_iterator_tag)
                    {
                      while (true)
                	if (__first == __last || __first == --__last)
                	  return;
                	else
                	  {
                	    std::iter_swap(__first, __last);
                	    ++__first;
                	  }
                    }
                
                  /**
                   *  This is an uglified reverse(_BidirectionalIterator,
                   *                              _BidirectionalIterator)
                   *  overloaded for random access iterators.
                  */
                  template<typename _RandomAccessIterator>
                    void
                    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	      random_access_iterator_tag)
                    {
                      if (__first == __last)
                	return;
                      --__last;
                      while (__first < __last)
                	{
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	  --__last;
                	}
                    }
                
                  /**
                   *  @brief Reverse a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @return   reverse() returns no value.
                   *
                   *  Reverses the order of the elements in the range @p [__first,__last),
                   *  so that the first element becomes the last etc.
                   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
                   *  swaps @p *(__first+i) and @p *(__last-(i+1))
                  */
                  template<typename _BidirectionalIterator>
                    inline void
                    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                      std::__reverse(__first, __last, std::__iterator_category(__first));
                    }
                
                  /**
                   *  @brief Copy a sequence, reversing its elements.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A bidirectional iterator.
                   *  @param  __last    A bidirectional iterator.
                   *  @param  __result  An output iterator.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Copies the elements in the range @p [__first,__last) to the
                   *  range @p [__result,__result+(__last-__first)) such that the
                   *  order of the elements is reversed.  For every @c i such that @p
                   *  0<=i<=(__last-__first), @p reverse_copy() performs the
                   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
                   *  The ranges @p [__first,__last) and @p
                   *  [__result,__result+(__last-__first)) must not overlap.
                  */
                  template<typename _BidirectionalIterator, typename _OutputIterator>
                    _OutputIterator
                    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
                		 _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                		typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      while (__first != __last)
                	{
                	  --__last;
                	  *__result = *__last;
                	  ++__result;
                	}
                      return __result;
                    }
                
                  /**
                   *  This is a helper function for the rotate algorithm specialized on RAIs.
                   *  It returns the greatest common divisor of two integer values.
                  */
                  template<typename _EuclideanRingElement>
                    _EuclideanRingElement
                    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
                    {
                      while (__n != 0)
                	{
                	  _EuclideanRingElement __t = __m % __n;
                	  __m = __n;
                	  __n = __t;
                	}
                      return __m;
                    }
                
                  inline namespace _V2
                  {
                
                  /// This is a helper function for the rotate algorithm.
                  template<typename _ForwardIterator>
                    _ForwardIterator
                    __rotate(_ForwardIterator __first,
                	     _ForwardIterator __middle,
                	     _ForwardIterator __last,
                	     forward_iterator_tag)
                    {
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      _ForwardIterator __first2 = __middle;
                      do
                	{
                	  std::iter_swap(__first, __first2);
                	  ++__first;
                	  ++__first2;
                	  if (__first == __middle)
                	    __middle = __first2;
                	}
                      while (__first2 != __last);
                
                      _ForwardIterator __ret = __first;
                
                      __first2 = __middle;
                
                      while (__first2 != __last)
                	{
                	  std::iter_swap(__first, __first2);
                	  ++__first;
                	  ++__first2;
                	  if (__first == __middle)
                	    __middle = __first2;
                	  else if (__first2 == __last)
                	    __first2 = __middle;
                	}
                      return __ret;
                    }
                
                   /// This is a helper function for the rotate algorithm.
                  template<typename _BidirectionalIterator>
                    _BidirectionalIterator
                    __rotate(_BidirectionalIterator __first,
                	     _BidirectionalIterator __middle,
                	     _BidirectionalIterator __last,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                      std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                
                      while (__first != __middle && __middle != __last)
                	{
                	  std::iter_swap(__first, --__last);
                	  ++__first;
                	}
                
                      if (__first == __middle)
                	{
                	  std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                	  return __last;
                	}
                      else
                	{
                	  std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                	  return __first;
                	}
                    }
                
                  /// This is a helper function for the rotate algorithm.
                  template<typename _RandomAccessIterator>
                    _RandomAccessIterator
                    __rotate(_RandomAccessIterator __first,
                	     _RandomAccessIterator __middle,
                	     _RandomAccessIterator __last,
                	     random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_Distance;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_ValueType;
                
                      _Distance __n = __last   - __first;
                      _Distance __k = __middle - __first;
                
                      if (__k == __n - __k)
                	{
                	  std::swap_ranges(__first, __middle, __middle);
                	  return __middle;
                	}
                
                      _RandomAccessIterator __p = __first;
                      _RandomAccessIterator __ret = __first + (__last - __middle);
                
                      for (;;)
                	{
                	  if (__k < __n - __k)
                	    {
                	      if (__is_pod(_ValueType) && __k == 1)
                		{
                		  _ValueType __t = _GLIBCXX_MOVE(*__p);
                		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
                		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
                		  return __ret;
                		}
                	      _RandomAccessIterator __q = __p + __k;
                	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                		{
                		  std::iter_swap(__p, __q);
                		  ++__p;
                		  ++__q;
                		}
                	      __n %= __k;
                	      if (__n == 0)
                		return __ret;
                	      std::swap(__n, __k);
                	      __k = __n - __k;
                	    }
                	  else
                	    {
                	      __k = __n - __k;
                	      if (__is_pod(_ValueType) && __k == 1)
                		{
                		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
                		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
                		  *__p = _GLIBCXX_MOVE(__t);
                		  return __ret;
                		}
                	      _RandomAccessIterator __q = __p + __n;
                	      __p = __q - __k;
                	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                		{
                		  --__p;
                		  --__q;
                		  std::iter_swap(__p, __q);
                		}
                	      __n %= __k;
                	      if (__n == 0)
                		return __ret;
                	      std::swap(__n, __k);
                	    }
                	}
                    }
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 488. rotate throws away useful information
                  /**
                   *  @brief Rotate the elements of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __middle  A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @return  first + (last - middle).
                   *
                   *  Rotates the elements of the range @p [__first,__last) by 
                   *  @p (__middle - __first) positions so that the element at @p __middle
                   *  is moved to @p __first, the element at @p __middle+1 is moved to
                   *  @p __first+1 and so on for each element in the range
                   *  @p [__first,__last).
                   *
                   *  This effectively swaps the ranges @p [__first,__middle) and
                   *  @p [__middle,__last).
                   *
                   *  Performs
                   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                   *  for each @p n in the range @p [0,__last-__first).
                  */
                  template<typename _ForwardIterator>
                    inline _ForwardIterator
                    rotate(_ForwardIterator __first, _ForwardIterator __middle,
                	   _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                
                      return std::__rotate(__first, __middle, __last,
                			   std::__iterator_category(__first));
                    }
                
                  } // namespace _V2
                
                  /**
                   *  @brief Copy a sequence, rotating its elements.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __middle  A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __result  An output iterator.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies the elements of the range @p [__first,__last) to the
                   *  range beginning at @result, rotating the copied elements by 
                   *  @p (__middle-__first) positions so that the element at @p __middle
                   *  is moved to @p __result, the element at @p __middle+1 is moved
                   *  to @p __result+1 and so on for each element in the range @p
                   *  [__first,__last).
                   *
                   *  Performs 
                   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                   *  for each @p n in the range @p [0,__last-__first).
                  */
                  template<typename _ForwardIterator, typename _OutputIterator>
                    inline _OutputIterator
                    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                		_ForwardIterator __last, _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                		typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                
                      return std::copy(__first, __middle,
                		       std::copy(__middle, __last, __result));
                    }
                
                  /// This is a helper function...
                  template<typename _ForwardIterator, typename _Predicate>
                    _ForwardIterator
                    __partition(_ForwardIterator __first, _ForwardIterator __last,
                		_Predicate __pred, forward_iterator_tag)
                    {
                      if (__first == __last)
                	return __first;
                
                      while (__pred(*__first))
                	if (++__first == __last)
                	  return __first;
                
                      _ForwardIterator __next = __first;
                
                      while (++__next != __last)
                	if (__pred(*__next))
                	  {
                	    std::iter_swap(__first, __next);
                	    ++__first;
                	  }
                
                      return __first;
                    }
                
                  /// This is a helper function...
                  template<typename _BidirectionalIterator, typename _Predicate>
                    _BidirectionalIterator
                    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
                		_Predicate __pred, bidirectional_iterator_tag)
                    {
                      while (true)
                	{
                	  while (true)
                	    if (__first == __last)
                	      return __first;
                	    else if (__pred(*__first))
                	      ++__first;
                	    else
                	      break;
                	  --__last;
                	  while (true)
                	    if (__first == __last)
                	      return __first;
                	    else if (!bool(__pred(*__last)))
                	      --__last;
                	    else
                	      break;
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	}
                    }
                
                  // partition
                
                  /// This is a helper function...
                  /// Requires __first != __last and !__pred(__first)
                  /// and __len == distance(__first, __last).
                  ///
                  /// !__pred(__first) allows us to guarantee that we don't
                  /// move-assign an element onto itself.
                  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
                	   typename _Distance>
                    _ForwardIterator
                    __stable_partition_adaptive(_ForwardIterator __first,
                				_ForwardIterator __last,
                				_Predicate __pred, _Distance __len,
                				_Pointer __buffer,
                				_Distance __buffer_size)
                    {
                      if (__len == 1)
                	return __first;
                
                      if (__len <= __buffer_size)
                	{
                	  _ForwardIterator __result1 = __first;
                	  _Pointer __result2 = __buffer;
                
                	  // The precondition guarantees that !__pred(__first), so
                	  // move that element to the buffer before starting the loop.
                	  // This ensures that we only call __pred once per element.
                	  *__result2 = _GLIBCXX_MOVE(*__first);
                	  ++__result2;
                	  ++__first;
                	  for (; __first != __last; ++__first)
                	    if (__pred(__first))
                	      {
                		*__result1 = _GLIBCXX_MOVE(*__first);
                		++__result1;
                	      }
                	    else
                	      {
                		*__result2 = _GLIBCXX_MOVE(*__first);
                		++__result2;
                	      }
                
                	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
                	  return __result1;
                	}
                
                      _ForwardIterator __middle = __first;
                      std::advance(__middle, __len / 2);
                      _ForwardIterator __left_split =
                	std::__stable_partition_adaptive(__first, __middle, __pred,
                					 __len / 2, __buffer,
                					 __buffer_size);
                
                      // Advance past true-predicate values to satisfy this
                      // function's preconditions.
                      _Distance __right_len = __len - __len / 2;
                      _ForwardIterator __right_split =
                	std::__find_if_not_n(__middle, __right_len, __pred);
                
                      if (__right_len)
                	__right_split =
                	  std::__stable_partition_adaptive(__right_split, __last, __pred,
                					   __right_len,
                					   __buffer, __buffer_size);
                
                      return std::rotate(__left_split, __middle, __right_split);
                    }
                
                  template<typename _ForwardIterator, typename _Predicate>
                    _ForwardIterator
                    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                		       _Predicate __pred)
                    {
                      __first = std::__find_if_not(__first, __last, __pred);
                
                      if (__first == __last)
                	return __first;
                
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _Temporary_buffer<_ForwardIterator, _ValueType>
                	__buf(__first, std::distance(__first, __last));
                      return
                	std::__stable_partition_adaptive(__first, __last, __pred,
                					 _DistanceType(__buf.requested_size()),
                					 __buf.begin(),
                					 _DistanceType(__buf.size()));
                    }
                
                  /**
                   *  @brief Move elements for which a predicate is true to the beginning
                   *         of a sequence, preserving relative ordering.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __pred    A predicate functor.
                   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                   *  iterator @p i in the range @p [first,middle) and false for each @p i
                   *  in the range @p [middle,last).
                   *
                   *  Performs the same function as @p partition() with the additional
                   *  guarantee that the relative ordering of elements in each group is
                   *  preserved, so any two elements @p x and @p y in the range
                   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
                   *  relative ordering after calling @p stable_partition().
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    inline _ForwardIterator
                    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                		     _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__stable_partition(__first, __last,
                				     __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /// This is a helper function for the sort routines.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
       ##### ->     __heap_select(_RandomAccessIterator __first,
                		  _RandomAccessIterator __middle,
                		  _RandomAccessIterator __last, _Compare __comp)
                    {
                      std::__make_heap(__first, __middle, __comp);
                      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
                	if (__comp(__i, __first))
                	  std::__pop_heap(__first, __middle, __i, __comp);
                    }
                
                  // partial_sort
                
                  template<typename _InputIterator, typename _RandomAccessIterator,
                	   typename _Compare>
                    _RandomAccessIterator
                    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
                			_RandomAccessIterator __result_first,
                			_RandomAccessIterator __result_last,
                			_Compare __comp)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
                      typedef typename _RItTraits::difference_type _DistanceType;
                
                      if (__result_first == __result_last)
                	return __result_last;
                      _RandomAccessIterator __result_real_last = __result_first;
                      while (__first != __last && __result_real_last != __result_last)
                	{
                	  *__result_real_last = *__first;
                	  ++__result_real_last;
                	  ++__first;
                	}
                      
                      std::__make_heap(__result_first, __result_real_last, __comp);
                      while (__first != __last)
                	{
                	  if (__comp(__first, __result_first))
                	    std::__adjust_heap(__result_first, _DistanceType(0),
                			       _DistanceType(__result_real_last
                					     - __result_first),
                			       _InputValueType(*__first), __comp);
                	  ++__first;
                	}
                      std::__sort_heap(__result_first, __result_real_last, __comp);
                      return __result_real_last;
                    }
                
                  /**
                   *  @brief Copy the smallest elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __result_first   A random-access iterator.
                   *  @param  __result_last    Another random-access iterator.
                   *  @return   An iterator indicating the end of the resulting sequence.
                   *
                   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                   *  to the range beginning at @p __result_first, where the number of
                   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                   *  @p (__result_last-__result_first).
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__result_first,__result_first+N) such that i precedes j then
                   *  *j<*i is false.
                   *  The value returned is @p __result_first+N.
                  */
                  template<typename _InputIterator, typename _RandomAccessIterator>
                    inline _RandomAccessIterator
                    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                		      _RandomAccessIterator __result_first,
                		      _RandomAccessIterator __result_last)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_OutputValueType;
                #endif
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                				  _OutputValueType>)
                      __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
                						     _OutputValueType>)
                      __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                      __glibcxx_requires_valid_range(__result_first, __result_last);
                
                      return std::__partial_sort_copy(__first, __last,
                				      __result_first, __result_last,
                				      __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Copy the smallest elements of a sequence using a predicate for
                   *         comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    Another input iterator.
                   *  @param  __result_first   A random-access iterator.
                   *  @param  __result_last    Another random-access iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return   An iterator indicating the end of the resulting sequence.
                   *
                   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                   *  to the range beginning at @p result_first, where the number of
                   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                   *  @p (__result_last-__result_first).
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__result_first,__result_first+N) such that i precedes j then
                   *  @p __comp(*j,*i) is false.
                   *  The value returned is @p __result_first+N.
                  */
                  template<typename _InputIterator, typename _RandomAccessIterator,
                	   typename _Compare>
                    inline _RandomAccessIterator
                    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                		      _RandomAccessIterator __result_first,
                		      _RandomAccessIterator __result_last,
                		      _Compare __comp)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_OutputValueType;
                #endif
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                				  _OutputValueType>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                				  _InputValueType, _OutputValueType>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                				  _OutputValueType, _OutputValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                      __glibcxx_requires_valid_range(__result_first, __result_last);
                
                      return std::__partial_sort_copy(__first, __last,
                				      __result_first, __result_last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
         898 ->     __unguarded_linear_insert(_RandomAccessIterator __last,
                			      _Compare __comp)
                    {
                      typename iterator_traits<_RandomAccessIterator>::value_type
                	__val = _GLIBCXX_MOVE(*__last);
                      _RandomAccessIterator __next = __last;
                      --__next;
                      while (__comp(__val, __next))
                	{
                	  *__last = _GLIBCXX_MOVE(*__next);
                	  __last = __next;
                	  --__next;
                	}
                      *__last = _GLIBCXX_MOVE(__val);
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
           1 ->     __insertion_sort(_RandomAccessIterator __first,
                		     _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__first == __last) return;
                
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	{
                	  if (__comp(__i, __first))
                	    {
                	      typename iterator_traits<_RandomAccessIterator>::value_type
                		__val = _GLIBCXX_MOVE(*__i);
                	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
                	      *__first = _GLIBCXX_MOVE(__val);
                	    }
                	  else
                	    std::__unguarded_linear_insert(__i,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                	}
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
           1 ->     __unguarded_insertion_sort(_RandomAccessIterator __first,
                			       _RandomAccessIterator __last, _Compare __comp)
                    {
                      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
                	std::__unguarded_linear_insert(__i,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  /**
                   *  @doctodo
                   *  This controls some aspect of the sort routines.
                  */
                  enum { _S_threshold = 16 };
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
           1 ->     __final_insertion_sort(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__last - __first > int(_S_threshold))
                	{
                	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
                	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
                					  __comp);
                	}
                      else
                	std::__insertion_sort(__first, __last, __comp);
                    }
                
                  /// This is a helper function...
                  template<typename _RandomAccessIterator, typename _Compare>
                    _RandomAccessIterator
          94 ->     __unguarded_partition(_RandomAccessIterator __first,
                			  _RandomAccessIterator __last,
                			  _RandomAccessIterator __pivot, _Compare __comp)
                    {
                      while (true)
                	{
                	  while (__comp(__first, __pivot))
                	    ++__first;
                	  --__last;
                	  while (__comp(__pivot, __last))
                	    --__last;
                	  if (!(__first < __last))
                	    return __first;
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	}
                    }
                
                  /// This is a helper function...
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline _RandomAccessIterator
          94 ->     __unguarded_partition_pivot(_RandomAccessIterator __first,
                				_RandomAccessIterator __last, _Compare __comp)
                    {
                      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
                      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                				  __comp);
                      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
                    }
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
       ##### ->     __partial_sort(_RandomAccessIterator __first,
                		   _RandomAccessIterator __middle,
                		   _RandomAccessIterator __last,
                		   _Compare __comp)
                    {
                      std::__heap_select(__first, __middle, __last, __comp);
                      std::__sort_heap(__first, __middle, __comp);
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                    void
           1 ->     __introsort_loop(_RandomAccessIterator __first,
                		     _RandomAccessIterator __last,
                		     _Size __depth_limit, _Compare __comp)
                    {
                      while (__last - __first > int(_S_threshold))
                	{
                	  if (__depth_limit == 0)
                	    {
                	      std::__partial_sort(__first, __last, __last, __comp);
                	      return;
                	    }
                	  --__depth_limit;
                	  _RandomAccessIterator __cut =
                	    std::__unguarded_partition_pivot(__first, __last, __comp);
                	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
                	  __last = __cut;
                	}
                    }
                
                  // sort
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
           1 ->     __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	   _Compare __comp)
                    {
                      if (__first != __last)
                	{
                	  std::__introsort_loop(__first, __last,
                				std::__lg(__last - __first) * 2,
                				__comp);
                	  std::__final_insertion_sort(__first, __last, __comp);
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                    void
                    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		  _RandomAccessIterator __last, _Size __depth_limit,
                		  _Compare __comp)
                    {
                      while (__last - __first > 3)
                	{
                	  if (__depth_limit == 0)
                	    {
                	      std::__heap_select(__first, __nth + 1, __last, __comp);
                	      // Place the nth largest element in its final position.
                	      std::iter_swap(__first, __nth);
                	      return;
                	    }
                	  --__depth_limit;
                	  _RandomAccessIterator __cut =
                	    std::__unguarded_partition_pivot(__first, __last, __comp);
                	  if (__cut <= __nth)
                	    __first = __cut;
                	  else
                	    __last = __cut;
                	}
                      std::__insertion_sort(__first, __last, __comp);
                    }
                
                  // nth_element
                
                  // lower_bound moved to stl_algobase.h
                
                  /**
                   *  @brief Finds the first position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return An iterator pointing to the first element <em>not less
                   *           than</em> @p __val, or end() if every element is less
                   *           than @p __val.
                   *  @ingroup binary_search_algorithms
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_comp_val(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _ForwardIterator
                    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__val, __middle))
                	    __len = __half;
                	  else
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the last position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return  An iterator pointing to the first element greater than @p __val,
                   *           or end() if no elements are greater than @p __val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
                    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      return std::__upper_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__val_less_iter());
                    }
                
                  /**
                   *  @brief Finds the last position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  An iterator pointing to the first element greater than @p __val,
                   *           or end() if no elements are greater than @p __val.
                   *  @ingroup binary_search_algorithms
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    inline _ForwardIterator
                    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      return std::__upper_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Tp,
                	   typename _CompareItTp, typename _CompareTpIt>
                    pair<_ForwardIterator, _ForwardIterator>
                    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val,
                		  _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp_it_val(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else if (__comp_val_it(__val, __middle))
                	    __len = __half;
                	  else
                	    {
                	      _ForwardIterator __left
                		= std::__lower_bound(__first, __middle, __val, __comp_it_val);
                	      std::advance(__first, __len);
                	      _ForwardIterator __right
                		= std::__upper_bound(++__middle, __first, __val, __comp_val_it);
                	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
                	    }
                	}
                      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
                    }
                
                  /**
                   *  @brief Finds the largest subrange in which @p __val could be inserted
                   *         at any place in it without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return  An pair of iterators defining the subrange.
                   *  @ingroup binary_search_algorithms
                   *
                   *  This is equivalent to
                   *  @code
                   *    std::make_pair(lower_bound(__first, __last, __val),
                   *                   upper_bound(__first, __last, __val))
                   *  @endcode
                   *  but does not actually call those functions.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline pair<_ForwardIterator, _ForwardIterator>
                    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      return std::__equal_range(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val(),
                				__gnu_cxx::__ops::__val_less_iter());
                    }
                
                  /**
                   *  @brief Finds the largest subrange in which @p __val could be inserted
                   *         at any place in it without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  An pair of iterators defining the subrange.
                   *  @ingroup binary_search_algorithms
                   *
                   *  This is equivalent to
                   *  @code
                   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
                   *                   upper_bound(__first, __last, __val, __comp))
                   *  @endcode
                   *  but does not actually call those functions.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    inline pair<_ForwardIterator, _ForwardIterator>
                    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      return std::__equal_range(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_comp_val(__comp),
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Determines whether an element exists in a range.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return True if @p __val (or its equivalent) is in [@p
                   *  __first,@p __last ].
                   *
                   *  Note that this does not actually return an iterator to @p __val.  For
                   *  that, use std::find or a container's specialized find member functions.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    bool
                    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      _ForwardIterator __i
                	= std::__lower_bound(__first, __last, __val,
                			     __gnu_cxx::__ops::__iter_less_val());
                      return __i != __last && !(__val < *__i);
                    }
                
                  /**
                   *  @brief Determines whether an element exists in a range.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
                   *
                   *  Note that this does not actually return an iterator to @p __val.  For
                   *  that, use std::find or a container's specialized find member functions.
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    bool
                    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      _ForwardIterator __i
                	= std::__lower_bound(__first, __last, __val,
                			     __gnu_cxx::__ops::__iter_comp_val(__comp));
                      return __i != __last && !bool(__comp(__val, *__i));
                    }
                
                  // merge
                
                  /// This is a helper function for the __merge_adaptive routines.
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    void
                    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
                			  _InputIterator2 __first2, _InputIterator2 __last2,
                			  _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first2);
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first1);
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      if (__first1 != __last1)
                	_GLIBCXX_MOVE3(__first1, __last1, __result);
                    }
                
                  /// This is a helper function for the __merge_adaptive routines.
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _BidirectionalIterator3, typename _Compare>
                    void
                    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
                				   _BidirectionalIterator1 __last1,
                				   _BidirectionalIterator2 __first2,
                				   _BidirectionalIterator2 __last2,
                				   _BidirectionalIterator3 __result,
                				   _Compare __comp)
                    {
                      if (__first1 == __last1)
                	{
                	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
                	  return;
                	}
                      else if (__first2 == __last2)
                	return;
                
                      --__last1;
                      --__last2;
                      while (true)
                	{
                	  if (__comp(__last2, __last1))
                	    {
                	      *--__result = _GLIBCXX_MOVE(*__last1);
                	      if (__first1 == __last1)
                		{
                		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
                		  return;
                		}
                	      --__last1;
                	    }
                	  else
                	    {
                	      *--__result = _GLIBCXX_MOVE(*__last2);
                	      if (__first2 == __last2)
                		return;
                	      --__last2;
                	    }
                	}
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _Distance>
                    _BidirectionalIterator1
                    __rotate_adaptive(_BidirectionalIterator1 __first,
                		      _BidirectionalIterator1 __middle,
                		      _BidirectionalIterator1 __last,
                		      _Distance __len1, _Distance __len2,
                		      _BidirectionalIterator2 __buffer,
                		      _Distance __buffer_size)
                    {
                      _BidirectionalIterator2 __buffer_end;
                      if (__len1 > __len2 && __len2 <= __buffer_size)
                	{
                	  if (__len2)
                	    {
                	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
                	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
                	    }
                	  else
                	    return __first;
                	}
                      else if (__len1 <= __buffer_size)
                	{
                	  if (__len1)
                	    {
                	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                	      _GLIBCXX_MOVE3(__middle, __last, __first);
                	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
                	    }
                	  else
                	    return __last;
                	}
                      else
                	return std::rotate(__first, __middle, __last);
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator, typename _Distance, 
                	   typename _Pointer, typename _Compare>
                    void
                    __merge_adaptive(_BidirectionalIterator __first,
                		     _BidirectionalIterator __middle,
                		     _BidirectionalIterator __last,
                		     _Distance __len1, _Distance __len2,
                		     _Pointer __buffer, _Distance __buffer_size,
                		     _Compare __comp)
                    {
                      if (__len1 <= __len2 && __len1 <= __buffer_size)
                	{
                	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
                				     __first, __comp);
                	}
                      else if (__len2 <= __buffer_size)
                	{
                	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
                					      __buffer_end, __last, __comp);
                	}
                      else
                	{
                	  _BidirectionalIterator __first_cut = __first;
                	  _BidirectionalIterator __second_cut = __middle;
                	  _Distance __len11 = 0;
                	  _Distance __len22 = 0;
                	  if (__len1 > __len2)
                	    {
                	      __len11 = __len1 / 2;
                	      std::advance(__first_cut, __len11);
                	      __second_cut
                		= std::__lower_bound(__middle, __last, *__first_cut,
                				     __gnu_cxx::__ops::__iter_comp_val(__comp));
                	      __len22 = std::distance(__middle, __second_cut);
                	    }
                	  else
                	    {
                	      __len22 = __len2 / 2;
                	      std::advance(__second_cut, __len22);
                	      __first_cut
                		= std::__upper_bound(__first, __middle, *__second_cut,
                				     __gnu_cxx::__ops::__val_comp_iter(__comp));
                	      __len11 = std::distance(__first, __first_cut);
                	    }
                
                	  _BidirectionalIterator __new_middle
                	    = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
                				     __len1 - __len11, __len22, __buffer,
                				     __buffer_size);
                	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
                				__len22, __buffer, __buffer_size, __comp);
                	  std::__merge_adaptive(__new_middle, __second_cut, __last,
                				__len1 - __len11,
                				__len2 - __len22, __buffer,
                				__buffer_size, __comp);
                	}
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator, typename _Distance,
                	   typename _Compare>
                    void
                    __merge_without_buffer(_BidirectionalIterator __first,
                			   _BidirectionalIterator __middle,
                			   _BidirectionalIterator __last,
                			   _Distance __len1, _Distance __len2,
                			   _Compare __comp)
                    {
                      if (__len1 == 0 || __len2 == 0)
                	return;
                
                      if (__len1 + __len2 == 2)
                	{
                	  if (__comp(__middle, __first))
                	    std::iter_swap(__first, __middle);
                	  return;
                	}
                
                      _BidirectionalIterator __first_cut = __first;
                      _BidirectionalIterator __second_cut = __middle;
                      _Distance __len11 = 0;
                      _Distance __len22 = 0;
                      if (__len1 > __len2)
                	{
                	  __len11 = __len1 / 2;
                	  std::advance(__first_cut, __len11);
                	  __second_cut
                	    = std::__lower_bound(__middle, __last, *__first_cut,
                				 __gnu_cxx::__ops::__iter_comp_val(__comp));
                	  __len22 = std::distance(__middle, __second_cut);
                	}
                      else
                	{
                	  __len22 = __len2 / 2;
                	  std::advance(__second_cut, __len22);
                	  __first_cut
                	    = std::__upper_bound(__first, __middle, *__second_cut,
                				 __gnu_cxx::__ops::__val_comp_iter(__comp));
                	  __len11 = std::distance(__first, __first_cut);
                	}
                
                      _BidirectionalIterator __new_middle
                	= std::rotate(__first_cut, __middle, __second_cut);
                      std::__merge_without_buffer(__first, __first_cut, __new_middle,
                				  __len11, __len22, __comp);
                      std::__merge_without_buffer(__new_middle, __second_cut, __last,
                				  __len1 - __len11, __len2 - __len22, __comp);
                    }
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    void
                    __inplace_merge(_BidirectionalIterator __first,
                		    _BidirectionalIterator __middle,
                		    _BidirectionalIterator __last,
                		    _Compare __comp)
                    {
                      typedef typename iterator_traits<_BidirectionalIterator>::value_type
                	  _ValueType;
                      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
                	  _DistanceType;
                
                      if (__first == __middle || __middle == __last)
                	return;
                
                      const _DistanceType __len1 = std::distance(__first, __middle);
                      const _DistanceType __len2 = std::distance(__middle, __last);
                
                      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
                      _TmpBuf __buf(__first, __len1 + __len2);
                
                      if (__buf.begin() == 0)
                	std::__merge_without_buffer
                	  (__first, __middle, __last, __len1, __len2, __comp);
                      else
                	std::__merge_adaptive
                	  (__first, __middle, __last, __len1, __len2, __buf.begin(),
                	   _DistanceType(__buf.size()), __comp);
                    }
                
                  /**
                   *  @brief Merges two sorted ranges in place.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                   *  [__middle,__last), and puts the result in [__first,__last).  The
                   *  output will be sorted.  The sort is @e stable, that is, for
                   *  equivalent elements in the two ranges, elements from the first
                   *  range will always come before elements from the second.
                   *
                   *  If enough additional memory is available, this takes (__last-__first)-1
                   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                   *  distance(__first,__last).
                  */
                  template<typename _BidirectionalIterator>
                    inline void
                    inplace_merge(_BidirectionalIterator __first,
                		  _BidirectionalIterator __middle,
                		  _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                	    _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_sorted(__first, __middle);
                      __glibcxx_requires_sorted(__middle, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__inplace_merge(__first, __middle, __last,
                			   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Merges two sorted ranges in place.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  Nothing.
                   *
                   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                   *  [middle,last), and puts the result in [__first,__last).  The output will
                   *  be sorted.  The sort is @e stable, that is, for equivalent
                   *  elements in the two ranges, elements from the first range will always
                   *  come before elements from the second.
                   *
                   *  If enough additional memory is available, this takes (__last-__first)-1
                   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                   *  distance(__first,__last).
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    inline void
                    inplace_merge(_BidirectionalIterator __first,
                		  _BidirectionalIterator __middle,
                		  _BidirectionalIterator __last,
                		  _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                	    _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_sorted_pred(__first, __middle, __comp);
                      __glibcxx_requires_sorted_pred(__middle, __last, __comp);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__inplace_merge(__first, __middle, __last,
                			   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                
                  /// This is a helper function for the __merge_sort_loop routines.
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __move_merge(_InputIterator __first1, _InputIterator __last1,
                		 _InputIterator __first2, _InputIterator __last2,
                		 _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first2);
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first1);
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      return _GLIBCXX_MOVE3(__first2, __last2,
                			    _GLIBCXX_MOVE3(__first1, __last1,
                					   __result));
                    }
                
                  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
                	   typename _Distance, typename _Compare>
                    void
                    __merge_sort_loop(_RandomAccessIterator1 __first,
                		      _RandomAccessIterator1 __last,
                		      _RandomAccessIterator2 __result, _Distance __step_size,
                		      _Compare __comp)
                    {
                      const _Distance __two_step = 2 * __step_size;
                
                      while (__last - __first >= __two_step)
                	{
                	  __result = std::__move_merge(__first, __first + __step_size,
                				       __first + __step_size,
                				       __first + __two_step,
                				       __result, __comp);
                	  __first += __two_step;
                	}
                      __step_size = std::min(_Distance(__last - __first), __step_size);
                
                      std::__move_merge(__first, __first + __step_size,
                			__first + __step_size, __last, __result, __comp);
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance,
                	   typename _Compare>
                    void
                    __chunk_insertion_sort(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last,
                			   _Distance __chunk_size, _Compare __comp)
                    {
                      while (__last - __first >= __chunk_size)
                	{
                	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
                	  __first += __chunk_size;
                	}
                      std::__insertion_sort(__first, __last, __comp);
                    }
                
                  enum { _S_chunk_size = 7 };
                
                  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
                    void
                    __merge_sort_with_buffer(_RandomAccessIterator __first,
                			     _RandomAccessIterator __last,
                			     _Pointer __buffer, _Compare __comp)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_Distance;
                
                      const _Distance __len = __last - __first;
                      const _Pointer __buffer_last = __buffer + __len;
                
                      _Distance __step_size = _S_chunk_size;
                      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
                
                      while (__step_size < __len)
                	{
                	  std::__merge_sort_loop(__first, __last, __buffer,
                				 __step_size, __comp);
                	  __step_size *= 2;
                	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
                				 __step_size, __comp);
                	  __step_size *= 2;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Pointer,
                	   typename _Distance, typename _Compare>
                    void
                    __stable_sort_adaptive(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last,
                			   _Pointer __buffer, _Distance __buffer_size,
                			   _Compare __comp)
                    {
                      const _Distance __len = (__last - __first + 1) / 2;
                      const _RandomAccessIterator __middle = __first + __len;
                      if (__len > __buffer_size)
                	{
                	  std::__stable_sort_adaptive(__first, __middle, __buffer,
                				      __buffer_size, __comp);
                	  std::__stable_sort_adaptive(__middle, __last, __buffer,
                				      __buffer_size, __comp);
                	}
                      else
                	{
                	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
                	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
                	}
                      std::__merge_adaptive(__first, __middle, __last,
                			    _Distance(__middle - __first),
                			    _Distance(__last - __middle),
                			    __buffer, __buffer_size,
                			    __comp);
                    }
                
                  /// This is a helper function for the stable sorting routines.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
                    __inplace_stable_sort(_RandomAccessIterator __first,
                			  _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__last - __first < 15)
                	{
                	  std::__insertion_sort(__first, __last, __comp);
                	  return;
                	}
                      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
                      std::__inplace_stable_sort(__first, __middle, __comp);
                      std::__inplace_stable_sort(__middle, __last, __comp);
                      std::__merge_without_buffer(__first, __middle, __last,
                				  __middle - __first,
                				  __last - __middle,
                				  __comp);
                    }
                
                  // stable_sort
                
                  // Set algorithms: includes, set_union, set_intersection, set_difference,
                  // set_symmetric_difference.  All of these algorithms have the precondition
                  // that their input ranges are sorted and the postcondition that their output
                  // ranges are sorted.
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    bool
                    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first2, __first1))
                	  return false;
                	else if (__comp(__first1, __first2))
                	  ++__first1;
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                
                      return __first2 == __last2;
                    }
                
                  /**
                   *  @brief Determines whether all elements of a sequence exists in a range.
                   *  @param  __first1  Start of search range.
                   *  @param  __last1   End of search range.
                   *  @param  __first2  Start of sequence
                   *  @param  __last2   End of sequence.
                   *  @return  True if each element in [__first2,__last2) is contained in order
                   *  within [__first1,__last1).  False otherwise.
                   *  @ingroup set_algorithms
                   *
                   *  This operation expects both [__first1,__last1) and
                   *  [__first2,__last2) to be sorted.  Searches for the presence of
                   *  each element in [__first2,__last2) within [__first1,__last1).
                   *  The iterators over each range only move forward, so this is a
                   *  linear algorithm.  If an element in [__first2,__last2) is not
                   *  found before the search iterator reaches @p __last2, false is
                   *  returned.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    inline bool
                    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return std::__includes(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Determines whether all elements of a sequence exists in a range
                   *  using comparison.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of search range.
                   *  @param  __last1   End of search range.
                   *  @param  __first2  Start of sequence
                   *  @param  __last2   End of sequence.
                   *  @param  __comp    Comparison function to use.
                   *  @return True if each element in [__first2,__last2) is contained
                   *  in order within [__first1,__last1) according to comp.  False
                   *  otherwise.  @ingroup set_algorithms
                   *
                   *  This operation expects both [__first1,__last1) and
                   *  [__first2,__last2) to be sorted.  Searches for the presence of
                   *  each element in [__first2,__last2) within [__first1,__last1),
                   *  using comp to decide.  The iterators over each range only move
                   *  forward, so this is a linear algorithm.  If an element in
                   *  [__first2,__last2) is not found before the search iterator
                   *  reaches @p __last2, false is returned.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    inline bool
                    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return std::__includes(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // nth_element
                  // merge
                  // set_difference
                  // set_intersection
                  // set_union
                  // stable_sort
                  // set_symmetric_difference
                  // min_element
                  // max_element
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    bool
                    __next_permutation(_BidirectionalIterator __first,
                		       _BidirectionalIterator __last, _Compare __comp)
                    {
                      if (__first == __last)
                	return false;
                      _BidirectionalIterator __i = __first;
                      ++__i;
                      if (__i == __last)
                	return false;
                      __i = __last;
                      --__i;
                
                      for(;;)
                	{
                	  _BidirectionalIterator __ii = __i;
                	  --__i;
                	  if (__comp(__i, __ii))
                	    {
                	      _BidirectionalIterator __j = __last;
                	      while (!__comp(__i, --__j))
                		{}
                	      std::iter_swap(__i, __j);
                	      std::__reverse(__ii, __last,
                			     std::__iterator_category(__first));
                	      return true;
                	    }
                	  if (__i == __first)
                	    {
                	      std::__reverse(__first, __last,
                			     std::__iterator_category(__first));
                	      return false;
                	    }
                	}
                    }
                
                  /**
                   *  @brief  Permute range into the next @e dictionary ordering.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  False if wrapped to first permutation, true otherwise.
                   *
                   *  Treats all permutations of the range as a set of @e dictionary sorted
                   *  sequences.  Permutes the current sequence into the next one of this set.
                   *  Returns true if there are more sequences to generate.  If the sequence
                   *  is the largest of the set, the smallest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator>
                    inline bool
                    next_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__next_permutation
                	(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Permute range into the next @e dictionary ordering using
                   *          comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   A comparison functor.
                   *  @return  False if wrapped to first permutation, true otherwise.
                   *
                   *  Treats all permutations of the range [__first,__last) as a set of
                   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                   *  sequence into the next one of this set.  Returns true if there are more
                   *  sequences to generate.  If the sequence is the largest of the set, the
                   *  smallest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    inline bool
                    next_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__next_permutation
                	(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    bool
                    __prev_permutation(_BidirectionalIterator __first,
                		       _BidirectionalIterator __last, _Compare __comp)
                    {
                      if (__first == __last)
                	return false;
                      _BidirectionalIterator __i = __first;
                      ++__i;
                      if (__i == __last)
                	return false;
                      __i = __last;
                      --__i;
                
                      for(;;)
                	{
                	  _BidirectionalIterator __ii = __i;
                	  --__i;
                	  if (__comp(__ii, __i))
                	    {
                	      _BidirectionalIterator __j = __last;
                	      while (!__comp(--__j, __i))
                		{}
                	      std::iter_swap(__i, __j);
                	      std::__reverse(__ii, __last,
                			     std::__iterator_category(__first));
                	      return true;
                	    }
                	  if (__i == __first)
                	    {
                	      std::__reverse(__first, __last,
                			     std::__iterator_category(__first));
                	      return false;
                	    }
                	}
                    }
                
                  /**
                   *  @brief  Permute range into the previous @e dictionary ordering.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  False if wrapped to last permutation, true otherwise.
                   *
                   *  Treats all permutations of the range as a set of @e dictionary sorted
                   *  sequences.  Permutes the current sequence into the previous one of this
                   *  set.  Returns true if there are more sequences to generate.  If the
                   *  sequence is the smallest of the set, the largest is generated and false
                   *  returned.
                  */
                  template<typename _BidirectionalIterator>
                    inline bool
                    prev_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__prev_permutation(__first, __last,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Permute range into the previous @e dictionary ordering using
                   *          comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   A comparison functor.
                   *  @return  False if wrapped to last permutation, true otherwise.
                   *
                   *  Treats all permutations of the range [__first,__last) as a set of
                   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                   *  sequence into the previous one of this set.  Returns true if there are
                   *  more sequences to generate.  If the sequence is the smallest of the set,
                   *  the largest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    inline bool
                    prev_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__prev_permutation(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // replace
                  // replace_if
                
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate, typename _Tp>
                    _OutputIterator
                    __replace_copy_if(_InputIterator __first, _InputIterator __last,
                		      _OutputIterator __result,
                		      _Predicate __pred, const _Tp& __new_value)
                    {
                      for (; __first != __last; ++__first, (void)++__result)
                	if (__pred(__first))
                	  *__result = __new_value;
                	else
                	  *__result = *__first;
                      return __result;
                    }
                
                  /**
                   *  @brief Copy a sequence, replacing each element of one value with another
                   *         value.
                   *  @param  __first      An input iterator.
                   *  @param  __last       An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __old_value  The value to be replaced.
                   *  @param  __new_value  The replacement value.
                   *  @return   The end of the output sequence, @p result+(last-first).
                   *
                   *  Copies each element in the input range @p [__first,__last) to the
                   *  output range @p [__result,__result+(__last-__first)) replacing elements
                   *  equal to @p __old_value with @p __new_value.
                  */
                  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                    inline _OutputIterator
                    replace_copy(_InputIterator __first, _InputIterator __last,
                		 _OutputIterator __result,
                		 const _Tp& __old_value, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__replace_copy_if(__first, __last, __result,
                			__gnu_cxx::__ops::__iter_equals_val(__old_value),
                					      __new_value);
                    }
                
                  /**
                   *  @brief Copy a sequence, replacing each value for which a predicate
                   *         returns true with another value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      An input iterator.
                   *  @param  __last       An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __pred       A predicate.
                   *  @param  __new_value  The replacement value.
                   *  @return   The end of the output sequence, @p __result+(__last-__first).
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  @p [__result,__result+(__last-__first)) replacing elements for which
                   *  @p __pred returns true with @p __new_value.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate, typename _Tp>
                    inline _OutputIterator
                    replace_copy_if(_InputIterator __first, _InputIterator __last,
                		    _OutputIterator __result,
                		    _Predicate __pred, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__replace_copy_if(__first, __last, __result,
                				__gnu_cxx::__ops::__pred_iter(__pred),
                					      __new_value);
                    }
                
                  template<typename _InputIterator, typename _Predicate>
                    typename iterator_traits<_InputIterator>::difference_type
                    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    {
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      for (; __first != __last; ++__first)
                	if (__pred(__first))
                	  ++__n;
                      return __n;
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Determines whether the elements of a sequence are sorted.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  True if the elements are sorted, false otherwise.
                  */
                  template<typename _ForwardIterator>
                    inline bool
                    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
                    { return std::is_sorted_until(__first, __last) == __last; }
                
                  /**
                   *  @brief  Determines whether the elements of a sequence are sorted
                   *          according to a comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  True if the elements are sorted, false otherwise.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    inline bool
                    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
                	      _Compare __comp)
                    { return std::is_sorted_until(__first, __last, __comp) == __last; }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _ForwardIterator
                    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                		      _Compare __comp)
                    {
                      if (__first == __last)
                	return __last;
                
                      _ForwardIterator __next = __first;
                      for (++__next; __next != __last; __first = __next, (void)++__next)
                	if (__comp(__next, __first))
                	  return __next;
                      return __next;
                    }
                
                  /**
                   *  @brief  Determines the end of a sorted sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                   *           for which the range [__first, i) is sorted.
                  */
                  template<typename _ForwardIterator>
                    inline _ForwardIterator
                    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__is_sorted_until(__first, __last,
                				    __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Determines the end of a sorted sequence using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                   *           for which the range [__first, i) is sorted.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    inline _ForwardIterator
                    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                		    _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__is_sorted_until(__first, __last,
                				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief  Determines min and max at once as an ordered pair.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                   *  __b) otherwise.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<const _Tp&, const _Tp&>
                    minmax(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                
                      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                		       : pair<const _Tp&, const _Tp&>(__a, __b);
                    }
                
                  /**
                   *  @brief  Determines min and max at once as an ordered pair.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
                   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                   *  __b) otherwise.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<const _Tp&, const _Tp&>
                    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                			      : pair<const _Tp&, const _Tp&>(__a, __b);
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    pair<_ForwardIterator, _ForwardIterator>
                    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                		     _Compare __comp)
                    {
                      _ForwardIterator __next = __first;
                      if (__first == __last
                	  || ++__next == __last)
                	return std::make_pair(__first, __first);
                
                      _ForwardIterator __min{}, __max{};
                      if (__comp(__next, __first))
                	{
                	  __min = __next;
                	  __max = __first;
                	}
                      else
                	{
                	  __min = __first;
                	  __max = __next;
                	}
                
                      __first = __next;
                      ++__first;
                
                      while (__first != __last)
                	{
                	  __next = __first;
                	  if (++__next == __last)
                	    {
                	      if (__comp(__first, __min))
                		__min = __first;
                	      else if (!__comp(__first, __max))
                		__max = __first;
                	      break;
                	    }
                
                	  if (__comp(__next, __first))
                	    {
                	      if (__comp(__next, __min))
                		__min = __next;
                	      if (!__comp(__first, __max))
                		__max = __first;
                	    }
                	  else
                	    {
                	      if (__comp(__first, __min))
                		__min = __first;
                	      if (!__comp(__next, __max))
                		__max = __next;
                	    }
                
                	  __first = __next;
                	  ++__first;
                	}
                
                      return std::make_pair(__min, __max);
                    }
                
                  /**
                   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                   *          elements in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  make_pair(m, M), where m is the first iterator i in 
                   *           [__first, __last) such that no other element in the range is
                   *           smaller, and where M is the last iterator i in [__first, __last)
                   *           such that no other element in the range is larger.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__minmax_element(__first, __last,
                				   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                   *          elements in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  make_pair(m, M), where m is the first iterator i in 
                   *           [__first, __last) such that no other element in the range is
                   *           smaller, and where M is the last iterator i in [__first, __last)
                   *           such that no other element in the range is larger.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                		   _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__minmax_element(__first, __last,
                				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // N2722 + DR 915.
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    min(initializer_list<_Tp> __l)
                    { return *std::min_element(__l.begin(), __l.end()); }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    min(initializer_list<_Tp> __l, _Compare __comp)
                    { return *std::min_element(__l.begin(), __l.end(), __comp); }
                
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    max(initializer_list<_Tp> __l)
                    { return *std::max_element(__l.begin(), __l.end()); }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    max(initializer_list<_Tp> __l, _Compare __comp)
                    { return *std::max_element(__l.begin(), __l.end(), __comp); }
                
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_Tp, _Tp>
                    minmax(initializer_list<_Tp> __l)
                    {
                      pair<const _Tp*, const _Tp*> __p =
                	std::minmax_element(__l.begin(), __l.end());
                      return std::make_pair(*__p.first, *__p.second);
                    }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_Tp, _Tp>
                    minmax(initializer_list<_Tp> __l, _Compare __comp)
                    {
                      pair<const _Tp*, const _Tp*> __p =
                	std::minmax_element(__l.begin(), __l.end(), __comp);
                      return std::make_pair(*__p.first, *__p.second);
                    }
                
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    bool
                    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		     _ForwardIterator2 __first2, _BinaryPredicate __pred)
                    {
                      // Efficiently compare identical prefixes:  O(N) if sequences
                      // have the same elements in the same order.
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!__pred(__first1, __first2))
                	  break;
                
                      if (__first1 == __last1)
                	return true;
                
                      // Establish __last2 assuming equal ranges by iterating over the
                      // rest of the list.
                      _ForwardIterator2 __last2 = __first2;
                      std::advance(__last2, std::distance(__first1, __last1));
                      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                	{
                	  if (__scan != std::__find_if(__first1, __scan,
                			  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                	    continue; // We've seen this one before.
                	  
                	  auto __matches
                	    = std::__count_if(__first2, __last2,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
                	  if (0 == __matches ||
                	      std::__count_if(__scan, __last1,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
                	      != __matches)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
                   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
                   *          returns true; otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                		typename iterator_traits<_ForwardIterator1>::value_type,
                		typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__is_permutation(__first1, __last1, __first2,
                				   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __pred    A binary predicate.
                   *  @return true if there exists a permutation of the elements in
                   *          the range [__first2, __first2 + (__last1 - __first1)),
                   *          beginning with ForwardIterator2 begin, such that
                   *          equal(__first1, __last1, __begin, __pred) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__is_permutation(__first1, __last1, __first2,
                				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
                    }
                
                #if __cplusplus > 201103L
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    bool
                    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                		     _BinaryPredicate __pred)
                    {
                      using _Cat1
                	= typename iterator_traits<_ForwardIterator1>::iterator_category;
                      using _Cat2
                	= typename iterator_traits<_ForwardIterator2>::iterator_category;
                      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
                      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
                      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
                      if (__ra_iters)
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	}
                
                      // Efficiently compare identical prefixes:  O(N) if sequences
                      // have the same elements in the same order.
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!__pred(__first1, __first2))
                	  break;
                
                      if (__ra_iters)
                	{
                	  if (__first1 == __last1)
                	    return true;
                	}
                      else
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 == 0 && __d2 == 0)
                	    return true;
                	  if (__d1 != __d2)
                	    return false;
                	}
                
                      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                	{
                	  if (__scan != std::__find_if(__first1, __scan,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                	    continue; // We've seen this one before.
                
                	  auto __matches = std::__count_if(__first2, __last2,
                		__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
                	  if (0 == __matches
                	      || std::__count_if(__scan, __last1,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
                	      != __matches)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  @brief  Checks whether a permutaion of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of first range.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __last2), beginning with ForwardIterator2 begin,
                   *          such that equal(__first1, __last1, begin) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return
                	std::__is_permutation(__first1, __last1, __first2, __last2,
                			      __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of first range.
                   *  @param  __pred    A binary predicate.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __last2), beginning with ForwardIterator2 begin,
                   *          such that equal(__first1, __last1, __begin, __pred) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                		   _BinaryPredicate __pred)
                    {
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__is_permutation(__first1, __last1, __first2, __last2,
                				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
                    }
                
                #if __cplusplus > 201402L
                
                #define __cpp_lib_clamp 201603
                
                  /**
                   *  @brief  Returns the value clamped between lo and hi.
                   *  @ingroup sorting_algorithms
                   *  @param  __val  A value of arbitrary type.
                   *  @param  __lo   A lower limit of arbitrary type.
                   *  @param  __hi   An upper limit of arbitrary type.
                   *  @return max(__val, __lo) if __val < __hi or min(__val, __hi) otherwise.
                   */
                  template<typename _Tp>
                    constexpr const _Tp&
                    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
                    {
                      __glibcxx_assert(!(__hi < __lo));
                      return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
                    }
                
                  /**
                   *  @brief  Returns the value clamped between lo and hi.
                   *  @ingroup sorting_algorithms
                   *  @param  __val   A value of arbitrary type.
                   *  @param  __lo    A lower limit of arbitrary type.
                   *  @param  __hi    An upper limit of arbitrary type.
                   *  @param  __comp  A comparison functor.
                   *  @return max(__val, __lo, __comp) if __comp(__val, __hi)
                   *	      or min(__val, __hi, __comp) otherwise.
                   */
                  template<typename _Tp, typename _Compare>
                    constexpr const _Tp&
                    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
                    {
                      __glibcxx_assert(!__comp(__hi, __lo));
                      return __comp(__val, __lo) ? __lo : __comp(__hi, __val) ? __hi : __val;
                    }
                #endif // C++17
                #endif // C++14
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  /**
                   *  @brief Generate two uniformly distributed integers using a
                   *         single distribution invocation.
                   *  @param  __b0    The upper bound for the first integer.
                   *  @param  __b1    The upper bound for the second integer.
                   *  @param  __g     A UniformRandomBitGenerator.
                   *  @return  A pair (i, j) with i and j uniformly distributed
                   *           over [0, __b0) and [0, __b1), respectively.
                   *
                   *  Requires: __b0 * __b1 <= __g.max() - __g.min().
                   *
                   *  Using uniform_int_distribution with a range that is very
                   *  small relative to the range of the generator ends up wasting
                   *  potentially expensively generated randomness, since
                   *  uniform_int_distribution does not store leftover randomness
                   *  between invocations.
                   *
                   *  If we know we want two integers in ranges that are sufficiently
                   *  small, we can compose the ranges, use a single distribution
                   *  invocation, and significantly reduce the waste.
                  */
                  template<typename _IntType, typename _UniformRandomBitGenerator>
                    pair<_IntType, _IntType>
                    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
                			   _UniformRandomBitGenerator&& __g)
                    {
                      _IntType __x
                	= uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
                      return std::make_pair(__x / __b1, __x % __b1);
                    }
                
                  /**
                   *  @brief Shuffle the elements of a sequence using a uniform random
                   *         number generator.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
                   *  @return  Nothing.
                   *
                   *  Reorders the elements in the range @p [__first,__last) using @p __g to
                   *  provide random numbers.
                  */
                  template<typename _RandomAccessIterator,
                	   typename _UniformRandomNumberGenerator>
                    void
                    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	    _UniformRandomNumberGenerator&& __g)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return;
                
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_DistanceType;
                
                      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
                      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
                      typedef typename __distr_type::param_type __p_type;
                
                      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
                	_Gen;
                      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
                	__uc_type;
                
                      const __uc_type __urngrange = __g.max() - __g.min();
                      const __uc_type __urange = __uc_type(__last - __first);
                
                      if (__urngrange / __urange >= __urange)
                        // I.e. (__urngrange >= __urange * __urange) but without wrap issues.
                      {
                	_RandomAccessIterator __i = __first + 1;
                
                	// Since we know the range isn't empty, an even number of elements
                	// means an uneven number of elements /to swap/, in which case we
                	// do the first one up front:
                
                	if ((__urange % 2) == 0)
                	{
                	  __distr_type __d{0, 1};
                	  std::iter_swap(__i++, __first + __d(__g));
                	}
                
                	// Now we know that __last - __i is even, so we do the rest in pairs,
                	// using a single distribution invocation to produce swap positions
                	// for two successive elements at a time:
                
                	while (__i != __last)
                	{
                	  const __uc_type __swap_range = __uc_type(__i - __first) + 1;
                
                	  const pair<__uc_type, __uc_type> __pospos =
                	    __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);
                
                	  std::iter_swap(__i++, __first + __pospos.first);
                	  std::iter_swap(__i++, __first + __pospos.second);
                	}
                
                	return;
                      }
                
                      __distr_type __d;
                
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
                    }
                #endif
                
                #endif // C++11
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Apply a function to every element of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __f      A unary function object.
                   *  @return   @p __f
                   *
                   *  Applies the function object @p __f to each element in the range
                   *  @p [first,last).  @p __f must not modify the order of the sequence.
                   *  If @p __f has a return value it is ignored.
                  */
                  template<typename _InputIterator, typename _Function>
                    _Function
                    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                      for (; __first != __last; ++__first)
                	__f(*__first);
                      return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.
                    }
                
                #if __cplusplus >= 201703L
                  /**
                   *  @brief Apply a function to every element of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __n      A value convertible to an integer.
                   *  @param  __f      A unary function object.
                   *  @return   `__first+__n`
                   *
                   *  Applies the function object `__f` to each element in the range
                   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.
                   *  If `__f` has a return value it is ignored.
                  */
                  template<typename _InputIterator, typename _Size, typename _Function>
                    _InputIterator
                    for_each_n(_InputIterator __first, _Size __n, _Function __f)
                    {
                      typename iterator_traits<_InputIterator>::difference_type __n2 = __n;
                      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
                      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)
                	{
                	  if (__n2 <= 0)
                	    return __first;
                	  auto __last = __first + __n2;
                	  std::for_each(__first, __last, std::move(__f));
                	  return __last;
                	}
                      else
                	{
                	  while (__n2-->0)
                	    {
                	      __f(*__first);
                	      ++__first;
                	    }
                	  return __first;
                	}
                    }
                #endif // C++17
                
                  /**
                   *  @brief Find the first occurrence of a value in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __val    The value to find.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Tp>
                    inline _InputIterator
                    find(_InputIterator __first, _InputIterator __last,
                	 const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                		typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__iter_equals_val(__val));
                    }
                
                  /**
                   *  @brief Find the first element in a sequence for which a
                   *         predicate is true.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline _InputIterator
                    find_if(_InputIterator __first, _InputIterator __last,
                	    _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief  Find element from a set in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of match candidates.
                   *  @param  __last2   End of match candidates.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
                   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for an element that is
                   *  equal to some element in the range [__first2,__last2).  If
                   *  found, returns an iterator in the range [__first1,__last1),
                   *  otherwise returns @p __last1.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    _InputIterator
                    find_first_of(_InputIterator __first1, _InputIterator __last1,
                		  _ForwardIterator __first2, _ForwardIterator __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1; ++__first1)
                	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                	  if (*__first1 == *__iter)
                	    return __first1;
                      return __last1;
                    }
                
                  /**
                   *  @brief  Find element from a set in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of match candidates.
                   *  @param  __last2   End of match candidates.
                   *  @param  __comp    Predicate to use.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
                   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
                   *  such iterator exists.
                   *
                
                   *  Searches the range @p [__first1,__last1) for an element that is
                   *  equal to some element in the range [__first2,__last2).  If
                   *  found, returns an iterator in the range [__first1,__last1),
                   *  otherwise returns @p __last1.
                  */
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _BinaryPredicate>
                    _InputIterator
                    find_first_of(_InputIterator __first1, _InputIterator __last1,
                		  _ForwardIterator __first2, _ForwardIterator __last2,
                		  _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_InputIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1; ++__first1)
                	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                	  if (__comp(*__first1, *__iter))
                	    return __first1;
                      return __last1;
                    }
                
                  /**
                   *  @brief Find two adjacent values in a sequence that are equal.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
                   *  or @p __last if no such iterator exists.
                  */
                  template<typename _ForwardIterator>
                    inline _ForwardIterator
                    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__adjacent_find(__first, __last,
                				  __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Find two adjacent values in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first         A forward iterator.
                   *  @param  __last          A forward iterator.
                   *  @param  __binary_pred   A binary predicate.
                   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                   *  valid iterators in @p [__first,__last) and such that
                   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
                   *  exists.
                  */
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    inline _ForwardIterator
                    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                		  _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__adjacent_find(__first, __last,
                			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                  /**
                   *  @brief Count the number of copies of a value in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __value  The value to be counted.
                   *  @return   The number of iterators @c i in the range @p [__first,__last)
                   *  for which @c *i == @p __value
                  */
                  template<typename _InputIterator, typename _Tp>
                    inline typename iterator_traits<_InputIterator>::difference_type
                    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__count_if(__first, __last,
                			     __gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Count the elements of a sequence for which a predicate is true.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The number of iterators @c i in the range @p [__first,__last)
                   *  for which @p __pred(*i) is true.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    inline typename iterator_traits<_InputIterator>::difference_type
                    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__count_if(__first, __last,
                			     __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief Search a sequence for a matching sub-sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @param  __last2   A forward iterator.
                   *  @return The first iterator @c i in the range @p
                   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
                   *  *(__first2+N) for each @c N in the range @p
                   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) and returns an iterator to the first element
                   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
                   *  found.
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.
                   *
                   *  This means that the returned iterator @c i will be in the range
                   *  @p [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    inline _ForwardIterator1
                    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__search(__first1, __last1, __first2, __last2,
                			   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Search a sequence for a matching sub-sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1     A forward iterator.
                   *  @param  __last1      A forward iterator.
                   *  @param  __first2     A forward iterator.
                   *  @param  __last2      A forward iterator.
                   *  @param  __predicate  A binary predicate.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1-(__last2-__first2)) such that
                   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
                   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2), using @p __predicate to determine equality,
                   *  and returns an iterator to the first element of the
                   *  sub-sequence, or @p __last1 if no such iterator exists.
                   *
                   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    inline _ForwardIterator1
                    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	   _BinaryPredicate  __predicate)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__search(__first1, __last1, __first2, __last2,
                			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
                    }
                
                  /**
                   *  @brief Search a sequence for a number of consecutive values.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __count  The number of consecutive values.
                   *  @param  __val    The value to find.
                   *  @return The first iterator @c i in the range @p
                   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
                   *  each @c N in the range @p [0,__count), or @p __last if no such
                   *  iterator exists.
                   *
                   *  Searches the range @p [__first,__last) for @p count consecutive elements
                   *  equal to @p __val.
                  */
                  template<typename _ForwardIterator, typename _Integer, typename _Tp>
                    inline _ForwardIterator
                    search_n(_ForwardIterator __first, _ForwardIterator __last,
                	     _Integer __count, const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__search_n(__first, __last, __count,
                			     __gnu_cxx::__ops::__iter_equals_val(__val));
                    }
                
                
                  /**
                   *  @brief Search a sequence for a number of consecutive values using a
                   *         predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __count        The number of consecutive values.
                   *  @param  __val          The value to find.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return The first iterator @c i in the range @p
                   *  [__first,__last-__count) such that @p
                   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
                   *  @p [0,__count), or @p __last if no such iterator exists.
                   *
                   *  Searches the range @p [__first,__last) for @p __count
                   *  consecutive elements for which the predicate returns true.
                  */
                  template<typename _ForwardIterator, typename _Integer, typename _Tp,
                	   typename _BinaryPredicate>
                    inline _ForwardIterator
                    search_n(_ForwardIterator __first, _ForwardIterator __last,
                	     _Integer __count, const _Tp& __val,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__search_n(__first, __last, __count,
                		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
                    }
                
                #if __cplusplus > 201402L
                  /** @brief Search a sequence using a Searcher object.
                   *
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __searcher     A callable object.
                   *  @return @p __searcher(__first,__last).first
                  */
                  template<typename _ForwardIterator, typename _Searcher>
                    inline _ForwardIterator
                    search(_ForwardIterator __first, _ForwardIterator __last,
                	   const _Searcher& __searcher)
                    { return __searcher(__first, __last).first; }
                #endif
                
                  /**
                   *  @brief Perform an operation on a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first     An input iterator.
                   *  @param  __last      An input iterator.
                   *  @param  __result    An output iterator.
                   *  @param  __unary_op  A unary operator.
                   *  @return   An output iterator equal to @p __result+(__last-__first).
                   *
                   *  Applies the operator to each element in the input range and assigns
                   *  the results to successive elements of the output sequence.
                   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
                   *  range @p [0,__last-__first).
                   *
                   *  @p unary_op must not alter its argument.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _UnaryOperation>
                    _OutputIterator
                    transform(_InputIterator __first, _InputIterator __last,
                	      _OutputIterator __result, _UnaryOperation __unary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _UnaryOperation"
                	    __typeof__(__unary_op(*__first))>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first, (void)++__result)
                	*__result = __unary_op(*__first);
                      return __result;
                    }
                
                  /**
                   *  @brief Perform an operation on corresponding elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1     An input iterator.
                   *  @param  __last1      An input iterator.
                   *  @param  __first2     An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __binary_op  A binary operator.
                   *  @return   An output iterator equal to @p result+(last-first).
                   *
                   *  Applies the operator to the corresponding elements in the two
                   *  input ranges and assigns the results to successive elements of the
                   *  output sequence.
                   *  Evaluates @p
                   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
                   *  @c N in the range @p [0,__last1-__first1).
                   *
                   *  @p binary_op must not alter either of its arguments.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _BinaryOperation>
                    _OutputIterator
                    transform(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _OutputIterator __result,
                	      _BinaryOperation __binary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _BinaryOperation"
                	    __typeof__(__binary_op(*__first1,*__first2))>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
                	*__result = __binary_op(*__first1, *__first2);
                      return __result;
                    }
                
                  /**
                   *  @brief Replace each occurrence of one value in a sequence with another
                   *         value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      A forward iterator.
                   *  @param  __last       A forward iterator.
                   *  @param  __old_value  The value to be replaced.
                   *  @param  __new_value  The replacement value.
                   *  @return   replace() returns no value.
                   *
                   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
                   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    void
                    replace(_ForwardIterator __first, _ForwardIterator __last,
                	    const _Tp& __old_value, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (*__first == __old_value)
                	  *__first = __new_value;
                    }
                
                  /**
                   *  @brief Replace each value in a sequence for which a predicate returns
                   *         true with another value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      A forward iterator.
                   *  @param  __last       A forward iterator.
                   *  @param  __pred       A predicate.
                   *  @param  __new_value  The replacement value.
                   *  @return   replace_if() returns no value.
                   *
                   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
                   *  is true then the assignment @c *i = @p __new_value is performed.
                  */
                  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
                    void
                    replace_if(_ForwardIterator __first, _ForwardIterator __last,
                	       _Predicate __pred, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  *__first = __new_value;
                    }
                
                  /**
                   *  @brief Assign the result of a function object to each value in a
                   *         sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __gen    A function object taking no arguments and returning
                   *                 std::iterator_traits<_ForwardIterator>::value_type
                   *  @return   generate() returns no value.
                   *
                   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                   *  @p [__first,__last).
                  */
                  template<typename _ForwardIterator, typename _Generator>
                    void
                    generate(_ForwardIterator __first, _ForwardIterator __last,
                	     _Generator __gen)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_GeneratorConcept<_Generator,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	*__first = __gen();
                    }
                
                  /**
                   *  @brief Assign the result of a function object to each value in a
                   *         sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __n      The length of the sequence.
                   *  @param  __gen    A function object taking no arguments and returning
                   *                 std::iterator_traits<_ForwardIterator>::value_type
                   *  @return   The end of the sequence, @p __first+__n
                   *
                   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                   *  @p [__first,__first+__n).
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 865. More algorithms that throw away information
                  */
                  template<typename _OutputIterator, typename _Size, typename _Generator>
                    _OutputIterator
                    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _Generator"
                	    __typeof__(__gen())>)
                
                      for (__decltype(__n + 0) __niter = __n;
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __gen();
                      return __first;
                    }
                
                  /**
                   *  @brief Copy a sequence, removing consecutive duplicate values.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  beginning at @p __result, except that only the first element is copied
                   *  from groups of consecutive elements that compare equal.
                   *  unique_copy() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                   *  
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
                   *  Assignable?
                  */
                  template<typename _InputIterator, typename _OutputIterator>
                    inline _OutputIterator
                    unique_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      return std::__unique_copy(__first, __last, __result,
                				__gnu_cxx::__ops::__iter_equal_to_iter(),
                				std::__iterator_category(__first),
                				std::__iterator_category(__result));
                    }
                
                  /**
                   *  @brief Copy a sequence, removing consecutive values using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first        An input iterator.
                   *  @param  __last         An input iterator.
                   *  @param  __result       An output iterator.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  beginning at @p __result, except that only the first element is copied
                   *  from groups of consecutive elements for which @p __binary_pred returns
                   *  true.
                   *  unique_copy() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    inline _OutputIterator
                    unique_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result,
                		_BinaryPredicate __binary_pred)
                    {
                      // concept requirements -- predicates checked later
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      return std::__unique_copy(__first, __last, __result,
                			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
                				std::__iterator_category(__first),
                				std::__iterator_category(__result));
                    }
                
                #if _GLIBCXX_HOSTED
                  /**
                   *  @brief Randomly shuffle the elements of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @return  Nothing.
                   *
                   *  Reorder the elements in the range @p [__first,__last) using a random
                   *  distribution, so that every possible ordering of the sequence is
                   *  equally likely.
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first != __last)
                	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	  {
                	    // XXX rand() % N is not uniformly distributed
                	    _RandomAccessIterator __j = __first
                					+ std::rand() % ((__i - __first) + 1);
                	    if (__i != __j)
                	      std::iter_swap(__i, __j);
                	  }
                    }
                #endif
                
                  /**
                   *  @brief Shuffle the elements of a sequence using a random number
                   *         generator.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __rand    The RNG functor or function.
                   *  @return  Nothing.
                   *
                   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
                   *  provide a random distribution. Calling @p __rand(N) for a positive
                   *  integer @p N should return a randomly chosen integer from the
                   *  range [0,N).
                  */
                  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
                    void
                    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                #if __cplusplus >= 201103L
                		   _RandomNumberGenerator&& __rand)
                #else
                		   _RandomNumberGenerator& __rand)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return;
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	{
                	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
                	  if (__i != __j)
                	    std::iter_swap(__i, __j);
                	}
                    }
                
                
                  /**
                   *  @brief Move elements for which a predicate is true to the beginning
                   *         of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __pred    A predicate functor.
                   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                   *  iterator @p i in the range @p [__first,middle) and false for each @p i
                   *  in the range @p [middle,__last).
                   *
                   *  @p __pred must not modify its operand. @p partition() does not preserve
                   *  the relative ordering of elements in each group, use
                   *  @p stable_partition() if this is needed.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    inline _ForwardIterator
                    partition(_ForwardIterator __first, _ForwardIterator __last,
                	      _Predicate   __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__partition(__first, __last, __pred,
                			      std::__iterator_category(__first));
                    }
                
                
                  /**
                   *  @brief Sort the smallest elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the smallest @p (__middle-__first) elements in the range
                   *  @p [first,last) and moves them to the range @p [__first,__middle). The
                   *  order of the remaining elements in the range @p [__middle,__last) is
                   *  undefined.
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    partial_sort(_RandomAccessIterator __first,
                		 _RandomAccessIterator __middle,
                		 _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__partial_sort(__first, __middle, __last,
                			  __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the smallest elements of a sequence using a predicate
                   *         for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the smallest @p (__middle-__first) elements in the range
                   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
                   *  order of the remaining elements in the range @p [__middle,__last) is
                   *  undefined.
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
                   *  are both false.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    partial_sort(_RandomAccessIterator __first,
                		 _RandomAccessIterator __middle,
                		 _RandomAccessIterator __last,
                		 _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__partial_sort(__first, __middle, __last,
                			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Sort a sequence just enough to find a particular position.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __nth     Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                   *  is the same element that would have been in that position had the
                   *  whole sequence been sorted. The elements either side of @p *__nth are
                   *  not completely sorted, but for any iterator @e i in the range
                   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                   *  holds that *j < *i is false.
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		_RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __nth);
                      __glibcxx_requires_valid_range(__nth, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      if (__first == __last || __nth == __last)
                	return;
                
                      std::__introselect(__first, __nth, __last,
                			 std::__lg(__last - __first) * 2,
                			 __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort a sequence just enough to find a particular position
                   *         using a predicate for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __nth     Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                   *  is the same element that would have been in that position had the
                   *  whole sequence been sorted. The elements either side of @p *__nth are
                   *  not completely sorted, but for any iterator @e i in the range
                   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                   *  holds that @p __comp(*j,*i) is false.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		_RandomAccessIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __nth);
                      __glibcxx_requires_valid_range(__nth, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      if (__first == __last || __nth == __last)
                	return;
                
                      std::__introselect(__first, __nth, __last,
                			 std::__lg(__last - __first) * 2,
                			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @e i in the range @p [__first,__last-1),  
                   *  *(i+1)<*i is false.
                   *
                   *  The relative ordering of equivalent elements is not preserved, use
                   *  @p stable_sort() if this is needed.
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence using a predicate for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
                   *  range @p [__first,__last-1).
                   *
                   *  The relative ordering of equivalent elements is not preserved, use
                   *  @p stable_sort() if this is needed.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
           1 ->     sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	 _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _OutputIterator
                    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	    _InputIterator2 __first2, _InputIterator2 __last2,
                	    _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = *__first2;
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      return std::copy(__first2, __last2,
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief Merges two sorted ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An iterator.
                   *  @param  __first2  Another iterator.
                   *  @param  __last1   Another iterator.
                   *  @param  __last2   Another iterator.
                   *  @param  __result  An iterator pointing to the end of the merged range.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @e val.
                   *
                   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                   *  the sorted range @p [__result, __result + (__last1-__first1) +
                   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                   *  output range must not overlap with either of the input ranges.
                   *  The sort is @e stable, that is, for equivalent elements in the
                   *  two ranges, elements from the first range will always come
                   *  before elements from the second.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    inline _OutputIterator
                    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2, _InputIterator2 __last2,
                	  _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__merge(__first1, __last1,
                				     __first2, __last2, __result,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Merges two sorted ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An iterator.
                   *  @param  __first2  Another iterator.
                   *  @param  __last1   Another iterator.
                   *  @param  __last2   Another iterator.
                   *  @param  __result  An iterator pointing to the end of the merged range.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return         An iterator pointing to the first element "not less
                   *                  than" @e val.
                   *
                   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                   *  the sorted range @p [__result, __result + (__last1-__first1) +
                   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                   *  output range must not overlap with either of the input ranges.
                   *  The sort is @e stable, that is, for equivalent elements in the
                   *  two ranges, elements from the first range will always come
                   *  before elements from the second.
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    inline _OutputIterator
                    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2, _InputIterator2 __last2,
                	  _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__merge(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                		  _Compare __comp)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_DistanceType;
                
                      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
                      _TmpBuf __buf(__first, std::distance(__first, __last));
                
                      if (__buf.begin() == 0)
                	std::__inplace_stable_sort(__first, __last, __comp);
                      else
                	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
                				    _DistanceType(__buf.size()), __comp);
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence, preserving the relative order
                   *         of equivalent elements.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @p i in the range @p [__first,__last-1),
                   *  @p *(i+1)<*i is false.
                   *
                   *  The relative ordering of equivalent elements is preserved, so any two
                   *  elements @p x and @p y in the range @p [__first,__last) such that
                   *  @p x<y is false and @p y<x is false will have the same relative
                   *  ordering after calling @p stable_sort().
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      _GLIBCXX_STD_A::__stable_sort(__first, __last,
                				    __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence using a predicate for comparison,
                   *         preserving the relative order of equivalent elements.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @p i in the range @p [__first,__last-1),
                   *  @p __comp(*(i+1),*i) is false.
                   *
                   *  The relative ordering of equivalent elements is preserved, so any two
                   *  elements @p x and @p y in the range @p [__first,__last) such that
                   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
                   *  relative ordering after calling @p stable_sort().
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      _GLIBCXX_STD_A::__stable_sort(__first, __last,
                				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                		_InputIterator2 __first2, _InputIterator2 __last2,
                		_OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first1, __first2))
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	    }
                	  else if (__comp(__first2, __first1))
                	    {
                	      *__result = *__first2;
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	      ++__first2;
                	    }
                	  ++__result;
                	}
                      return std::copy(__first2, __last2,
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief Return the union of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  each range in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other,
                   *  that element is copied and the iterator advanced.  If an element is
                   *  contained in both ranges, the element from the first range is copied and
                   *  both ranges advance.  The output range may not overlap either input
                   *  range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    inline _OutputIterator
                    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _InputIterator2 __last2,
                	      _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Return the union of two sorted ranges using a comparison functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  each range in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other
                   *  according to @p __comp, that element is copied and the iterator advanced.
                   *  If an equivalent element according to @p __comp is contained in both
                   *  ranges, the element from the first range is copied and both ranges
                   *  advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    inline _OutputIterator
                    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _InputIterator2 __last2,
                	      _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		       _InputIterator2 __first2, _InputIterator2 __last2,
                		       _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  ++__first1;
                	else if (__comp(__first2, __first1))
                	  ++__first2;
                	else
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__first2;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Return the intersection of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  both ranges in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other,
                   *  that iterator advances.  If an element is contained in both ranges, the
                   *  element from the first range is copied and both ranges advance.  The
                   *  output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    inline _OutputIterator
                    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
                				     __first2, __last2, __result,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Return the intersection of two sorted ranges using comparison
                   *  functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  both ranges in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other
                   *  according to @p __comp, that iterator advances.  If an element is
                   *  contained in both ranges according to @p __comp, the element from the
                   *  first range is copied and both ranges advance.  The output range may not
                   *  overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    inline _OutputIterator
                    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__result;
                	  }
                	else if (__comp(__first2, __first1))
                	  ++__first2;
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                      return std::copy(__first1, __last1, __result);
                    }
                
                  /**
                   *  @brief Return the difference of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  the first range but not the second in order to the output range.
                   *  Iterators increment for each range.  When the current element of the
                   *  first range is less than the second, that element is copied and the
                   *  iterator advances.  If the current element of the second range is less,
                   *  the iterator advances, but no element is copied.  If an element is
                   *  contained in both ranges, no elements are copied and both ranges
                   *  advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    inline _OutputIterator
                    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		   _InputIterator2 __first2, _InputIterator2 __last2,
                		   _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
                				   __first2, __last2, __result,
                				   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the difference of two sorted ranges using comparison
                   *  functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  the first range but not the second in order to the output range.
                   *  Iterators increment for each range.  When the current element of the
                   *  first range is less than the second according to @p __comp, that element
                   *  is copied and the iterator advances.  If the current element of the
                   *  second range is less, no element is copied and the iterator advances.
                   *  If an element is contained in both ranges according to @p __comp, no
                   *  elements are copied and both ranges advance.  The output range may not
                   *  overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    inline _OutputIterator
                    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		   _InputIterator2 __first2, _InputIterator2 __last2,
                		   _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
                				   __first2, __last2, __result,
                				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __set_symmetric_difference(_InputIterator1 __first1,
                			       _InputIterator1 __last1,
                			       _InputIterator2 __first2,
                			       _InputIterator2 __last2,
                			       _OutputIterator __result,
                			       _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__result;
                	  }
                	else if (__comp(__first2, __first1))
                	  {
                	    *__result = *__first2;
                	    ++__first2;
                	    ++__result;
                	  }
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                      return std::copy(__first2, __last2, 
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief  Return the symmetric difference of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  one range but not the other in order to the output range.  Iterators
                   *  increment for each range.  When the current element of one range is less
                   *  than the other, that element is copied and the iterator advances.  If an
                   *  element is contained in both ranges, no elements are copied and both
                   *  ranges advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    inline _OutputIterator
                    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                			     _InputIterator2 __first2, _InputIterator2 __last2,
                			     _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
                					__first2, __last2, __result,
                					__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the symmetric difference of two sorted ranges using
                   *  comparison functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  one range but not the other in order to the output range.  Iterators
                   *  increment for each range.  When the current element of one range is less
                   *  than the other according to @p comp, that element is copied and the
                   *  iterator advances.  If an element is contained in both ranges according
                   *  to @p __comp, no elements are copied and both ranges advance.  The output
                   *  range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    inline _OutputIterator
                    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                			     _InputIterator2 __first2, _InputIterator2 __last2,
                			     _OutputIterator __result,
                			     _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    __min_element(_ForwardIterator __first, _ForwardIterator __last,
                		  _Compare __comp)
                    {
                      if (__first == __last)
                	return __first;
                      _ForwardIterator __result = __first;
                      while (++__first != __last)
                	if (__comp(__first, __result))
                	  __result = __first;
                      return __result;
                    }
                
                  /**
                   *  @brief  Return the minimum element in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  Iterator referencing the first instance of the smallest value.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return _GLIBCXX_STD_A::__min_element(__first, __last,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the minimum element in a range using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  Iterator referencing the first instance of the smallest value
                   *  according to __comp.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    min_element(_ForwardIterator __first, _ForwardIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return _GLIBCXX_STD_A::__min_element(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    __max_element(_ForwardIterator __first, _ForwardIterator __last,
                		  _Compare __comp)
                    {
                      if (__first == __last) return __first;
                      _ForwardIterator __result = __first;
                      while (++__first != __last)
                	if (__comp(__result, __first))
                	  __result = __first;
                      return __result;
                    }
                
                  /**
                   *  @brief  Return the maximum element in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  Iterator referencing the first instance of the largest value.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    max_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return _GLIBCXX_STD_A::__max_element(__first, __last,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the maximum element in a range using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  Iterator referencing the first instance of the largest value
                   *  according to __comp.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    max_element(_ForwardIterator __first, _ForwardIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return _GLIBCXX_STD_A::__max_element(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cplusplus >= 201402L
                  /// Reservoir sampling algorithm.
                  template<typename _InputIterator, typename _RandomAccessIterator,
                           typename _Size, typename _UniformRandomBitGenerator>
                    _RandomAccessIterator
                    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
                	     _RandomAccessIterator __out, random_access_iterator_tag,
                	     _Size __n, _UniformRandomBitGenerator&& __g)
                    {
                      using __distrib_type = uniform_int_distribution<_Size>;
                      using __param_type = typename __distrib_type::param_type;
                      __distrib_type __d{};
                      _Size __sample_sz = 0;
                      while (__first != __last && __sample_sz != __n)
                	{
                	  __out[__sample_sz++] = *__first;
                	  ++__first;
                	}
                      for (auto __pop_sz = __sample_sz; __first != __last;
                	  ++__first, (void) ++__pop_sz)
                	{
                	  const auto __k = __d(__g, __param_type{0, __pop_sz});
                	  if (__k < __n)
                	    __out[__k] = *__first;
                	}
                      return __out + __sample_sz;
                    }
                
                  /// Selection sampling algorithm.
                  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
                           typename _Size, typename _UniformRandomBitGenerator>
                    _OutputIterator
                    __sample(_ForwardIterator __first, _ForwardIterator __last,
                	     forward_iterator_tag,
                	     _OutputIterator __out, _Cat,
                	     _Size __n, _UniformRandomBitGenerator&& __g)
                    {
                      using __distrib_type = uniform_int_distribution<_Size>;
                      using __param_type = typename __distrib_type::param_type;
                      using _USize = make_unsigned_t<_Size>;
                      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
                      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
                
                      if (__first == __last)
                	return __out;
                
                      __distrib_type __d{};
                      _Size __unsampled_sz = std::distance(__first, __last);
                      __n = std::min(__n, __unsampled_sz);
                
                      // If possible, we use __gen_two_uniform_ints to efficiently produce
                      // two random numbers using a single distribution invocation:
                
                      const __uc_type __urngrange = __g.max() - __g.min();
                      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))
                        // I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without
                	// wrapping issues.
                        {
                	  while (__n != 0 && __unsampled_sz >= 2)
                	    {
                	      const pair<_Size, _Size> __p =
                		__gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);
                
                	      --__unsampled_sz;
                	      if (__p.first < __n)
                		{
                		  *__out++ = *__first;
                		  --__n;
                		}
                
                	      ++__first;
                
                	      if (__n == 0) break;
                
                	      --__unsampled_sz;
                	      if (__p.second < __n)
                		{
                		  *__out++ = *__first;
                		  --__n;
                		}
                
                	      ++__first;
                	    }
                        }
                
                      // The loop above is otherwise equivalent to this one-at-a-time version:
                
                      for (; __n != 0; ++__first)
                	if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
                	  {
                	    *__out++ = *__first;
                	    --__n;
                	  }
                      return __out;
                    }
                
                #if __cplusplus > 201402L
                #define __cpp_lib_sample 201603
                  /// Take a random sample from a population.
                  template<typename _PopulationIterator, typename _SampleIterator,
                           typename _Distance, typename _UniformRandomBitGenerator>
                    _SampleIterator
                    sample(_PopulationIterator __first, _PopulationIterator __last,
                	   _SampleIterator __out, _Distance __n,
                	   _UniformRandomBitGenerator&& __g)
                    {
                      using __pop_cat = typename
                	std::iterator_traits<_PopulationIterator>::iterator_category;
                      using __samp_cat = typename
                	std::iterator_traits<_SampleIterator>::iterator_category;
                
                      static_assert(
                	  __or_<is_convertible<__pop_cat, forward_iterator_tag>,
                		is_convertible<__samp_cat, random_access_iterator_tag>>::value,
                	  "output range must use a RandomAccessIterator when input range"
                	  " does not meet the ForwardIterator requirements");
                
                      static_assert(is_integral<_Distance>::value,
                		    "sample size must be an integer type");
                
                      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
                      return _GLIBCXX_STD_A::
                	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
                		 std::forward<_UniformRandomBitGenerator>(__g));
                    }
                #endif // C++17
                #endif // C++14
                
                _GLIBCXX_END_NAMESPACE_ALGO
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_ALGO_H */


Top 10 Lines:

     Line      Count

     1826        898
       78         94
     1901         94
     1922         94
     1845          1
     1868          1
     1885          1
     1945          1
     1968          1
     4893          1

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

     1186   Total number of line executions
    98.83   Average executions per line


*** File /mnt/c/VERČA/FJFI/PAA/vertex-coloring/profiling/./../src/greedy.cpp:
                #include <iostream>
                #include <vector>
                #include <string>
                #include <algorithm>
                #include <numeric>   // for iota
                #include <fstream>   // for writing DOT
                #include <unordered_set>
                using namespace std;
                
                // ---- DIMACS reader ----
           1 -> bool read_dimacs(int& n, int& m, vector<vector<int>>& adj) {
                    ios::sync_with_stdio(false); //disconnects c++ from c (scanf, printf), to make it faster
                    cin.tie(nullptr); // stops cin from flusing cout before reading
                    n = m = -1;
                    string line;
                    vector<pair<int,int>> edges;
                    while (true) {
                        string t;
                        if(!(cin >> t)) break;
                        if (t == "c") {
                            getline(cin, line); //skip commentline
                        } else if (t == "p") {
                            string kind;
                            cin >> kind >> n >> m;
                            if (n <= 0) return false;
                            adj.assign(n, {}); //reset adjacency table
                        } else if (t == "e") {
                            int a, b;
                            cin >> a >> b;
                            if (n <= 0) { cerr << "Missing 'p' line before edge declaration in the DIMACS file.\n"; return false;}
                            if (a == b) continue; // ignore self-loops
                            if (a < 1 || a > n || b < 1 || b > n) { cerr << "Edge out of range.\n"; return false;}
                            edges.emplace_back(a-1,b-1);   //convert to 0-based and store
                        } else {
                            //unknown token, continue
                            getline(cin, line);
                        }
                    }
                    if (n <= 0) return false;
                
                    // building adjacency, deduplication of multiedges
                    vector<unordered_set<int>> tmp(n); //store only unique integers
                    for (unsigned int i = 0; i < edges.size(); ++i) {
                        int u = edges[i].first;
                        int v = edges[i].second;
                        tmp[u].insert(v);
                        tmp[v].insert(u);
                    }
                    adj.assign(n, {});
                    for (int i=0;i<n;++i) {
                        adj[i] = vector<int>(tmp[i].begin(), tmp[i].end());
                    } 
                    return true;
                }
                
                // ---- Greedy coloring ------
           1 -> vector<int> greedy_color(const vector<vector<int>>& adj, const vector<int>& order) {
                    int n = (int)adj.size();
                    vector<int> color(n, -1), mark(n, -1); // n colors, initially -1; mark tracks forbidden colors
                    int stamp = 0; //timestamp to avoid clearing mark each time
                    for (int v : order) {
                        stamp++;
                        for (int u : adj[v]) { if (color[u] != -1) mark[color[u]] = stamp;}
                        int c = 0;
                        while (c < n && mark[c] == stamp) c++;
                        color[v] = c;
                    }
                    return color;
                }
                
                // sort vertices by descending degree and vertex id
           1 -> vector<int> desc_degree_order(const vector<vector<int>>& adj) {
                    int n = (int)adj.size();
                    vector<int> order(n);
                    iota(order.begin(), order.end(), 0);  // fill with 0..n-1
        9589 ->     sort(order.begin(), order.end(), [&](int a, int b) { //capture by reference from adj
                        if (adj[a].size() != adj[b].size())
                            return adj[a].size() > adj[b].size(); // higher degree first
                        return a < b; // tie: smaller index first
                    });
                    return order;
                }
                
                // ---- DOT writer ------
           1 -> void write_dot(const string& path, const vector<vector<int>>& adj, const vector<int>& color) {
                    static const vector<string> pal = {
                        "red","green","blue","gold","cyan","magenta","orange","purple","brown","pink",
                        "gray","turquoise","violet","chartreuse","salmon","tan","sienna","khaki","aquamarine","orchid"
                    };
                    int n = (int)adj.size();
                    ofstream out(path); //open out file streat
                    if (!out) {cerr << "Cannot open DOT output path.\n"; return; }
                    out << "graph G {\n";
                    out << "  layout=neato;\n  overlap=false;\n  splines=true;\n";
                    out << "  node [shape=circle, style=filled, fontname=Inter];\n";
                
                    // convert vertices indices back to 1-based like in dimacs
                    for (int v=0; v<n; ++v) {
                        int c = color[v];
                        string fill = pal[c % pal.size()];
                        out << "  " << (v+1) << " [label=\"" << (v+1) << "\", fillcolor=\"" << fill << "\", tooltip=\"v"
                            << (v+1) << " color " << c << "\"];\n";
                    }
                    // each undirected edge once
                    for (int u=0; u<n; ++u) {
                        for (int v: adj[u]) {
                            if (u < v) {
                                out << "  " << (u+1) << " -- " << (v+1) << ";\n";
                            } 
                        }
                    }
                    out << "}\n";
                    cerr << "DOT written to: " << path << "\n";
                }
                
                // ---- Main ------
                // uses the welsh-powell algo
       ##### -> int main(int argc, char** argv) {
                    string dot_path = "graph_colored.dot"; //default
                    for (int i=1; i<argc; ++i) { //arg[0] is program name
                        string a = argv[i];
                        if (a == "--dot" && i+1 < argc) { dot_path = argv[++i]; } //user dot filename
                        else if (a == "--help" || a == "-h") {
                            cerr << "Usage: greedy [--dot out.dot] < input.col\n";
                            return 0;
                        }
                    }
                
                    int n, m;
                    vector<vector<int>> adj;
                    if (!read_dimacs(n, m, adj)) { cerr << "Failed to read DIMACS from input file.\n"; return 1; }
                
                    vector<int> order = desc_degree_order(adj);
                    vector<int> color = greedy_color(adj, order);
                
                    int k = 0;
                    for (int c: color) {k = max(k, c+1);}
                    cout << "Used " << k << " colors" << "\n"; // number of colors used
                
                    write_dot(dot_path, adj, color);
                    return 0;
           2 -> }

Top 10 Lines:

     Line      Count

       76       9589
      142          2
       11          1
       57          1
       72          1
       85          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

     9595   Total number of line executions
  1370.71   Average executions per line
